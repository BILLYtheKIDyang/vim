<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>EmergencyElisp - RDoc Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
  var index_rel_prefix = "./";
</script>

<script src="./js/navigation.js" defer></script>
<script src="./js/search.js" defer></script>
<script src="./js/search_index.js" defer></script>
<script src="./js/searcher.js" defer></script>
<script src="./js/darkfish.js" defer></script>

<link href="./css/fonts.css" rel="stylesheet">
<link href="./css/rdoc.css" rel="stylesheet">




<body id="top" role="document" class="file">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="./index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="./table_of_contents.html#pages">Pages</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="project-metadata">
    <div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
  
    <li><a href="./'.html">&#39;</a>
  
    <li><a href="./24_pl.html">24.pl</a>
  
    <li><a href="./4748_test.html">4748.test</a>
  
    <li><a href="./7444_test.html">7444.test</a>
  
    <li><a href="./9_39_pl.html">9.39.pl</a>
  
    <li><a href="./A_java.html">A.java</a>
  
    <li><a href="./AdvancedPerl_pl.html">AdvancedPerl.pl</a>
  
    <li><a href="./ArrayDemo_java.html">ArrayDemo.java</a>
  
    <li><a href="./Devinitive_js.html">Devinitive.js</a>
  
    <li><a href="./EffectivePerl_pl.html">EffectivePerl.pl</a>
  
    <li><a href="./EmergencyElisp_txt.html">EmergencyElisp</a>
  
    <li><a href="./LiveLessons_pl.html">LiveLessons.pl</a>
  
    <li><a href="./LiveLessons_py.html">LiveLessons.py</a>
  
    <li><a href="./PERL_vim.html">PERL.vim</a>
  
    <li><a href="./Scheme_txt.html">Scheme</a>
  
    <li><a href="./a_clj.html">a.clj</a>
  
    <li><a href="./a_cs.html">a.cs</a>
  
    <li><a href="./a_hs.html">a.hs</a>
  
    <li><a href="./a_html.html">a.html</a>
  
    <li><a href="./a_js.html">a.js</a>
  
    <li><a href="./a_lisp.html">a.lisp</a>
  
    <li><a href="./a_pl.html">a.pl</a>
  
    <li><a href="./a_ps1.html">a.ps1</a>
  
    <li><a href="./a_py.html">a.py</a>
  
    <li><a href="./a_red.html">a.red</a>
  
    <li><a href="./a_scala.html">a.scala</a>
  
    <li><a href="./a_sml.html">a.sml</a>
  
    <li><a href="./a_vbs.html">a.vbs</a>
  
    <li><a href="./a_vim.html">a.vim</a>
  
    <li><a href="./b_js.html">b.js</a>
  
    <li><a href="./b_p6.html">b.p6</a>
  
    <li><a href="./b_pl.html">b.pl</a>
  
    <li><a href="./b_py.html">b.py</a>
  
    <li><a href="./bigpy-dir_py.html">bigpy-dir.py</a>
  
    <li><a href="./c_js.html">c.js</a>
  
    <li><a href="./c_pl.html">c.pl</a>
  
    <li><a href="./chinese_red.html">chinese.red</a>
  
    <li><a href="./client_pl.html">client.pl</a>
  
    <li><a href="./closureobject_txt.html">closureobject</a>
  
    <li><a href="./connect_py.html">connect.py</a>
  
    <li><a href="./connect2_py.html">connect2.py</a>
  
    <li><a href="./connect3_py.html">connect3.py</a>
  
    <li><a href="./cron_pl.html">cron.pl</a>
  
    <li><a href="./cronlog_txt.html">cronlog</a>
  
    <li><a href="./crontab.html">crontab</a>
  
    <li><a href="./d_pl.html">d.pl</a>
  
    <li><a href="./download_py.html">download.py</a>
  
    <li><a href="./fact_py.html">fact.py</a>
  
    <li><a href="./fork_pl.html">fork.pl</a>
  
    <li><a href="./gopherclient_py.html">gopherclient.py</a>
  
    <li><a href="./gopherclient3_py.html">gopherclient3.py</a>
  
    <li><a href="./gopherlibclient_py.html">gopherlibclient.py</a>
  
    <li><a href="./hangman_pl.html">hangman.pl</a>
  
    <li><a href="./lgetr_pl.html">lgetr.pl</a>
  
    <li><a href="./markov_pl.html">markov.pl</a>
  
    <li><a href="./mydata.html">mydata</a>
  
    <li><a href="./perlEssential_pl.html">perlEssential.pl</a>
  
    <li><a href="./python-mode_el.html">python-mode.el</a>
  
    <li><a href="./red_red.html">red.red</a>
  
    <li><a href="./repl_vbs.html">repl.vbs</a>
  
    <li><a href="./server_pl.html">server.pl</a>
  
    <li><a href="./server_py.html">server.py</a>
  
    <li><a href="./socketerrors_py.html">socketerrors.py</a>
  
    <li><a href="./t_py.html">t.py</a>
  
    <li><a href="./tags_vim.html">tags.vim</a>
  
    <li><a href="./urlclient_py.html">urlclient.py</a>
  
    <li><a href="./vbs-repl_el.html">vbs-repl.el</a>
  
    <li><a href="./vbsh_vbs.html">vbsh.vbs</a>
  
    <li><a href="./vbshell_vbs.html">vbshell.vbs</a>
  
    <li><a href="./vimtags_pl.html">vimtags.pl</a>
  
    <li><a href="./visual-basic-mode_el.html">visual-basic-mode.el</a>
  
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-label="Page EmergencyElisp.txt">

<p>Emergency Elisp vim:tw=78:nosta:noet:ts=8:sts=0:ft=help:noet:fen:fdm=marker:</p>

<pre>Quick Start*</pre>

<p>To set a variable named foo to the value “bar”: &gt;</p>

<pre class="ruby">(<span class="ruby-identifier">setq</span> <span class="ruby-identifier">foo</span> <span class="ruby-string">&quot;bar&quot;</span>)  ; <span class="ruby-identifier">setq</span> <span class="ruby-identifier">means</span> <span class="ruby-string">&quot;set quoted&quot;</span>
</pre>

<p>To call a function named foo-bar with arguments “flim” and “flam”: &gt;</p>

<pre>(foo-bar &quot;flim&quot; &quot;flam&quot;)</pre>

<p>To compute the arithmetic expression (0x15 * (8.2 + (7 &lt;&lt; 3))) % 2: &gt;</p>

<pre>(% (* #x15 (+ 8.2 (lsh 7 3))) 2)</pre>

<p>The first approach spits the result into the <strong>scratch</strong> buffer, and the next two echo it into the minibuffer. They all also work for atoms – expressions not in parens such as numbers, strings, characters and symbols. Lexical Stuff Lisp has only a handful of lexical tokens (i.e. atomic program elements). Comments: Single-line only. They start with a semicolon: &gt;</p>

<pre class="ruby">(<span class="ruby-identifier">blah</span> <span class="ruby-identifier">blah</span> <span class="ruby-identifier">blah</span>)   ;  <span class="ruby-constant">I</span> <span class="ruby-identifier">am</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">comment</span>
</pre>

<p>Strings:                                        <strong>Strings</strong> Double-quoted only. &gt;</p>

<pre class="ruby"><span class="ruby-string">&quot;He&#39;s said: \&quot;Emacs Rules\&quot; one time too many.&quot;</span>
</pre>

<p>You can embed newlines in strings, like so: &gt;</p>

<pre class="ruby"><span class="ruby-string">&quot;Oh Argentina!
Your little tin of pink meat
Soars o&#39;er the Pampas&quot;</span>
</pre>

<p>Characters:                                    <strong>Characters</strong> ?x is the syntax for an ASCII character: ? followed by the character. e.g.: ?a is ascii 97 (&#39;a&#39;), ? (that is, question-mark space) is ascii 32 (&#39; &#39;). Some need to be escaped, such as ?(, ?) and ?\ Emacs 22+ has unicode support. Out of scope for this primer. Characters are just int values internally, so you can use arithmetic operations on them (for instance, to iterate through ?a to ?z). Numbers:                                       <strong>Numbers</strong> Integers are 29 bits of precision (not the usual 32). -32, 0, 157, etc. Binary: start with b, e.g. b10010110 Octal: o[0-7]+, e.g. o377 Hexadecimal: start with x, e.g. xabcd, xDEADBEE Floating-point: the usual. -10.005, 0.0, 3.14159265 (64 bits of precision.) Scientific: the usual. 6.02e23, 5e-10 The variables |most-positive-fixnum|and |most-negative-fixnum| are the largest and smallest integers representable in Emacs Lisp without bignum support. Emacs 22+ comes with a fancy bignum/math library called calc, if you need it. Arithmetic operations overflow and underflow the way you&#39;d expect (in, say, C or Java.) Booleans                                         <strong>Booleans</strong> The symbol t (just a letter &#39;t&#39; by itself) is true. The symbol nil is false (and also means null). In Emacs Lisp, nil is the only false value; everything else evalutes to true in a boolean context, including empty strings, zero, the symbol &#39;false, and empty vectors. An empty list, &#39;(), is the same thing as nil. Arrays                                     <strong>Arrays</strong> Elisp has fixed-sized arrays called “vectors”. You can use square-brackets to create a pre-initialized literal vector, for instance: &gt;</p>

<pre>[-2 0 2 4 6 8 10]
[&quot;No&quot; &quot;Sir&quot; &quot;I&quot; &quot;am&quot; &quot;a&quot; &quot;real&quot; &quot;horse&quot;]
[&quot;hi&quot; 22 120 89.6 2748 [3 &quot;a&quot;]]</pre>

<p>Note that you do not (and cannot) use commas to separate the elements; use whitespace. Vectors can have mixed-type elements, and can be nested. You usually use the function make-vector to create them, since literal vectors are singletons, which can be surprising. Lists                                                 <strong>Lists</strong> Lisp makes heavy use of linked lists, so there&#39;s lexical syntax for them. Anything in parentheses is a list, but unless you quote it, it will be evaluated as a function call. There are various ways to quote things in Lisp: &gt;</p>

<pre>(quote (1 2 3))    ; produces the list (1 2 3) with no list-element evaluation
&#39;(1 2 3)           ; apostrophe is shorthand for (quote (...))
                   ; note that it goes _outside_ the left-paren
(list 1 (+ 1 1) 3) ; also produces (1 2 3), since it evaluates the elements first
`(1 ,(+ 1 1) 3)    ; another (1 2 3) via a template system called &quot;backquote&quot;</pre>

<p>There&#39;s a lot more that could be said about lists, but other people have already said it. Pairs                                      <strong>Pairs</strong> You can set the head and tail (also known as car and cdr) fields of a lisp link-list node struct (also known as a cons cell) directly, using it as a 2-element untyped struct. The syntax is (head-value . tail-value), and you have to quote it (see above). A common lookup-table data-structure for very small data sets is an associative list (known as an alist). It&#39;s just a list of dotted pairs, like so: &gt;</p>

<pre>&#39;((apple . &quot;red&quot;)
  (banana . &quot;yellow&quot;)
  (orange . &quot;orange&quot;))</pre>

<p>Emacs Lisp has built-in hashtables, bit-vectors, and miscellaneous other data structures, but there&#39;s no syntax for them; you create them with function calls. Operators Some operations that are typically operators in other languages are function calls in elisp. Equality                                      <strong>Equality</strong> Numeric equality: (= 2 (+ 1 1)) Single-equal. Yields t or nil. Works for floats too. Not-numerically-equal: (/= 2 3) I know, it looks like assign-divide-equal. But it&#39;s not. Value equality: (eq &#39;foo 2) Like Java ==. Works for ints, symbols, interned strings, and object references. Use eql for floating-point numbers (or just =). Deep (structural) equality: use equal, as in: &gt;</p>

<pre>(equal &#39;(1 2 (3 4)) (list 1 2 (list 3 (* 2 2))))  ; true</pre>

<p>The equal function is like Java&#39;s Object.equals(). Works for lists, vectors, strings, and just about anything else. String            </p>

<p>Strings don&#39;t have any operators, but there are lots of string functions. Some common ones: &gt;</p>

<pre>(concat &quot;foo&quot; &quot;bar&quot; &quot;baz&quot;)  ; yields &quot;foobarbaz&quot;
(string= &quot;foo&quot; &quot;baz&quot;)  ; yields nil (false).  Can also use equal.
(substring &quot;foobar&quot; 0 3) ; yields &quot;foo&quot;
(upcase &quot;foobar&quot;)  ; yields &quot;FOOBAR&quot;</pre>

<p>Do M-x apropos RET bstringb RET to see a list of functions related to strings. Arithmetic                            <strong>Arithmetic</strong> Easiest to show as a table… C/Java/JS Operator      Emacs Lisp                          Example             Result &gt;</p>

<pre>+                      +                                   (+ 1 2 3 4 5)       15
-                      -                                   (- 6 2 3)           1
                                                           (* 2 -1 4.2)        -8.4
/                      /                                   (/ 10 3)            3 (use floats for float div)
%                      %                                   (% 10 2)            0
&lt;&lt;                     lsh                                 (lsh 1 5)           32
&gt;&gt;                     ash (negative amount)               (ash -32 -4)        -2
&gt;&gt;&gt;                    lsh (negative amount)               (lsh 32 -4)         2
++                     incf (requires &#39;cl library)         (incf x 6)          x+6
--                     decf (ditto)                        (decf x 5)          x-5
? : (ternary)          (if test-expr then-expr else-expr)  (if t 3 4)          3
&amp;&amp;                     and                                 (and t t t nil)     nil
||                     or                                  (or nil nil nil t)  t
! (logical-not)        not                                 (not 3)             nil
~ (bit-not)            lognot                              (lognot #b1001)     -10
^ (bit-xor)            logxor                              (logxor 5 3)        6
&amp; (bit-and)            logand                              (logand 1 3)        1
| (bit-or)             logior                              (logior 1 3)        3
&lt;                      &lt;                                   (&lt; 5 3)             nil
&gt;                      &gt;                                   (&gt; 5 3)             t
&lt;=                     &lt;=                                  (&lt;= 3 3)            t
&gt;=                     &gt;=                                  (&gt;= 5 3)            t
. (field access)       see setf below                      n/a                 n/a
[] (array access)      aref/aset                           (aref [2 4 6] 1)    4</pre>

<p>Statements                                    <strong>Statements</strong> This section has some recipes for simple Java-like statements. It&#39;s not comprehensive – just some recipes to get you going. if/else  <strong>if-else</strong> Case 1: no else clause: (if {test-expr} {expr}) Example: &gt;</p>

<pre>(if (&gt;= 3 2)
    (message &quot;hello there&quot;))</pre>

<p>Case 2: else clause: (if {test-expr} {then-expr} {else-expr}) &gt;</p>

<pre>(if (today-is-friday)         ; test-expr
    (message &quot;yay, friday&quot;)   ; then-expr
  (message &quot;boo, other day&quot;)) ; else-expr</pre>

<p>If you need multiple expressions (statements) in the then-expr, you wrap them with a call to progn, which is like curly-braces in C or Java: &gt;</p>

<pre>(if (zerop 0)
    (progn
      (do-something)
      (do-something-else)
      (etc-etc-etc)))</pre>

<p>You don&#39;t need the progn around the else-expr – everything after the then-expr is considered to be part of the else-expr. Hence: &gt;</p>

<pre>(if (today-is-friday)
    (message &quot;yay, friday&quot;)
  (message &quot;not friday!&quot;)
  (non-friday-stuff)
  (more-non-friday-stuff))</pre>

<p>Case 3: else-if clause: Just nest &#39;em. Or use cond (see below). &gt;</p>

<pre>(if &#39;sunday
    (message &quot;sunday!&quot;)      ; then-expr
  (if &#39;saturday              ; else-if
      (message &quot;saturday!&quot;)  ; next then-expr
    (message (&quot;weekday!&quot;)))) ; final else</pre>

<p>Case 4: no else-if, multiple body expressions – use when: If you don&#39;t have an else-clause, then you can use the when macro, which provides an implicit progn: &gt;</p>

<pre>(when (&gt; 5 1)
  (blah)
  (blah-blah)
  (blah blah blah))</pre>

<p>You can also use unless, which is like when but inverts the sense of the test: &gt;</p>

<pre>(unless (weekend-p)
  (message &quot;another day at work&quot;)
  (get-back-to-work))</pre>

<p>switch  <strong>switch</strong> Elisp has two versions of the classic switch statement: cond and case. Elisp does not have a table-lookup optimization for switch, so cond and case are just syntax for nested if-then-else clauses. However, if you have more than one level of nesting, it looks a lot nicer than if expressions. The syntax is: &gt;</p>

<pre>(cond
  (test-1
    do-stuff-1)
  (test-2
    do-stuff-2)
  ...
  (t
    do-default-stuff))</pre>

<p>The do-stuff parts can be any number of statements, and don&#39;t need to be wrapped with a progn block. Unlike classic switch, cond can handle any test expression (it just checks them in order), not just numbers. The downside is that it doesn&#39;t have any special-casing for numbers, so you have to compare them to something. Here&#39;s one that does string compares: &gt;</p>

<pre>(cond
 ((equal value &quot;foo&quot;)  ; case #1 – notice it&#39;s a function call to `equal&#39; so it&#39;s in parens
  (message &quot;got foo&quot;)  ; action 1
  (+ 2 2))             ; return value for case 1
 ((equal value &quot;bar&quot;)  ; case #2 – also a function call (to `+&#39;)
  nil)                 ; return value for case 2
 (t                    ; default case – not a function call, just literal true
  &#39;hello))             ; return symbol &#39;hello</pre>

<p>The final t default clause is optional. The first matching clause is executed, and the result of the entire cond expression is the result of the last expression in the matching clause. The &#39;cl (Common Lisp) package bundled with Emacs provides case, which works if you&#39;re comparing numbers or symbols, so in a sense it works more like standard switch. Example: &gt;</p>

<pre>(case 12
  (5 &quot;five&quot;)
  (1 &quot;one&quot;)
  (12 &quot;twelve&quot;)
  (otherwise
   &quot;I only know five, one and twelve.&quot;))  ; result:  &quot;twelve&quot;</pre>

<p>With case you can use either t or otherwise for the default case, but it must come last. It&#39;s cleaner to use case when you can get away with it, but cond is more general. while                                                   <strong>while</strong> Elisp has a relatively normal while function: (while {test} {body-forms}) Example, which you can evaluate in your <strong>scratch</strong> buffer: &gt;</p>

<pre>(setq x 10
      total 0)
(while (plusp x)  ; while x is positive
  (incf total x)  ; add x to total
  (decf x))       ; subtract 1 from x</pre>

<p>First we set two global variables, x=10 and total=0, then run the loop. Then we can evaluate the expression total to see that its value is 55 (the sum of the numbers 1 to 10). break/continue</p>
<hr>

<p>Lisp has a facility for upward control-flow transfers called catch/throw. It&#39;s very similar to Java or C++ exception handling, albeit possibly somewhat lighter-weight. To do a break from inside a loop in elisp, you put a (catch &#39;break …) outside the loop, and a (throw &#39;break value) wherever you want to break inside the loop, like so:</p>

<pre>Emacs Lisp                          JavaScript &gt;
(setq x 0 total 0)                  var x = total = 0;
(catch &#39;break                       while (true) {
  (while t                            total += x;
    (incf total x)                    if (x++ &gt; 10) {
    (if (&gt; (incf x) 10)                 break;
        (throw &#39;break total))))       }
                                    }</pre>

<p>The symbol &#39;break is arbitrary, but is probably a nice choice for your readers. If you have nested loops, you might consider &#39;break-outer and &#39;break-inner in your catch expressions. You can (throw &#39;break nil) if you don&#39;t care about the “return value” for the while-loop. To continue a loop, put a catch expression just inside the loop, at the top. For instance, to sum the numbers from 1 to 99 that are not evenly divisible by 5 (artificially lame example demonstrating use of continue): Emacs Lisp                            JavaScript &gt;</p>

<pre>(setq x 0 total 0)                 var x = total = 0;
(while (&lt; x 100)                   while (x &lt; 100) {
  (catch &#39;continue                   x++;
    (incf x)                         if (x % 5 == 0) {
    (if (zerop (% x 5))                continue;
        (throw &#39;continue nil))       }
    (incf total x)))                 total += x;
                                   }</pre>

<p>We can combine these examples to show using a break and continue in the same loop:</p>

<pre>Emacs Lisp     JavaScript &gt;
(setq x 0 total 0)                 var x = total = 0;
(catch &#39;break                      while (true) {
  (while t                           x++;
    (catch &#39;continue                 if (x &gt;= 100) {
      (incf x)                         break;
      (if (&gt;= x 100)                 }
          (throw &#39;break nil))        if (x % 5 == 0) {
      (if (zerop (% x 5))              continue;
          (throw &#39;continue nil))     }
      (incf total x))))              total += x;
                                   }</pre>

<p>All the loops above compute the value 4000 in the variable total. There are better ways to compute this result, but I needed something simple to illustrate break and continue. The catch/throw mechanism can be used across function boundaries, just like exceptions. It&#39;s not intended for true exceptions or error conditions – Emacs has another mechanism for that, discussed in the try/catch section below. You should get comfortable using catch/throw for normal jumps and control transfer in your Elisp code. do/while Pretty much all iteration in Emacs Lisp is easiest using the loop macro from the Common Lisp package. Just do this to enable loop: (require &#39;cl)  ; get lots of Common Lisp goodies The loop macro is a powerful minilanguage with lots of features, and it&#39;s worth reading up on. I&#39;ll use it in this primer to show you how to do basic looping constructs from other languages. You can do a do/while like so: &gt;</p>

<pre>(loop do
      (setq x (1+ x))
      while
      (&lt; x 10))</pre>

<p>You can have any number of lisp expressions between the do and while keywords. for The C-style for-loop has four components: variable initialization, the loop body, the test, and the increment. You can do all that and more with the loop macro. For instance, this arbitrary JavaScript: &gt;</p>

<pre>// JavaScript
var result = [];
for (var i = 10, j = 0; j &lt;= 10; i--, j += 2) {
  result.push(i+j);
}</pre>

<p>Could be done with loop like so: &gt;</p>

<pre>(loop with result = &#39;()         ; one-time initialization
      for i downfrom 10         ; count i down from 10
      for j from 0 by 2         ; count j up from 0 by 2
      while (&lt; j 10)            ; stop when j &gt;= 10
      do
      (push (+ i j) result)     ; fast-accumulate i+j
      finally
      return (nreverse result)) ; reverse and return result</pre>

<p>It&#39;s a bit more verbose, but loop has a lot of options, so you want it to be reasonably transparent. Notice that this loop declares the result array and then “returns” it. It could also operate on a variable declared outside the loop, in which case we wouldn&#39;t need the finally return clause. The loop macro is astoundingly flexible. Its full specification is way out of scope for this primer, but if you want to make Emacs Lisp your, uh, friend, then you should spend some time reading up on loop. for..in If you&#39;re iterating over a collection, Java provides the “smart” for-loop, and JavaScript has for..in and for each..in. There are various ways to do it in Lisp, but you really might as well just learn how to do it with the loop macro. It&#39;s a one-stop shop for iteration. The basic approach is to use loop for var in sequence, and then do something with the individual results. You can, for instance, collect them (or a function on them) into a result list like so: (loop for i in &#39;(1 2 3 4 5 6)</p>

<pre>collect (* i i))           ; yields (1 4 9 16 25 36)</pre>

<p>The loop macro lets you iterate over list elements, list cells, vectors, hash-keys, hash-values, buffers, windows, frames, symbols, and just about anything else you could want to traverse. See the Info pages or your Emacs manual for details. functions You define a function with defun. Syntax: (defun {function-name} {arg-list} [optional-docstring] {body}) &gt;</p>

<pre>(defun square (x)
  &quot;Return X squared.&quot;
  (* x x))</pre>

<p>For a no-arg function, you use an empty list: &gt;</p>

<pre class="ruby">(<span class="ruby-identifier">defun</span> <span class="ruby-identifier">hello</span> ()
  <span class="ruby-string">&quot;Print the string `hello&#39; to the minibuffer.&quot;</span>
  (<span class="ruby-identifier">message</span> <span class="ruby-string">&quot;hello!&quot;</span>))
</pre>

<p>The body can be any number of expressions. The return value of the function is the result of the last expression executed. You do not declare the return type, so it&#39;s useful to mention it in the documentation string. The doc string is available from M-x describe-function after you evaluate your function. Emacs Lisp does not have function/method overloading, but it supports optional and “rest” parameters similar to what Python and Ruby offer. You can use the full Common Lisp specification for argument lists, including support for keyword arguments (see the defstruct section below), if you use the defun* macro instead of defun. The defun* version also lets you (return “foo”) without having to set up your own catch/throw. If you want your function to be available as a M-x command, put (interactive) as the first expression in the body after the doc string. local variables You declare function local variables with the let form. The basic syntax is (let {var-decl} {var-decl}) (let ((name1 value1)</p>

<pre>(name2 value2)
name3
name4
(name5 value5)
name6
...))</pre>

<p>Each var-decl is either a single name, or (name initial-value). You can mix initialized and uninitialized values in any order. Uninitialized variables get the initial value nil. You can have multiple let clauses in a function. Code written for performance often collects all declarations into a single let at the top, since it&#39;s a bit faster that way. Typically you should write your code for clarity first. reference parameters C++ has reference parameters, which allow you to modify variables from the caller&#39;s stack. Java does not, so you have to work around it occasionally by passing in a 1-element array, or using an instance variable, or whatever. Emacs Lisp does not have true reference parameters, but it has dynamic scope, which means you can modify values on your caller&#39;s stack anyway. Consider the following pair of functions: &gt;</p>

<pre>(defun foo ()
  (let ((x 6))  ; define a local (i.e., stack) variable x initialized to 6
    (bar)       ; call bar
    x))         ; return x
(defun bar ()
  (setq x 7))   ; finds and modifies x in the caller&#39;s stack frame</pre>

<p>If you invoke (foo) the return value is 7. Dynamic scoping is generally considered a bad design bordering on evil, but it can occasionally come in handy. If nothing else, it&#39;s good to know it&#39;s what Emacs does. return A lisp function by default returns the value of the last expression executed in the function. Sometimes it&#39;s possible to structure your function so that every possible return value is in a “tail position” (meaning the last expression out before the door closes, so to speak.) For instance:</p>

<pre>Emacs Lisp                                  JavaScript &gt;
(require &#39;calendar)                         function dayName() {
(defun day-name ()                            var date = new Date().getDay();
  (let ((date (calendar-day-of-week           switch (date) {
               (calendar-current-date))))       case 0:
    (if (= date 0)                                return &quot;Sunday&quot;;
        &quot;Sunday&quot;                                case 6:
      (if (= date 6)                              return &quot;Saturday&quot;;
          &quot;Saturday&quot;                            default:
        &quot;weekday&quot;))))                             return &quot;weekday&quot;;
                                              }
                                            }</pre>

<p>The return value is just the result of the last expression, so whatever our nested if produces is automatically returned, and there&#39;s no need here for an explicit return form. However, sometimes restructuring the function this way is inconvenient, and you&#39;d prefer to do an “early return”. You can do early returns in Emacs Lisp the same way you do break and continue, using the catch/throw facility. Usually simple functions can be structured so you don&#39;t need this – it&#39;s most often useful for larger, deeply-nested functions. So for a contrived example, we&#39;ll just rewrite the function above to be closer to the JavaScript version: &gt;</p>

<pre>(defun day-name ()
  (let ((date (calendar-day-of-week
               (calendar-current-date))))  ; 0-6
    (catch &#39;return
      (case date
        (0
         (throw &#39;return &quot;Sunday&quot;))
        (6
         (throw &#39;return &quot;Saturday&quot;))
        (t
         (throw &#39;return &quot;weekday&quot;))))))</pre>

<p>Obviously using catch/throw here is slow and clunky compared to the alternatives, but sometimes it&#39;s exactly what you need to get out of a deeply nested construct. try/catch <strong>try-catch</strong> We&#39;ve already discussed catch/throw, an exception-like facility for normal control flow transfers. Emacs has a different facility for real error conditions, called the “conditions” system. Going through the full system is out of scope for our primer, but I&#39;ll cover how to catch all exceptions and how to ignore (squelch) them. Here&#39;s an example of a universal try/catch using the condition-case construct, with a Java equivalent:</p>

<pre>Emacs Lisp                  Java &gt;

(condition-case nil         try {
    (progn                    doSomething();
      (do-something)          doSomethingElse();
      (do-something-else))  } catch (Throwable t) {
  (error                      print(&quot;uh-oh&quot;);
   (message &quot;oh no!&quot;)         doRecoveryStuff();
   (do-recovery-stuff)))    }</pre>

<p>If you want an empty catch block (just squelch the error), you can use ignore-errors: (ignore-errors</p>

<pre>(do-something)
(do-something-else))</pre>

<p>It&#39;s sometimes a good idea to slap an ignore-errors around bits of elisp code in your startup file that may not always work, so you can still at least start your Emacs up if the code is failing. The condition-case nil means “Don&#39;t assign the error to a named variable.” Elisp lets you catch different kinds of errors and examine the error data. You can read the Emacs manual or Info pages to learn more about how to do that. The progn is necessary if you have multiple expressions (in C/Java, statements) to evaluate in the condition-case body. condition-case will not catch values thrown by throw – the two systems are independent. try/finally Emacs has a “finally”-like facility called unwind-protect.</p>

<pre>Emacs Lisp                 Java &gt;
(unwind-protect            try {
    (progn                   doSomething();
      (do-something)         doSomethingElse();
      (do-something-else)) } finally {
  (first-finally-expr)       firstFinallyExpr();
  (second-finally-expr))     secondFinallyExpr();
                           }</pre>

<p>Like condition-case, unwind-protect takes a single body-form followed by one or more cleanup forms, so you need to use progn if you have more than one expression in the body. try/catch/finally If you make the condition-case (which is basically try/catch) the body-form of an unwind-protect (which is basically try/finally), you get the effect of try/catch/finally: &gt;</p>

<pre>(unwind-protect                 ; finally
    (condition-case nil         ; try
        (progn                  ; {
          (do-something)        ;   body-1
          (do-something-else))  ;   body-2 }
      (error                    ; catch
       (message &quot;oh no!&quot;)       ; { catch 1
       (poop-pants)))           ;   catch 2 }
  (first-finally-expr)          ; { finally 1
  (second-finally-expr))        ;   finally 2 }</pre>

<p>Classes  <strong>Classes</strong> Emacs Lisp is not object-oriented in the standard sense: it doesn&#39;t have classes, inheritance, polymorphism and so on. The Common Lisp package includes a useful feature called defstruct that gives you some simple OOP-like support. I&#39;ll walk through a basic example. These two declarations are essentially equivalent: Emacs Lisp                        Java &gt;</p>

<pre>(require &#39;cl)  ; top of file     A Person class   
                              class Person {
(defstruct person               String name;
  &quot;A person structure.&quot;         int age;
  name                          double height;
  (age 0)                       public Person() {}
  (height 0.0))                 public Person(String name) {
                                  this(name, 0, 0);
                                }
                                public Person(int age) {
                                  this(null, age, 0);
                                }
                                public Person(double height) {
                                  this(null, 0, height);
                                }
                                public Person(String name, int age) {
                                  this(name, age, 0);
                                }
                                public Person(String name, double height) {
                                  this(name, 0, height);
                                }
                                public Person(int age, double height) {
                                  this(null, age, height);
                                }
                                public Person(String name, int age, double height) {
                                  this.name = name;
                                  this.age = age;
                                  this.height = height;
                                }
                              }</pre>

<p>Both create a “class” with three named fields, and constructors for initializing any subset of the fields. With defstruct you get one constructor with keyword parameters, so these are all valid: &gt;</p>

<pre>(make-person)  ; new Person()
(make-person :age 39)  ; new Person(39)
(make-person :name &quot;Steve&quot; :height 5.83 :age 39)  ; new Person(&quot;Steve&quot;, 39, 5.83)</pre>

<p>The defstruct macro supports single-inheritance (to arbitrary depth): Emacs Lisp                          Java &gt;</p>

<pre>(defstruct (employee                An Employee class   
            (:include person))   class Employee extends Person {
  &quot;An employee structure.&quot;         String company;
  company                          int level = 1;
  (level 1)                        String title = &quot;n00b&quot;;
  (title &quot;n00b&quot;))                  public Employee() {
                                   }
                                   public Employee(String name,
                                                  String company) {
                                     super(name);
                                     this.company = company;
                                   }
                                   public Employee(String name,
                                                  int age,
                                                  String company) {
                                     super(name, age);
                                     this.company = company;
                                   }
                                   public Employee(String name,
                                                  int age,
                                                  double height,
                                                  String company) {
                                     super(name, age, height);
                                     this.company = company;
                                   }
                                   public Employee(String name,
                                                  int age,
                                                  String company,
                                                  int level) {
                                     super(name, age);
                                     this.company = company;
                                     this.level = level;
                                   }
                                   public Employee(String name,
                                                  int age,
                                                  String co,
                                                  int lvl,
                                                  String title) {
                                     super(name, age);
                                     this.company = co;
                                     this.level = lvl;
                                     this.title = title;
                                   }
                                   // (remaining 150 overloaded constructors elided for brevity)
                                 }</pre>

<p>The defstruct macro provides a flexible default constructor, but also gives you a fair amount of control over your constructor(s) if you prefer. The defstruct macro creates an instanceof-like predicate function named after the struct, so you can say: &gt;</p>

<pre>(person-p (make-person))
t
(employee-p (make-person))
nil
(employee-p (make-employee))
t
(person-p (make-employee))  ; yes, it inherits from person
t</pre>

<p>Java may suck at declaring constructors, but Emacs Lisp makes up for it by sucking at setting fields. To set a field in a struct, you have to use the setf function, and construct the field name by prepending the structure name. So:</p>

<pre>Emacs Lisp                           Java &gt;
(setq e (make-employee))             Employee e = new Employee();
(setf (employee-name e) &quot;Steve&quot;      e.name = &quot;Steve&quot;;
      (employee-age e) 39            e.age = 39;
      (employee-company e) &quot;Google&quot;  e.company = &quot;Google&quot;;
      (employee-title e) &quot;Janitor&quot;)  e.title = &quot;Janitor&quot;;</pre>

<p>The Lisp one doesn&#39;t look too bad here, but in practice (because Elisp has no namespace support and no with-slots macro), you wind up with long structure and field names. So your defstruct-enabled elisp code tends to look more like this: &gt;</p>

<pre>(setf (js2-compiler-data-current-script-or-function compiler-data) current-script
      (js2-compiler-data-line-number compiler-data) current-line
      (js2-compiler-data-allow-member-expr-as-function-name compiler-data) allow
      (js2-compiler-data-language-version compiler-data) language-version)</pre>

<p>So it goes. To fetch the value of a field in a struct variable, you concatenate the struct name with the field name and use it as a function call: (person-name steve)  ; yields “Steve” There&#39;s more that defstruct can do – it&#39;s a pretty decent facility, all things considered, though it falls well short of a full object system. Buffers as classes In Elisp programming it can often be useful to think of buffers as instances of your own classes. This is because Emacs supports the notion of buffer-local variables: variables that automatically become buffer-local whenever they are set in any fashion. They become part of the scope chain for any code executing in the buffer, so they act a lot like encapsulated instance variables. You can use the function make-variable-buffer-local to declare a variable as buffer-local. Usually it comes right after the defvar or defconst declaration (see below.) Variables You can declare a variable, optionally giving it some runtime documentation, with defvar or defconst: (defconst pi 3.14159 “A gross approximation of pi.”) The syntax is (defvar name value [ doc-string ]). Ironically, defconst is variable and defvar is constant, at least if you re-evaluate them. To change the value of a defvar variable by re-evaluating its declaration you need to use makunbound to unbind it first. You can always change the value of any defvar or defconst variable using setq. The only difference between the two is that defconst makes it clearer to the programmer that the value is not intended to change. You can use setq to create brand-new variables, but if you use defvar, the byte-compiler will be able to catch more typos. Further reading Emacs Lisp is a real programming language. It has a compiler, a debugger, a profiler, pretty-printers, runtime documentation, libraries, I/O, networking, process control and much more. There&#39;s a lot to learn, but I&#39;m hoping this little primer has got you over the hump, as it were. In spite of its various quirks and annoyances, Elisp is reasonably fun to program in once you get the hang of it. As a language it&#39;s not that great, and everyone wishes it were Common Lisp or <a href="Scheme_txt.html">Scheme</a> or some other reasonable Lisp dialect. Some people even wish it weren&#39;t Lisp at all, if you can believe that! (hee) But it&#39;s really, really useful to be able to customize your editor, and also to be able to fix problems with elisp code you borrowed or inherited. So a little Elisp goes a long way. For those of you learning Emacs Lisp, please let me know if you found this useful. If you try writing some Emacs extensions, let me know what you would like to see documented next; I can always do another installment of the Emergency Elisp series if there&#39;s enough interest. Good luck! Posted 25th January 2008 by Steve Yegge</p>

</main>



<footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.1.2.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

