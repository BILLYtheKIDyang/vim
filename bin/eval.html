*eval.txt*	For Vim version 8.1.  Last change: 2019 Nov 25<p>


<pre>		  VIM REFERENCE MANUAL	  by Bram Moolenaar<p></pre>


Expression evaluation			*expression* *expr* *E15* *eval*<p>

Using expressions is introduced in chapter 41 of the user manual |usr_41.txt|.<p>

Note: Expression evaluation can be disabled at compile time.  If this has been
done, the features in this document are not available.  See |+eval| and
|no-eval-feature|.<p>

<pre>1.  Variables			|variables|</pre>
<pre>    1.1 Variable types</pre>
<pre>    1.2 Function references		|Funcref|</pre>
<pre>    1.3 Lists				|Lists|</pre>
<pre>    1.4 Dictionaries			|Dictionaries|</pre>
<pre>    1.5 Blobs				|Blobs|</pre>
<pre>    1.6 More about variables		|more-variables|</pre>
<pre>2.  Expression syntax		|expression-syntax|</pre>
<pre>3.  Internal variable		|internal-variables|</pre>
<pre>4.  Builtin Functions		|functions|</pre>
<pre>5.  Defining functions		|user-functions|</pre>
<pre>6.  Curly braces names		|curly-braces-names|</pre>
<pre>7.  Commands			|expression-commands|</pre>
<pre>8.  Exception handling		|exception-handling|</pre>
<pre>9.  Examples			|eval-examples|</pre>
<pre>10. Vim script version		|vimscript-version|</pre>
<pre>11. No +eval feature		|no-eval-feature|</pre>
<pre>12. The sandbox			|eval-sandbox|</pre>
<pre>13. Textlock			|textlock|<p></pre>

Testing support is documented in |testing.txt|.
Profiling is documented at |profiling|.<p>

* Variables						*variables*<p>

1.1 Variable types ~
<pre>						*E712* *E896* *E897* *E899*</pre>
There are ten types of variables:<p>

Number		A 32 or 64 bit signed number.  |expr-number| *Number*
<pre>		64-bit Numbers are available only when compiled with the</pre>
<pre>		|+num64| feature.</pre>
<pre>		Examples:  -123  0x10  0177  0b1011<p></pre>

Float		A floating point number. |floating-point-format| *Float*
<pre>		{only when compiled with the |+float| feature}</pre>
<pre>		Examples: 123.456  1.15e-6  -1.1e3<p></pre>

<pre>							*E928*</pre>
String		A NUL terminated string of 8-bit unsigned characters (bytes).
<pre>		|expr-string| Examples: "ab\txx\"--"  'x-z''a,c'<p></pre>

List		An ordered sequence of items, see |List| for details.
<pre>		Example: [1, 2, ['a', 'b']]<p></pre>

Dictionary	An associative, unordered array: Each entry has a key and a
<pre>		value. |Dictionary|</pre>
<pre>		Examples:</pre>
<pre>			{'blue': "#0000ff", 'red': "#ff0000"}</pre>
<pre>			#{blue: "#0000ff", red: "#ff0000"}<p></pre>

Funcref		A reference to a function |Funcref|.
<pre>		Example: function("strlen")</pre>
<pre>		It can be bound to a dictionary and arguments, it then works</pre>
<pre>		like a Partial.</pre>
<pre>		Example: function("Callback", [arg], myDict)<p></pre>

Special		|v:false|, |v:true|, |v:none| and |v:null|.  *Special*<p>

Job		Used for a job, see |job_start()|. *Job* *Jobs*<p>

Channel		Used for a channel, see |ch_open()|. *Channel* *Channels*<p>

Blob		Binary Large Object. Stores any sequence of bytes.  See |Blob|
<pre>		for details</pre>
<pre>		Example: 0zFF00ED015DAF</pre>
<pre>		0z is an empty Blob.<p></pre>

The Number and String types are converted automatically, depending on how they
are used.<p>

Conversion from a Number to a String is by making the ASCII representation of
the Number.  Examples:
<pre>	Number 123	-->	String "123" ~</pre>
<pre>	Number 0	-->	String "0" ~</pre>
<pre>	Number -1	-->	String "-1" ~</pre>
<pre>							*octal*</pre>
Conversion from a String to a Number is done by converting the first digits to
a number.  Hexadecimal "0xf9", Octal "017", and Binary "0b10" numbers are
recognized (NOTE: when using |scriptversion-4| octal is not recognized).  If
the String doesn't start with digits, the result is zero.
Examples:
<pre>	String "456"	-->	Number 456 ~</pre>
<pre>	String "6bar"	-->	Number 6 ~</pre>
<pre>	String "foo"	-->	Number 0 ~</pre>
<pre>	String "0xf1"	-->	Number 241 ~</pre>
<pre>	String "0100"	-->	Number 64 ~</pre>
<pre>	String "0b101"	-->	Number 5 ~</pre>
<pre>	String "-8"	-->	Number -8 ~</pre>
<pre>	String "+8"	-->	Number 0 ~<p></pre>

To force conversion from String to Number, add zero to it: >
<pre>	:echo "0100" + 0</pre>
<	64 ~<p>

To avoid a leading zero to cause octal conversion, or for using a different
base, use |str2nr()|.<p>

<pre>						*TRUE* *FALSE* *Boolean*</pre>
For boolean operators Numbers are used.  Zero is FALSE, non-zero is TRUE.
You can also use |v:false| and |v:true|.  When TRUE is returned from a
function it is the Number one, FALSE is the number zero.<p>

Note that in the command: >
<pre>	:if "foo"</pre>
<pre>	:" NOT executed</pre>
"foo" is converted to 0, which means FALSE.  If the string starts with a
non-zero number it means TRUE: >
<pre>	:if "8foo"</pre>
<pre>	:" executed</pre>
To test for a non-empty string, use empty(): >
<pre>	:if !empty("foo")</pre>
<
<pre>							*non-zero-arg*</pre>
Function arguments often behave slightly different from |TRUE|: If the
argument is present and it evaluates to a non-zero Number, |v:true| or a
non-empty String, then the value is considered to be TRUE.
Note that " " and "0" are also non-empty strings, thus considered to be TRUE.
A List, Dictionary or Float is not a Number or String, thus evaluate to FALSE.<p>

<pre>		*E745* *E728* *E703* *E729* *E730* *E731* *E908* *E910* *E913*</pre>
<pre>		*E974* *E975* *E976*</pre>
|List|, |Dictionary|, |Funcref|, |Job|, |Channel| and |Blob| types are not
automatically converted.<p>

<pre>							*E805* *E806* *E808*</pre>
When mixing Number and Float the Number is converted to Float.  Otherwise
there is no automatic conversion of Float.  You can use str2float() for String
to Float, printf() for Float to String and float2nr() for Float to Number.<p>

<pre>			*E891* *E892* *E893* *E894* *E907* *E911* *E914*</pre>
When expecting a Float a Number can also be used, but nothing else.<p>

<pre>						*no-type-checking*</pre>
You will not get an error if you try to change the type of a variable.<p>


1.2 Function references ~
<pre>					*Funcref* *E695* *E718*</pre>
A Funcref variable is obtained with the |function()| function, the |funcref()|
function or created with the lambda expression |expr-lambda|.  It can be used
in an expression in the place of a function name, before the parenthesis
around the arguments, to invoke the function it refers to.  Example: ><p>

<pre>	:let Fn = function("MyFunc")</pre>
<pre>	:echo Fn()</pre>
<							*E704* *E705* *E707*
A Funcref variable must start with a capital, "s:", "w:", "t:" or "b:".  You
can use "g:" but the following name must still start with a capital.  You
cannot have both a Funcref variable and a function with the same name.<p>

A special case is defining a function and directly assigning its Funcref to a
Dictionary entry.  Example: >
<pre>	:function dict.init() dict</pre>
<pre>	:   let self.val = 0</pre>
<pre>	:endfunction<p></pre>

The key of the Dictionary can start with a lower case letter.  The actual
function name is not used here.  Also see |numbered-function|.<p>

A Funcref can also be used with the |:call| command: >
<pre>	:call Fn()</pre>
<pre>	:call dict.init()<p></pre>

The name of the referenced function can be obtained with |string()|. >
<pre>	:let func = string(Fn)<p></pre>

You can use |call()| to invoke a Funcref and use a list variable for the
arguments: >
<pre>	:let r = call(Fn, mylist)</pre>
<
<pre>								*Partial*</pre>
A Funcref optionally binds a Dictionary and/or arguments.  This is also called
a Partial.  This is created by passing the Dictionary and/or arguments to
function() or funcref().  When calling the function the Dictionary and/or
arguments will be passed to the function.  Example: ><p>

<pre>	let Cb = function('Callback', ['foo'], myDict)</pre>
<pre>	call Cb('bar')<p></pre>

This will invoke the function as if using: >
<pre>	call myDict.Callback('foo', 'bar')<p></pre>

This is very useful when passing a function around, e.g. in the arguments of
|ch_open()|.<p>

Note that binding a function to a Dictionary also happens when the function is
a member of the Dictionary: ><p>

<pre>	let myDict.myFunction = MyFunction</pre>
<pre>	call myDict.myFunction()<p></pre>

Here MyFunction() will get myDict passed as "self".  This happens when the
"myFunction" member is accessed.  When making assigning "myFunction" to
otherDict and calling it, it will be bound to otherDict: ><p>

<pre>	let otherDict.myFunction = myDict.myFunction</pre>
<pre>	call otherDict.myFunction()<p></pre>

Now "self" will be "otherDict".  But when the dictionary was bound explicitly
this won't happen: ><p>

<pre>	let myDict.myFunction = function(MyFunction, myDict)</pre>
<pre>	let otherDict.myFunction = myDict.myFunction</pre>
<pre>	call otherDict.myFunction()<p></pre>

Here "self" will be "myDict", because it was bound explicitly.<p>


1.3 Lists ~
<pre>						*list* *List* *Lists* *E686*</pre>
A List is an ordered sequence of items.  An item can be of any type.  Items
can be accessed by their index number.  Items can be added and removed at any
position in the sequence.<p>


List creation ~
<pre>							*E696* *E697*</pre>
A List is created with a comma separated list of items in square brackets.
Examples: >
<pre>	:let mylist = [1, two, 3, "four"]</pre>
<pre>	:let emptylist = []<p></pre>

An item can be any expression.  Using a List for an item creates a
List of Lists: >
<pre>	:let nestlist = [[11, 12], [21, 22], [31, 32]]<p></pre>

An extra comma after the last item is ignored.<p>


List index ~
<pre>							*list-index* *E684*</pre>
An item in the List can be accessed by putting the index in square brackets
after the List.  Indexes are zero-based, thus the first item has index zero. >
<pre>	:let item = mylist[0]		" get the first item: 1</pre>
<pre>	:let item = mylist[2]		" get the third item: 3<p></pre>

When the resulting item is a list this can be repeated: >
<pre>	:let item = nestlist[0][1]	" get the first list, second item: 12</pre>
<
A negative index is counted from the end.  Index -1 refers to the last item in
the List, -2 to the last but one item, etc. >
<pre>	:let last = mylist[-1]		" get the last item: "four"<p></pre>

To avoid an error for an invalid index use the |get()| function.  When an item
is not available it returns zero or the default value you specify: >
<pre>	:echo get(mylist, idx)</pre>
<pre>	:echo get(mylist, idx, "NONE")<p></pre>


List concatenation ~<p>

Two lists can be concatenated with the "+" operator: >
<pre>	:let longlist = mylist + [5, 6]</pre>
<pre>	:let mylist += [7, 8]<p></pre>

To prepend or append an item turn the item into a list by putting [] around
it.  To change a list in-place see |list-modification| below.<p>


Sublist ~
<pre>							*sublist*</pre>
A part of the List can be obtained by specifying the first and last index,
separated by a colon in square brackets: >
<pre>	:let shortlist = mylist[2:-1]	" get List [3, "four"]<p></pre>

Omitting the first index is similar to zero.  Omitting the last index is
similar to -1. >
<pre>	:let endlist = mylist[2:]	" from item 2 to the end: [3, "four"]</pre>
<pre>	:let shortlist = mylist[2:2]	" List with one item: [3]</pre>
<pre>	:let otherlist = mylist[:]	" make a copy of the List<p></pre>

If the first index is beyond the last item of the List or the second item is
before the first item, the result is an empty list.  There is no error
message.<p>

If the second index is equal to or greater than the length of the list the
length minus one is used: >
<pre>	:let mylist = [0, 1, 2, 3]</pre>
<pre>	:echo mylist[2:8]		" result: [2, 3]<p></pre>

NOTE: mylist[s:e] means using the variable "s:e" as index.  Watch out for
using a single letter variable before the ":".  Insert a space when needed:
mylist[s : e].<p>


List identity ~
<pre>							*list-identity*</pre>
When variable "aa" is a list and you assign it to another variable "bb", both
variables refer to the same list.  Thus changing the list "aa" will also
change "bb": >
<pre>	:let aa = [1, 2, 3]</pre>
<pre>	:let bb = aa</pre>
<pre>	:call add(aa, 4)</pre>
<pre>	:echo bb</pre>
<	[1, 2, 3, 4]<p>

Making a copy of a list is done with the |copy()| function.  Using [:] also
works, as explained above.  This creates a shallow copy of the list: Changing
a list item in the list will also change the item in the copied list: >
<pre>	:let aa = [[1, 'a'], 2, 3]</pre>
<pre>	:let bb = copy(aa)</pre>
<pre>	:call add(aa, 4)</pre>
<pre>	:let aa[0][1] = 'aaa'</pre>
<pre>	:echo aa</pre>
<	[[1, aaa], 2, 3, 4] >
<pre>	:echo bb</pre>
<	[[1, aaa], 2, 3]<p>

To make a completely independent list use |deepcopy()|.  This also makes a
copy of the values in the list, recursively.  Up to a hundred levels deep.<p>

The operator "is" can be used to check if two variables refer to the same
List.  "isnot" does the opposite.  In contrast "==" compares if two lists have
the same value. >
<pre>	:let alist = [1, 2, 3]</pre>
<pre>	:let blist = [1, 2, 3]</pre>
<pre>	:echo alist is blist</pre>
<	0 >
<pre>	:echo alist == blist</pre>
<	1<p>

Note about comparing lists: Two lists are considered equal if they have the
same length and all items compare equal, as with using "==".  There is one
exception: When comparing a number with a string they are considered
different.  There is no automatic type conversion, as with using "==" on
variables.  Example: >
<pre>	echo 4 == "4"</pre>
<	1 >
<pre>	echo [4] == ["4"]</pre>
<	0<p>

Thus comparing Lists is more strict than comparing numbers and strings.  You
can compare simple values this way too by putting them in a list: ><p>

<pre>	:let a = 5</pre>
<pre>	:let b = "5"</pre>
<pre>	:echo a == b</pre>
<	1 >
<pre>	:echo [a] == [b]</pre>
<	0<p>


List unpack ~<p>

To unpack the items in a list to individual variables, put the variables in
square brackets, like list items: >
<pre>	:let [var1, var2] = mylist<p></pre>

When the number of variables does not match the number of items in the list
this produces an error.  To handle any extra items from the list append ";"
and a variable name: >
<pre>	:let [var1, var2; rest] = mylist<p></pre>

This works like: >
<pre>	:let var1 = mylist[0]</pre>
<pre>	:let var2 = mylist[1]</pre>
<pre>	:let rest = mylist[2:]<p></pre>

Except that there is no error if there are only two items.  "rest" will be an
empty list then.<p>


List modification ~
<pre>							*list-modification*</pre>
To change a specific item of a list use |:let| this way: >
<pre>	:let list[4] = "four"</pre>
<pre>	:let listlist[0][3] = item<p></pre>

To change part of a list you can specify the first and last item to be
modified.  The value must at least have the number of items in the range: >
<pre>	:let list[3:5] = [3, 4, 5]<p></pre>

Adding and removing items from a list is done with functions.  Here are a few
examples: >
<pre>	:call insert(list, 'a')		" prepend item 'a'</pre>
<pre>	:call insert(list, 'a', 3)	" insert item 'a' before list[3]</pre>
<pre>	:call add(list, "new")		" append String item</pre>
<pre>	:call add(list, [1, 2])		" append a List as one new item</pre>
<pre>	:call extend(list, [1, 2])	" extend the list with two more items</pre>
<pre>	:let i = remove(list, 3)	" remove item 3</pre>
<pre>	:unlet list[3]			" idem</pre>
<pre>	:let l = remove(list, 3, -1)	" remove items 3 to last item</pre>
<pre>	:unlet list[3 : ]		" idem</pre>
<pre>	:call filter(list, 'v:val !~ "x"')  " remove items with an 'x'<p></pre>

Changing the order of items in a list: >
<pre>	:call sort(list)		" sort a list alphabetically</pre>
<pre>	:call reverse(list)		" reverse the order of items</pre>
<pre>	:call uniq(sort(list))		" sort and remove duplicates<p></pre>


For loop ~<p>

The |:for| loop executes commands for each item in a list.  A variable is set
to each item in the list in sequence.  Example: >
<pre>	:for item in mylist</pre>
<pre>	:   call Doit(item)</pre>
<pre>	:endfor<p></pre>

This works like: >
<pre>	:let index = 0</pre>
<pre>	:while index < len(mylist)</pre>
<pre>	:   let item = mylist[index]</pre>
<pre>	:   :call Doit(item)</pre>
<pre>	:   let index = index + 1</pre>
<pre>	:endwhile<p></pre>

If all you want to do is modify each item in the list then the |map()|
function will be a simpler method than a for loop.<p>

Just like the |:let| command, |:for| also accepts a list of variables.  This
requires the argument to be a list of lists. >
<pre>	:for [lnum, col] in [[1, 3], [2, 8], [3, 0]]</pre>
<pre>	:   call Doit(lnum, col)</pre>
<pre>	:endfor<p></pre>

This works like a |:let| command is done for each list item.  Again, the types
must remain the same to avoid an error.<p>

It is also possible to put remaining items in a List variable: >
<pre>	:for [i, j; rest] in listlist</pre>
<pre>	:   call Doit(i, j)</pre>
<pre>	:   if !empty(rest)</pre>
<pre>	:      echo "remainder: " . string(rest)</pre>
<pre>	:   endif</pre>
<pre>	:endfor<p></pre>


List functions ~
<pre>						*E714*</pre>
Functions that are useful with a List: >
<pre>	:let r = call(funcname, list)	" call a function with an argument list</pre>
<pre>	:if empty(list)			" check if list is empty</pre>
<pre>	:let l = len(list)		" number of items in list</pre>
<pre>	:let big = max(list)		" maximum value in list</pre>
<pre>	:let small = min(list)		" minimum value in list</pre>
<pre>	:let xs = count(list, 'x')	" count nr of times 'x' appears in list</pre>
<pre>	:let i = index(list, 'x')	" index of first 'x' in list</pre>
<pre>	:let lines = getline(1, 10)	" get ten text lines from buffer</pre>
<pre>	:call append('$', lines)	" append text lines in buffer</pre>
<pre>	:let list = split("a b c")	" create list from items in a string</pre>
<pre>	:let string = join(list, ', ')	" create string from list items</pre>
<pre>	:let s = string(list)		" String representation of list</pre>
<pre>	:call map(list, '">> " . v:val')  " prepend ">> " to each item<p></pre>

Don't forget that a combination of features can make things simple.  For
example, to add up all the numbers in a list: >
<pre>	:exe 'let sum = ' . join(nrlist, '+')<p></pre>


1.4 Dictionaries ~
<pre>				*dict* *Dict* *Dictionaries* *Dictionary*</pre>
A Dictionary is an associative array: Each entry has a key and a value.  The
entry can be located with the key.  The entries are stored without a specific
ordering.<p>


Dictionary creation ~
<pre>						*E720* *E721* *E722* *E723*</pre>
A Dictionary is created with a comma separated list of entries in curly
braces.  Each entry has a key and a value, separated by a colon.  Each key can
only appear once.  Examples: >
<pre>	:let mydict = {1: 'one', 2: 'two', 3: 'three'}</pre>
<pre>	:let emptydict = {}</pre>
<							*E713* *E716* *E717*
A key is always a String.  You can use a Number, it will be converted to a
String automatically.  Thus the String '4' and the number 4 will find the same
entry.  Note that the String '04' and the Number 04 are different, since the
Number will be converted to the String '4'.  The empty string can also be used
as a key.
<pre>						*literal-Dict* *#{}*</pre>
To avoid having to put quotes around every key the #{} form can be used.  This
does require the key to consist only of ASCII letters, digits, '-' and '_'.
Example: >
<pre>	:let mydict = #{zero: 0, one_key: 1, two-key: 2, 333: 3}</pre>
Note that 333 here is the string "333".  Empty keys are not possible with #{}.<p>

A value can be any expression.  Using a Dictionary for a value creates a
nested Dictionary: >
<pre>	:let nestdict = {1: {11: 'a', 12: 'b'}, 2: {21: 'c'}}<p></pre>

An extra comma after the last entry is ignored.<p>


Accessing entries ~<p>

The normal way to access an entry is by putting the key in square brackets: >
<pre>	:let val = mydict["one"]</pre>
<pre>	:let mydict["four"] = 4<p></pre>

You can add new entries to an existing Dictionary this way, unlike Lists.<p>

For keys that consist entirely of letters, digits and underscore the following
form can be used |expr-entry|: >
<pre>	:let val = mydict.one</pre>
<pre>	:let mydict.four = 4<p></pre>

Since an entry can be any type, also a List and a Dictionary, the indexing and
key lookup can be repeated: >
<pre>	:echo dict.key[idx].key<p></pre>


Dictionary to List conversion ~<p>

You may want to loop over the entries in a dictionary.  For this you need to
turn the Dictionary into a List and pass it to |:for|.<p>

Most often you want to loop over the keys, using the |keys()| function: >
<pre>	:for key in keys(mydict)</pre>
<pre>	:   echo key . ': ' . mydict[key]</pre>
<pre>	:endfor<p></pre>

The List of keys is unsorted.  You may want to sort them first: >
<pre>	:for key in sort(keys(mydict))<p></pre>

To loop over the values use the |values()| function:  >
<pre>	:for v in values(mydict)</pre>
<pre>	:   echo "value: " . v</pre>
<pre>	:endfor<p></pre>

If you want both the key and the value use the |items()| function.  It returns
a List in which each item is a List with two items, the key and the value: >
<pre>	:for [key, value] in items(mydict)</pre>
<pre>	:   echo key . ': ' . value</pre>
<pre>	:endfor<p></pre>


Dictionary identity ~
<pre>							*dict-identity*</pre>
Just like Lists you need to use |copy()| and |deepcopy()| to make a copy of a
Dictionary.  Otherwise, assignment results in referring to the same
Dictionary: >
<pre>	:let onedict = {'a': 1, 'b': 2}</pre>
<pre>	:let adict = onedict</pre>
<pre>	:let adict['a'] = 11</pre>
<pre>	:echo onedict['a']</pre>
<pre>	11<p></pre>

Two Dictionaries compare equal if all the key-value pairs compare equal.  For
more info see |list-identity|.<p>


Dictionary modification ~
<pre>							*dict-modification*</pre>
To change an already existing entry of a Dictionary, or to add a new entry,
use |:let| this way: >
<pre>	:let dict[4] = "four"</pre>
<pre>	:let dict['one'] = item<p></pre>

Removing an entry from a Dictionary is done with |remove()| or |:unlet|.
Three ways to remove the entry with key "aaa" from dict: >
<pre>	:let i = remove(dict, 'aaa')</pre>
<pre>	:unlet dict.aaa</pre>
<pre>	:unlet dict['aaa']<p></pre>

Merging a Dictionary with another is done with |extend()|: >
<pre>	:call extend(adict, bdict)</pre>
This extends adict with all entries from bdict.  Duplicate keys cause entries
in adict to be overwritten.  An optional third argument can change this.
Note that the order of entries in a Dictionary is irrelevant, thus don't
expect ":echo adict" to show the items from bdict after the older entries in
adict.<p>

Weeding out entries from a Dictionary can be done with |filter()|: >
<pre>	:call filter(dict, 'v:val =~ "x"')</pre>
This removes all entries from "dict" with a value not matching 'x'.<p>


Dictionary function ~
<pre>				*Dictionary-function* *self* *E725* *E862*</pre>
When a function is defined with the "dict" attribute it can be used in a
special way with a dictionary.  Example: >
<pre>	:function Mylen() dict</pre>
<pre>	:   return len(self.data)</pre>
<pre>	:endfunction</pre>
<pre>	:let mydict = {'data': [0, 1, 2, 3], 'len': function("Mylen")}</pre>
<pre>	:echo mydict.len()<p></pre>

This is like a method in object oriented programming.  The entry in the
Dictionary is a |Funcref|.  The local variable "self" refers to the dictionary
the function was invoked from.<p>

It is also possible to add a function without the "dict" attribute as a
Funcref to a Dictionary, but the "self" variable is not available then.<p>

<pre>				*numbered-function* *anonymous-function*</pre>
To avoid the extra name for the function it can be defined and directly
assigned to a Dictionary in this way: >
<pre>	:let mydict = {'data': [0, 1, 2, 3]}</pre>
<pre>	:function mydict.len()</pre>
<pre>	:   return len(self.data)</pre>
<pre>	:endfunction</pre>
<pre>	:echo mydict.len()<p></pre>

The function will then get a number and the value of dict.len is a |Funcref|
that references this function.  The function can only be used through a
|Funcref|.  It will automatically be deleted when there is no |Funcref|
remaining that refers to it.<p>

It is not necessary to use the "dict" attribute for a numbered function.<p>

If you get an error for a numbered function, you can find out what it is with
a trick.  Assuming the function is 42, the command is: >
<pre>	:function {42}<p></pre>


Functions for Dictionaries ~
<pre>							*E715*</pre>
Functions that can be used with a Dictionary: >
<pre>	:if has_key(dict, 'foo')	" TRUE if dict has entry with key "foo"</pre>
<pre>	:if empty(dict)			" TRUE if dict is empty</pre>
<pre>	:let l = len(dict)		" number of items in dict</pre>
<pre>	:let big = max(dict)		" maximum value in dict</pre>
<pre>	:let small = min(dict)		" minimum value in dict</pre>
<pre>	:let xs = count(dict, 'x')	" count nr of times 'x' appears in dict</pre>
<pre>	:let s = string(dict)		" String representation of dict</pre>
<pre>	:call map(dict, '">> " . v:val')  " prepend ">> " to each item<p></pre>


1.5 Blobs ~
<pre>						*blob* *Blob* *Blobs* *E978*</pre>
A Blob is a binary object.  It can be used to read an image from a file and
send it over a channel, for example.<p>

A Blob mostly behaves like a |List| of numbers, where each number has the
value of an 8-bit byte, from 0 to 255.<p>


Blob creation ~<p>

A Blob can be created with a |blob-literal|: >
<pre>	:let b = 0zFF00ED015DAF</pre>
Dots can be inserted between bytes (pair of hex characters) for readability,
they don't change the value: >
<pre>	:let b = 0zFF00.ED01.5DAF<p></pre>

A blob can be read from a file with |readfile()| passing the {type} argument
set to "B", for example: >
<pre>	:let b = readfile('image.png', 'B')<p></pre>

A blob can be read from a channel with the |ch_readblob()| function.<p>


Blob index ~
<pre>							*blob-index* *E979*</pre>
A byte in the Blob can be accessed by putting the index in square brackets
after the Blob.  Indexes are zero-based, thus the first byte has index zero. >
<pre>	:let myblob = 0z00112233</pre>
<pre>	:let byte = myblob[0]		" get the first byte: 0x00</pre>
<pre>	:let byte = myblob[2]		" get the third byte: 0x22<p></pre>

A negative index is counted from the end.  Index -1 refers to the last byte in
the Blob, -2 to the last but one byte, etc. >
<pre>	:let last = myblob[-1]		" get the last byte: 0x33<p></pre>

To avoid an error for an invalid index use the |get()| function.  When an item
is not available it returns -1 or the default value you specify: >
<pre>	:echo get(myblob, idx)</pre>
<pre>	:echo get(myblob, idx, 999)<p></pre>


Blob iteration ~<p>

The |:for| loop executes commands for each byte of a Blob.  The loop variable is
set to each byte in the Blob.  Example: >
<pre>	:for byte in 0z112233</pre>
<pre>	:   call Doit(byte)</pre>
<pre>	:endfor</pre>
This calls Doit() with 0x11, 0x22 and 0x33.<p>


Blob concatenation ~<p>

Two blobs can be concatenated with the "+" operator: >
<pre>	:let longblob = myblob + 0z4455</pre>
<pre>	:let myblob += 0z6677<p></pre>

To change a blob in-place see |blob-modification| below.<p>


Part of a blob ~<p>

A part of the Blob can be obtained by specifying the first and last index,
separated by a colon in square brackets: >
<pre>	:let myblob = 0z00112233</pre>
<pre>	:let shortblob = myblob[1:2]	" get 0z1122</pre>
<pre>	:let shortblob = myblob[2:-1]	" get 0z2233<p></pre>

Omitting the first index is similar to zero.  Omitting the last index is
similar to -1. >
<pre>	:let endblob = myblob[2:]	" from item 2 to the end: 0z2233</pre>
<pre>	:let shortblob = myblob[2:2]	" Blob with one byte: 0z22</pre>
<pre>	:let otherblob = myblob[:]	" make a copy of the Blob<p></pre>

If the first index is beyond the last byte of the Blob or the second index is
before the first index, the result is an empty Blob.  There is no error
message.<p>

If the second index is equal to or greater than the length of the list the
length minus one is used: >
<pre>	:echo myblob[2:8]		" result: 0z2233<p></pre>


Blob modification ~
<pre>							*blob-modification*</pre>
To change a specific byte of a blob use |:let| this way: >
<pre>	:let blob[4] = 0x44<p></pre>

When the index is just one beyond the end of the Blob, it is appended. Any
higher index is an error.<p>

To change a sequence of bytes the [:] notation can be used: >
<pre>	let blob[1:3] = 0z445566</pre>
The length of the replaced bytes must be exactly the same as the value
provided. *E972*<p>

To change part of a blob you can specify the first and last byte to be
modified.  The value must have the same number of bytes in the range: >
<pre>	:let blob[3:5] = 0z334455<p></pre>

You can also use the functions |add()|, |remove()| and |insert()|.<p>


Blob identity ~<p>

Blobs can be compared for equality: >
<pre>	if blob == 0z001122</pre>
And for equal identity: >
<pre>	if blob is otherblob</pre>
<							*blob-identity* *E977*
When variable "aa" is a Blob and you assign it to another variable "bb", both
variables refer to the same Blob.  Then the "is" operator returns true.<p>

When making a copy using [:] or |copy()| the values are the same, but the
identity is different: >
<pre>	:let blob = 0z112233</pre>
<pre>	:let blob2 = blob</pre>
<pre>	:echo blob == blob2</pre>
<	1 >
<pre>	:echo blob is blob2</pre>
<	1 >
<pre>	:let blob3 = blob[:]</pre>
<pre>	:echo blob == blob3</pre>
<	1 >
<pre>	:echo blob is blob3</pre>
<	0<p>

Making a copy of a Blob is done with the |copy()| function.  Using [:] also
works, as explained above.<p>


1.6 More about variables ~
<pre>							*more-variables*</pre>
If you need to know the type of a variable or expression, use the |type()|
function.<p>

When the '!' flag is included in the 'viminfo' option, global variables that
start with an uppercase letter, and don't contain a lowercase letter, are
stored in the viminfo file |viminfo-file|.<p>

When the 'sessionoptions' option contains "global", global variables that
start with an uppercase letter and contain at least one lowercase letter are
stored in the session file |session-file|.<p>

variable name		can be stored where ~
my_var_6		not
My_Var_6		session file
MY_VAR_6		viminfo file<p>


It's possible to form a variable name with curly braces, see
|curly-braces-names|.<p>

* Expression syntax					*expression-syntax*<p>

Expression syntax summary, from least to most significant:<p>

|expr1|	expr2
<pre>	expr2 ? expr1 : expr1	if-then-else<p></pre>

|expr2|	expr3
<pre>	expr3 || expr3 ...	logical OR<p></pre>

|expr3|	expr4
<pre>	expr4 && expr4 ...	logical AND<p></pre>

|expr4|	expr5
<pre>	expr5 == expr5		equal</pre>
<pre>	expr5 != expr5		not equal</pre>
<pre>	expr5 >	 expr5		greater than</pre>
<pre>	expr5 >= expr5		greater than or equal</pre>
<pre>	expr5 <	 expr5		smaller than</pre>
<pre>	expr5 <= expr5		smaller than or equal</pre>
<pre>	expr5 =~ expr5		regexp matches</pre>
<pre>	expr5 !~ expr5		regexp doesn't match<p></pre>

<pre>	expr5 ==? expr5		equal, ignoring case</pre>
<pre>	expr5 ==# expr5		equal, match case</pre>
<pre>	etc.			As above, append ? for ignoring case, # for</pre>
<pre>				matching case<p></pre>

<pre>	expr5 is expr5		same |List|, |Dictionary| or |Blob| instance</pre>
<pre>	expr5 isnot expr5	different |List|, |Dictionary| or |Blob|</pre>
<pre>				instance<p></pre>

|expr5|	expr6
<pre>	expr6 +	 expr6 ...	number addition, list or blob concatenation</pre>
<pre>	expr6 -	 expr6 ...	number subtraction</pre>
<pre>	expr6 .	 expr6 ...	string concatenation</pre>
<pre>	expr6 .. expr6 ...	string concatenation<p></pre>

|expr6|	expr7
<pre>	expr7 *	 expr7 ...	number multiplication</pre>
<pre>	expr7 /	 expr7 ...	number division</pre>
<pre>	expr7 %	 expr7 ...	number modulo<p></pre>

|expr7|	expr8
<pre>	! expr7			logical NOT</pre>
<pre>	- expr7			unary minus</pre>
<pre>	+ expr7			unary plus<p></pre>

|expr8|	expr9
<pre>	expr8[expr1]		byte of a String or item of a |List|</pre>
<pre>	expr8[expr1 : expr1]	substring of a String or sublist of a |List|</pre>
<pre>	expr8.name		entry in a |Dictionary|</pre>
<pre>	expr8(expr1, ...)	function call with |Funcref| variable</pre>
<pre>	expr8->name(expr1, ...)	|method| call<p></pre>

|expr9|	number			number constant
<pre>	"string"		string constant, backslash is special</pre>
<pre>	'string'		string constant, ' is doubled</pre>
<pre>	[expr1, ...]		|List|</pre>
<pre>	{expr1: expr1, ...}	|Dictionary|</pre>
<pre>	#{key: expr1, ...}	|Dictionary|</pre>
<pre>	&option			option value</pre>
<pre>	(expr1)			nested expression</pre>
<pre>	variable		internal variable</pre>
<pre>	va{ria}ble		internal variable with curly braces</pre>
<pre>	$VAR			environment variable</pre>
<pre>	@r			contents of register 'r'</pre>
<pre>	function(expr1, ...)	function call</pre>
<pre>	func{ti}on(expr1, ...)	function call with curly braces</pre>
<pre>	{args -> expr1}		lambda expression<p></pre>


"..." indicates that the operations in this level can be concatenated.
Example: >
<pre>	&nu || &list && &shell == "csh"<p></pre>

All expressions within one level are parsed from left to right.<p>


expr1							*expr1* *E109*
-----<p>

expr2 ? expr1 : expr1<p>

The expression before the '?' is evaluated to a number.  If it evaluates to
|TRUE|, the result is the value of the expression between the '?' and ':',
otherwise the result is the value of the expression after the ':'.
Example: >
<pre>	:echo lnum == 1 ? "top" : lnum<p></pre>

Since the first expression is an "expr2", it cannot contain another ?:.  The
other two expressions can, thus allow for recursive use of ?:.
Example: >
<pre>	:echo lnum == 1 ? "top" : lnum == 1000 ? "last" : lnum<p></pre>

To keep this readable, using |line-continuation| is suggested: >
<pre>	:echo lnum == 1</pre>
<pre>	:\	? "top"</pre>
<pre>	:\	: lnum == 1000</pre>
<pre>	:\		? "last"</pre>
<pre>	:\		: lnum<p></pre>

You should always put a space before the ':', otherwise it can be mistaken for
use in a variable such as "a:1".<p>


expr2 and expr3						*expr2* *expr3*
---------------<p>

expr3 || expr3 ..	logical OR		*expr-barbar*
expr4 && expr4 ..	logical AND		*expr-&&*<p>

The "||" and "&&" operators take one argument on each side.  The arguments
are (converted to) Numbers.  The result is:<p>

<pre>    input			 output ~</pre>
n1	n2		n1 || n2	n1 && n2 ~
|FALSE|	|FALSE|		|FALSE|		|FALSE|
|FALSE|	|TRUE|		|TRUE|		|FALSE|
|TRUE|	|FALSE|		|TRUE|		|FALSE|
|TRUE|	|TRUE|		|TRUE|		|TRUE|<p>

The operators can be concatenated, for example: ><p>

<pre>	&nu || &list && &shell == "csh"<p></pre>

Note that "&&" takes precedence over "||", so this has the meaning of: ><p>

<pre>	&nu || (&list && &shell == "csh")<p></pre>

Once the result is known, the expression "short-circuits", that is, further
arguments are not evaluated.  This is like what happens in C.  For example: ><p>

<pre>	let a = 1</pre>
<pre>	echo a || b<p></pre>

This is valid even if there is no variable called "b" because "a" is |TRUE|,
so the result must be |TRUE|.  Similarly below: ><p>

<pre>	echo exists("b") && b == "yes"<p></pre>

This is valid whether "b" has been defined or not.  The second clause will
only be evaluated if "b" has been defined.<p>


expr4							*expr4*
-----<p>

expr5 {cmp} expr5<p>

Compare two expr5 expressions, resulting in a 0 if it evaluates to false, or 1
if it evaluates to true.<p>

<pre>			*expr-==*  *expr-!=*  *expr->*	 *expr->=*</pre>
<pre>			*expr-<*   *expr-<=*  *expr-=~*  *expr-!~*</pre>
<pre>			*expr-==#* *expr-!=#* *expr->#*  *expr->=#*</pre>
<pre>			*expr-<#*  *expr-<=#* *expr-=~#* *expr-!~#*</pre>
<pre>			*expr-==?* *expr-!=?* *expr->?*  *expr->=?*</pre>
<pre>			*expr-<?*  *expr-<=?* *expr-=~?* *expr-!~?*</pre>
<pre>			*expr-is* *expr-isnot* *expr-is#* *expr-isnot#*</pre>
<pre>			*expr-is?* *expr-isnot?*</pre>
<pre>		use 'ignorecase'    match case	   ignore case ~</pre>
equal			==		==#		==?
not equal		!=		!=#		!=?
greater than		>		>#		>?
greater than or equal	>=		>=#		>=?
smaller than		<		<#		<?
smaller than or equal	<=		<=#		<=?
regexp matches		=~		=~#		=~?
regexp doesn't match	!~		!~#		!~?
same instance		is		is#		is?
different instance	isnot		isnot#		isnot?<p>

Examples:
"abc" ==# "Abc"	  evaluates to 0
"abc" ==? "Abc"	  evaluates to 1
"abc" == "Abc"	  evaluates to 1 if 'ignorecase' is set, 0 otherwise<p>

<pre>							*E691* *E692*</pre>
A |List| can only be compared with a |List| and only "equal", "not equal",
"is" and "isnot" can be used.  This compares the values of the list,
recursively.  Ignoring case means case is ignored when comparing item values.<p>

<pre>							*E735* *E736*</pre>
A |Dictionary| can only be compared with a |Dictionary| and only "equal", "not
equal", "is" and "isnot" can be used.  This compares the key/values of the
|Dictionary| recursively.  Ignoring case means case is ignored when comparing
item values.<p>

<pre>							*E694*</pre>
A |Funcref| can only be compared with a |Funcref| and only "equal", "not
equal", "is" and "isnot" can be used.  Case is never ignored.  Whether
arguments or a Dictionary are bound (with a partial) matters.  The
Dictionaries must also be equal (or the same, in case of "is") and the
arguments must be equal (or the same).<p>

To compare Funcrefs to see if they refer to the same function, ignoring bound
Dictionary and arguments, use |get()| to get the function name: >
<pre>	if get(Part1, 'name') == get(Part2, 'name')</pre>
<pre>	   " Part1 and Part2 refer to the same function<p></pre>

Using "is" or "isnot" with a |List|, |Dictionary| or |Blob| checks whether
the expressions are referring to the same |List|, |Dictionary| or |Blob|
instance.  A copy of a |List| is different from the original |List|.  When
using "is" without a |List|, |Dictionary| or |Blob|, it is equivalent to
using "equal", using "isnot" equivalent to using "not equal".  Except that
a different type means the values are different: >
<pre>	echo 4 == '4'</pre>
<pre>	1</pre>
<pre>	echo 4 is '4'</pre>
<pre>	0</pre>
<pre>	echo 0 is []</pre>
<pre>	0</pre>
"is#"/"isnot#" and "is?"/"isnot?" can be used to match and ignore case.<p>

When comparing a String with a Number, the String is converted to a Number,
and the comparison is done on Numbers.  This means that: >
<pre>	echo 0 == 'x'</pre>
<pre>	1</pre>
because 'x' converted to a Number is zero.  However: >
<pre>	echo [0] == ['x']</pre>
<pre>	0</pre>
Inside a List or Dictionary this conversion is not used.<p>

When comparing two Strings, this is done with strcmp() or stricmp().  This
results in the mathematical difference (comparing byte values), not
necessarily the alphabetical difference in the local language.<p>

When using the operators with a trailing '#', or the short version and
'ignorecase' is off, the comparing is done with strcmp(): case matters.<p>

When using the operators with a trailing '?', or the short version and
'ignorecase' is set, the comparing is done with stricmp(): case is ignored.<p>

'smartcase' is not used.<p>

The "=~" and "!~" operators match the lefthand argument with the righthand
argument, which is used as a pattern.  See |pattern| for what a pattern is.
This matching is always done like 'magic' was set and 'cpoptions' is empty, no
matter what the actual value of 'magic' or 'cpoptions' is.  This makes scripts
portable.  To avoid backslashes in the regexp pattern to be doubled, use a
single-quote string, see |literal-string|.
Since a string is considered to be a single line, a multi-line pattern
(containing \n, backslash-n) will not match.  However, a literal NL character
can be matched like an ordinary character.  Examples:
<pre>	"foo\nbar" =~ "\n"	evaluates to 1</pre>
<pre>	"foo\nbar" =~ "\\n"	evaluates to 0<p></pre>


expr5 and expr6						*expr5* *expr6*
---------------
expr6 + expr6   Number addition, |List| or |Blob| concatenation	*expr-+*
expr6 - expr6   Number subtraction				*expr--*
expr6 . expr6   String concatenation				*expr-.*
expr6 .. expr6  String concatenation				*expr-..*<p>

For |Lists| only "+" is possible and then both expr6 must be a list.  The
result is a new list with the two lists Concatenated.<p>

For String concatenation ".." is preferred, since "." is ambiguous, it is also
used for |Dict| member access and floating point numbers.
When |vimscript-version| is 2 or higher, using "." is not allowed.<p>

expr7 * expr7  Number multiplication				*expr-star*
expr7 / expr7  Number division					*expr-/*
expr7 % expr7  Number modulo					*expr-%*<p>

For all, except "." and "..", Strings are converted to Numbers.
For bitwise operators see |and()|, |or()| and |xor()|.<p>

Note the difference between "+" and ".":
<pre>	"123" + "456" = 579</pre>
<pre>	"123" . "456" = "123456"<p></pre>

Since '.' has the same precedence as '+' and '-', you need to read: >
<pre>	1 . 90 + 90.0</pre>
As: >
<pre>	(1 . 90) + 90.0</pre>
That works, since the String "190" is automatically converted to the Number
190, which can be added to the Float 90.0.  However: >
<pre>	1 . 90 * 90.0</pre>
Should be read as: >
<pre>	1 . (90 * 90.0)</pre>
Since '.' has lower precedence than '*'.  This does NOT work, since this
attempts to concatenate a Float and a String.<p>

When dividing a Number by zero the result depends on the value:
<pre>	  0 / 0  = -0x80000000	(like NaN for Float)</pre>
<pre>	 >0 / 0  =  0x7fffffff	(like positive infinity)</pre>
<pre>	 <0 / 0  = -0x7fffffff	(like negative infinity)</pre>
<pre>	(before Vim 7.2 it was always 0x7fffffff)<p></pre>

When 64-bit Number support is enabled:
<pre>	  0 / 0  = -0x8000000000000000	(like NaN for Float)</pre>
<pre>	 >0 / 0  =  0x7fffffffffffffff	(like positive infinity)</pre>
<pre>	 <0 / 0  = -0x7fffffffffffffff	(like negative infinity)<p></pre>

When the righthand side of '%' is zero, the result is 0.<p>

None of these work for |Funcref|s.<p>

. and % do not work for Float. *E804*<p>


expr7							*expr7*
-----
! expr7			logical NOT		*expr-!*
<pre>- expr7			unary minus		*expr-unary--*</pre>
+ expr7			unary plus		*expr-unary-+*<p>

For '!' |TRUE| becomes |FALSE|, |FALSE| becomes |TRUE| (one).
For '-' the sign of the number is changed.
For '+' the number is unchanged.<p>

A String will be converted to a Number first.<p>

These three can be repeated and mixed.  Examples:
<pre>	!-1	    == 0</pre>
<pre>	!!8	    == 1</pre>
<pre>	--9	    == 9<p></pre>


expr8							*expr8*
-----
This expression is either |expr9| or a sequence of the alternatives below,
in any order.  E.g., these are all possible:
<pre>	expr8[expr1].name</pre>
<pre>	expr8.name[expr1]</pre>
<pre>	expr8(expr1, ...)[expr1].name</pre>
<pre>	expr8->(expr1, ...)[expr1]</pre>
Evaluation is always from left to right.<p>

expr8[expr1]		item of String or |List|	*expr-[]* *E111*
<pre>							*E909* *subscript*</pre>
If expr8 is a Number or String this results in a String that contains the
expr1'th single byte from expr8.  expr8 is used as a String, expr1 as a
Number.  This doesn't recognize multi-byte encodings, see `byteidx()` for
an alternative, or use `split()` to turn the string into a list of characters.<p>

Index zero gives the first byte.  This is like it works in C.  Careful:
text column numbers start with one!  Example, to get the byte under the
cursor: >
<pre>	:let c = getline(".")[col(".") - 1]<p></pre>

If the length of the String is less than the index, the result is an empty
String.  A negative index always results in an empty string (reason: backward
compatibility).  Use [-1:] to get the last byte.<p>

If expr8 is a |List| then it results the item at index expr1.  See |list-index|
for possible index values.  If the index is out of range this results in an
error.  Example: >
<pre>	:let item = mylist[-1]		" get last item<p></pre>

Generally, if a |List| index is equal to or higher than the length of the
|List|, or more negative than the length of the |List|, this results in an
error.<p>


expr8[expr1a : expr1b]	substring or sublist		*expr-[:]*<p>

If expr8 is a Number or String this results in the substring with the bytes
from expr1a to and including expr1b.  expr8 is used as a String, expr1a and
expr1b are used as a Number.  This doesn't recognize multi-byte encodings, see
|byteidx()| for computing the indexes.<p>

If expr1a is omitted zero is used.  If expr1b is omitted the length of the
string minus one is used.<p>

A negative number can be used to measure from the end of the string.  -1 is
the last character, -2 the last but one, etc.<p>

If an index goes out of range for the string characters are omitted.  If
expr1b is smaller than expr1a the result is an empty string.<p>

Examples: >
<pre>	:let c = name[-1:]		" last byte of a string</pre>
<pre>	:let c = name[-2:-2]		" last but one byte of a string</pre>
<pre>	:let s = line(".")[4:]		" from the fifth byte to the end</pre>
<pre>	:let s = s[:-3]			" remove last two bytes</pre>
<
<pre>							*slice*</pre>
If expr8 is a |List| this results in a new |List| with the items indicated by
the indexes expr1a and expr1b.  This works like with a String, as explained
just above. Also see |sublist| below.  Examples: >
<pre>	:let l = mylist[:3]		" first four items</pre>
<pre>	:let l = mylist[4:4]		" List with one item</pre>
<pre>	:let l = mylist[:]		" shallow copy of a List<p></pre>

If expr8 is a |Blob| this results in a new |Blob| with the bytes in the
indexes expr1a and expr1b, inclusive.  Examples: >
<pre>	:let b = 0zDEADBEEF</pre>
<pre>	:let bs = b[1:2]		" 0zADBE</pre>
<pre>	:let bs = b[:]			" copy of 0zDEADBEEF<p></pre>

Using expr8[expr1] or expr8[expr1a : expr1b] on a |Funcref| results in an
error.<p>

Watch out for confusion between a namespace and a variable followed by a colon
for a sublist: >
<pre>	mylist[n:]     " uses variable n</pre>
<pre>	mylist[s:]     " uses namespace s:, error!<p></pre>


expr8.name		entry in a |Dictionary|		*expr-entry*<p>

If expr8 is a |Dictionary| and it is followed by a dot, then the following
name will be used as a key in the |Dictionary|.  This is just like:
expr8[name].<p>

The name must consist of alphanumeric characters, just like a variable name,
but it may start with a number.  Curly braces cannot be used.<p>

There must not be white space before or after the dot.<p>

Examples: >
<pre>	:let dict = {"one": 1, 2: "two"}</pre>
<pre>	:echo dict.one		" shows "1"</pre>
<pre>	:echo dict.2		" shows "two"</pre>
<pre>	:echo dict .2		" error because of space before the dot<p></pre>

Note that the dot is also used for String concatenation.  To avoid confusion
always put spaces around the dot for String concatenation.<p>


expr8(expr1, ...)	|Funcref| function call<p>

When expr8 is a |Funcref| type variable, invoke the function it refers to.<p>


expr8->name([args])	method call			*method* *->*
expr8->{lambda}([args])
<pre>							*E276*</pre>
For methods that are also available as global functions this is the same as: >
<pre>	name(expr8 [, args])</pre>
There can also be methods specifically for the type of "expr8".<p>

This allows for chaining, passing the value that one method returns to the
next method: >
<pre>	mylist->filter(filterexpr)->map(mapexpr)->sort()->join()</pre>
<
Example of using a lambda: >
<pre>	GetPercentage()->{x -> x * 100}()->printf('%d%%')</pre>
<
When using -> the |expr7| operators will be applied first, thus: >
<pre>	-1.234->string()</pre>
Is equivalent to: >
<pre>	(-1.234)->string()</pre>
And NOT: >
<pre>	-(1.234->string())</pre>
<
<pre>							*E274*</pre>
"->name(" must not contain white space.  There can be white space before the
"->" and after the "(", thus you can split the lines like this: >
<pre>	mylist</pre>
<pre>	\ ->filter(filterexpr)</pre>
<pre>	\ ->map(mapexpr)</pre>
<pre>	\ ->sort()</pre>
<pre>	\ ->join()<p></pre>

When using the lambda form there must be no white space between the } and the
(.<p>


<pre>							*expr9*</pre>
number
------
number			number constant			*expr-number*
<pre>				*hex-number* *octal-number* *binary-number*<p></pre>

Decimal, Hexadecimal (starting with 0x or 0X), Binary (starting with 0b or 0B)
and Octal (starting with 0).<p>

<pre>						*floating-point-format*</pre>
Floating point numbers can be written in two forms:<p>

<pre>	[-+]{N}.{M}</pre>
<pre>	[-+]{N}.{M}[eE][-+]{exp}<p></pre>

{N} and {M} are numbers.  Both {N} and {M} must be present and can only
contain digits.
[-+] means there is an optional plus or minus sign.
{exp} is the exponent, power of 10.
Only a decimal point is accepted, not a comma.  No matter what the current
locale is.
{only when compiled with the |+float| feature}<p>

Examples:
<pre>	123.456</pre>
<pre>	+0.0001</pre>
<pre>	55.0</pre>
<pre>	-0.123</pre>
<pre>	1.234e03</pre>
<pre>	1.0E-6</pre>
<pre>	-3.1416e+88<p></pre>

These are INVALID:
<pre>	3.		empty {M}</pre>
<pre>	1e40		missing .{M}<p></pre>

Rationale:
Before floating point was introduced, the text "123.456" was interpreted as
the two numbers "123" and "456", both converted to a string and concatenated,
resulting in the string "123456".  Since this was considered pointless, and we
could not find it intentionally being used in Vim scripts, this backwards
incompatibility was accepted in favor of being able to use the normal notation
for floating point numbers.<p>

<pre>							*float-pi* *float-e*</pre>
A few useful values to copy&paste: >
<pre>	:let pi = 3.14159265359</pre>
<pre>	:let e  = 2.71828182846</pre>
Or, if you don't want to write them in as floating-point literals, you can
also use functions, like the following: >
<pre>	:let pi = acos(-1.0)</pre>
<pre>	:let e  = exp(1.0)</pre>
<
<pre>						*floating-point-precision*</pre>
The precision and range of floating points numbers depends on what "double"
means in the library Vim was compiled with.  There is no way to change this at
runtime.<p>

The default for displaying a |Float| is to use 6 decimal places, like using
printf("%g", f).  You can select something else when using the |printf()|
function.  Example: >
<pre>	:echo printf('%.15e', atan(1))</pre>
<	7.853981633974483e-01<p>

<p>

string					*string* *String* *expr-string* *E114*
------
"string"		string constant		*expr-quote*<p>

Note that double quotes are used.<p>

A string constant accepts these special characters:
\...	three-digit octal number (e.g., "\316")
\..	two-digit octal number (must be followed by non-digit)
\.	one-digit octal number (must be followed by non-digit)
\x..	byte specified with two hex numbers (e.g., "\x1f")
\x.	byte specified with one hex number (must be followed by non-hex char)
\X..	same as \x..
\X.	same as \x.
\u....	character specified with up to 4 hex numbers, stored according to the
<pre>	current value of 'encoding' (e.g., "\u02a4")</pre>
\U....	same as \u but allows up to 8 hex numbers.
\b	backspace <BS>
\e	escape <Esc>
\f	formfeed <FF>
\n	newline <NL>
\r	return <CR>
\t	tab <Tab>
\\	backslash
\"	double quote
\<xxx>	Special key named "xxx".  e.g. "\<C-W>" for CTRL-W.  This is for use
<pre>	in mappings, the 0x80 byte is escaped.</pre>
<pre>	To use the double quote character it must be escaped: "<M-\">".</pre>
<pre>	Don't use <Char-xxxx> to get a utf-8 character, use \uxxxx as</pre>
<pre>	mentioned above.<p></pre>

Note that "\xff" is stored as the byte 255, which may be invalid in some
encodings.  Use "\u00ff" to store character 255 according to the current value
of 'encoding'.<p>

Note that "\000" and "\x00" force the end of the string.<p>


blob-literal				*blob-literal* *E973*
------------<p>

Hexadecimal starting with 0z or 0Z, with an arbitrary number of bytes.
The sequence must be an even number of hex characters.  Example: >
<pre>	:let b = 0zFF00ED015DAF<p></pre>


literal-string						*literal-string* *E115*
---------------
'string'		string constant			*expr-'*<p>

Note that single quotes are used.<p>

This string is taken as it is.  No backslashes are removed or have a special
meaning.  The only exception is that two quotes stand for one quote.<p>

Single quoted strings are useful for patterns, so that backslashes do not need
to be doubled.  These two commands are equivalent: >
<pre>	if a =~ "\\s*"</pre>
<pre>	if a =~ '\s*'<p></pre>


option						*expr-option* *E112* *E113*
------
&option			option value, local value if possible
&g:option		global option value
&l:option		local option value<p>

Examples: >
<pre>	echo "tabstop is " . &tabstop</pre>
<pre>	if &insertmode<p></pre>

Any option name can be used here.  See |options|.  When using the local value
and there is no buffer-local or window-local value, the global value is used
anyway.<p>


register						*expr-register* *@r*
--------
@r			contents of register 'r'<p>

The result is the contents of the named register, as a single string.
Newlines are inserted where required.  To get the contents of the unnamed
register use @" or @@.  See |registers| for an explanation of the available
registers.<p>

When using the '=' register you get the expression itself, not what it
evaluates to.  Use |eval()| to evaluate it.<p>


nesting							*expr-nesting* *E110*
-------
(expr1)			nested expression<p>


environment variable					*expr-env*
--------------------
$VAR			environment variable<p>

The String value of any environment variable.  When it is not defined, the
result is an empty string.<p>

The functions `getenv()` and `setenv()` can also be used and work for
environment variables with non-alphanumeric names.
The function `environ()` can be used to get a Dict with all environment
variables.<p>


<pre>						*expr-env-expand*</pre>
Note that there is a difference between using $VAR directly and using
expand("$VAR").  Using it directly will only expand environment variables that
are known inside the current Vim session.  Using expand() will first try using
the environment variables known inside the current Vim session.  If that
fails, a shell will be used to expand the variable.  This can be slow, but it
does expand all variables that the shell knows about.  Example: >
<pre>	:echo $shell</pre>
<pre>	:echo expand("$shell")</pre>
The first one probably doesn't echo anything, the second echoes the $shell
variable (if your shell supports it).<p>


internal variable					*expr-variable*
-----------------
variable		internal variable
See below |internal-variables|.<p>


function call		*expr-function* *E116* *E118* *E119* *E120*
-------------
function(expr1, ...)	function call
See below |functions|.<p>


lambda expression				*expr-lambda* *lambda*
-----------------
{args -> expr1}		lambda expression<p>

A lambda expression creates a new unnamed function which returns the result of
evaluating |expr1|.  Lambda expressions differ from |user-functions| in
the following ways:<p>

<pre>1. The body of the lambda expression is an |expr1| and not a sequence of |Ex|</pre>
<pre>   commands.</pre>
<pre>2. The prefix "a:" should not be used for arguments.  E.g.: ></pre>
<pre>	:let F = {arg1, arg2 -> arg1 - arg2}</pre>
<pre>	:echo F(5, 2)</pre>
<	3<p>

The arguments are optional.  Example: >
<pre>	:let F = {-> 'error function'}</pre>
<pre>	:echo F()</pre>
<	error function
<pre>							*closure*</pre>
Lambda expressions can access outer scope variables and arguments.  This is
often called a closure.  Example where "i" and "a:arg" are used in a lambda
while they already exist in the function scope.  They remain valid even after
the function returns: >
<pre>	:function Foo(arg)</pre>
<pre>	:  let i = 3</pre>
<pre>	:  return {x -> x + i - a:arg}</pre>
<pre>	:endfunction</pre>
<pre>	:let Bar = Foo(4)</pre>
<pre>	:echo Bar(6)</pre>
<	5<p>

Note that the variables must exist in the outer scope before the lamba is
defined for this to work.  See also |:func-closure|.<p>

Lambda and closure support can be checked with: >
<pre>	if has('lambda')<p></pre>

Examples for using a lambda expression with |sort()|, |map()| and |filter()|: >
<pre>	:echo map([1, 2, 3], {idx, val -> val + 1})</pre>
<	[2, 3, 4] >
<pre>	:echo sort([3,7,2,1,4], {a, b -> a - b})</pre>
<	[1, 2, 3, 4, 7]<p>

The lambda expression is also useful for Channel, Job and timer: >
<pre>	:let timer = timer_start(500,</pre>
<pre>			\ {-> execute("echo 'Handler called'", "")},</pre>
<pre>			\ {'repeat': 3})</pre>
<	Handler called
<pre>	Handler called</pre>
<pre>	Handler called<p></pre>

Note how execute() is used to execute an Ex command.  That's ugly though.<p>


Lambda expressions have internal names like '<lambda>42'.  If you get an error
for a lambda expression, you can find what it is with the following command: >
<pre>	:function {'<lambda>42'}</pre>
See also: |numbered-function|<p>

* Internal variable				*internal-variables* *E461*<p>

An internal variable name can be made up of letters, digits and '_'.  But it
cannot start with a digit.  It's also possible to use curly braces, see
|curly-braces-names|.<p>

An internal variable is created with the ":let" command |:let|.
An internal variable is explicitly destroyed with the ":unlet" command
|:unlet|.
Using a name that is not an internal variable or refers to a variable that has
been destroyed results in an error.<p>

There are several name spaces for variables.  Which one is to be used is
specified by what is prepended:<p>

<pre>		(nothing) In a function: local to a function; otherwise: global</pre>
|buffer-variable|    b:	  Local to the current buffer.
|window-variable|    w:	  Local to the current window.
|tabpage-variable|   t:	  Local to the current tab page.
|global-variable|    g:	  Global.
|local-variable|     l:	  Local to a function.
|script-variable|    s:	  Local to a |:source|'ed Vim script.
|function-argument|  a:	  Function argument (only inside a function).
|vim-variable|       v:	  Global, predefined by Vim.<p>

The scope name by itself can be used as a |Dictionary|.  For example, to
delete all script-local variables: >
<pre>	:for k in keys(s:)</pre>
<pre>	:    unlet s:[k]</pre>
<pre>	:endfor</pre>
<
<pre>						*buffer-variable* *b:var* *b:*</pre>
A variable name that is preceded with "b:" is local to the current buffer.
Thus you can have several "b:foo" variables, one for each buffer.
This kind of variable is deleted when the buffer is wiped out or deleted with
|:bdelete|.<p>

One local buffer variable is predefined:
<pre>					*b:changedtick* *changetick*</pre>
b:changedtick	The total number of changes to the current buffer.  It is
<pre>		incremented for each change.  An undo command is also a change</pre>
<pre>		in this case.  Resetting 'modified' when writing the buffer is</pre>
<pre>		also counted.</pre>
<pre>		This can be used to perform an action only when the buffer has</pre>
<pre>		changed.  Example: ></pre>
<pre>		    :if my_changedtick != b:changedtick</pre>
<pre>		    :	let my_changedtick = b:changedtick</pre>
<pre>		    :	call My_Update()</pre>
<pre>		    :endif</pre>
<		You cannot change or delete the b:changedtick variable.<p>

<pre>						*window-variable* *w:var* *w:*</pre>
A variable name that is preceded with "w:" is local to the current window.  It
is deleted when the window is closed.<p>

<pre>						*tabpage-variable* *t:var* *t:*</pre>
A variable name that is preceded with "t:" is local to the current tab page,
It is deleted when the tab page is closed. {not available when compiled
without the |+windows| feature}<p>

<pre>						*global-variable* *g:var* *g:*</pre>
Inside functions global variables are accessed with "g:".  Omitting this will
access a variable local to a function.  But "g:" can also be used in any other
place if you like.<p>

<pre>						*local-variable* *l:var* *l:*</pre>
Inside functions local variables are accessed without prepending anything.
But you can also prepend "l:" if you like.  However, without prepending "l:"
you may run into reserved variable names.  For example "count".  By itself it
refers to "v:count".  Using "l:count" you can have a local variable with the
same name.<p>

<pre>						*script-variable* *s:var*</pre>
In a Vim script variables starting with "s:" can be used.  They cannot be
accessed from outside of the scripts, thus are local to the script.<p>

They can be used in:
<pre>- commands executed while the script is sourced</pre>
<pre>- functions defined in the script</pre>
<pre>- autocommands defined in the script</pre>
<pre>- functions and autocommands defined in functions and autocommands which were</pre>
<pre>  defined in the script (recursively)</pre>
<pre>- user defined commands defined in the script</pre>
Thus not in:
<pre>- other scripts sourced from this one</pre>
<pre>- mappings</pre>
<pre>- menus</pre>
<pre>- etc.<p></pre>

Script variables can be used to avoid conflicts with global variable names.
Take this example: ><p>

<pre>	let s:counter = 0</pre>
<pre>	function MyCounter()</pre>
<pre>	  let s:counter = s:counter + 1</pre>
<pre>	  echo s:counter</pre>
<pre>	endfunction</pre>
<pre>	command Tick call MyCounter()<p></pre>

You can now invoke "Tick" from any script, and the "s:counter" variable in
that script will not be changed, only the "s:counter" in the script where
"Tick" was defined is used.<p>

Another example that does the same: ><p>

<pre>	let s:counter = 0</pre>
<pre>	command Tick let s:counter = s:counter + 1 | echo s:counter<p></pre>

When calling a function and invoking a user-defined command, the context for
script variables is set to the script where the function or command was
defined.<p>

The script variables are also available when a function is defined inside a
function that is defined in a script.  Example: ><p>

<pre>	let s:counter = 0</pre>
<pre>	function StartCounting(incr)</pre>
<pre>	  if a:incr</pre>
<pre>	    function MyCounter()</pre>
<pre>	      let s:counter = s:counter + 1</pre>
<pre>	    endfunction</pre>
<pre>	  else</pre>
<pre>	    function MyCounter()</pre>
<pre>	      let s:counter = s:counter - 1</pre>
<pre>	    endfunction</pre>
<pre>	  endif</pre>
<pre>	endfunction<p></pre>

This defines the MyCounter() function either for counting up or counting down
when calling StartCounting().  It doesn't matter from where StartCounting() is
called, the s:counter variable will be accessible in MyCounter().<p>

When the same script is sourced again it will use the same script variables.
They will remain valid as long as Vim is running.  This can be used to
maintain a counter: ><p>

<pre>	if !exists("s:counter")</pre>
<pre>	  let s:counter = 1</pre>
<pre>	  echo "script executed for the first time"</pre>
<pre>	else</pre>
<pre>	  let s:counter = s:counter + 1</pre>
<pre>	  echo "script executed " . s:counter . " times now"</pre>
<pre>	endif<p></pre>

Note that this means that filetype plugins don't get a different set of script
variables for each buffer.  Use local buffer variables instead |b:var|.<p>


PREDEFINED VIM VARIABLES			*vim-variable* *v:var* *v:*
<pre>								*E963*</pre>
Some variables can be set by the user, but the type cannot be changed.<p>

<pre>					*v:argv* *argv-variable*</pre>
v:argv		The command line arguments Vim was invoked with.  This is a
<pre>		list of strings.  The first item is the Vim command.<p></pre>

<pre>					*v:beval_col* *beval_col-variable*</pre>
v:beval_col	The number of the column, over which the mouse pointer is.
<pre>		This is the byte index in the |v:beval_lnum| line.</pre>
<pre>		Only valid while evaluating the 'balloonexpr' option.<p></pre>

<pre>					*v:beval_bufnr* *beval_bufnr-variable*</pre>
v:beval_bufnr	The number of the buffer, over which the mouse pointer is. Only
<pre>		valid while evaluating the 'balloonexpr' option.<p></pre>

<pre>					*v:beval_lnum* *beval_lnum-variable*</pre>
v:beval_lnum	The number of the line, over which the mouse pointer is. Only
<pre>		valid while evaluating the 'balloonexpr' option.<p></pre>

<pre>					*v:beval_text* *beval_text-variable*</pre>
v:beval_text	The text under or after the mouse pointer.  Usually a word as
<pre>		it is useful for debugging a C program.  'iskeyword' applies,</pre>
<pre>		but a dot and "->" before the position is included.  When on a</pre>
<pre>		']' the text before it is used, including the matching '[' and</pre>
<pre>		word before it.  When on a Visual area within one line the</pre>
<pre>		highlighted text is used.  Also see |<cexpr>|.</pre>
<pre>		Only valid while evaluating the 'balloonexpr' option.<p></pre>

<pre>					*v:beval_winnr* *beval_winnr-variable*</pre>
v:beval_winnr	The number of the window, over which the mouse pointer is. Only
<pre>		valid while evaluating the 'balloonexpr' option.  The first</pre>
<pre>		window has number zero (unlike most other places where a</pre>
<pre>		window gets a number).<p></pre>

<pre>					*v:beval_winid* *beval_winid-variable*</pre>
v:beval_winid	The |window-ID| of the window, over which the mouse pointer
<pre>		is.  Otherwise like v:beval_winnr.<p></pre>

<pre>					*v:char* *char-variable*</pre>
v:char		Argument for evaluating 'formatexpr' and used for the typed
<pre>		character when using <expr> in an abbreviation |:map-<expr>|.</pre>
<pre>		It is also used by the |InsertCharPre| and |InsertEnter| events.<p></pre>

<pre>			*v:charconvert_from* *charconvert_from-variable*</pre>
v:charconvert_from
<pre>		The name of the character encoding of a file to be converted.</pre>
<pre>		Only valid while evaluating the 'charconvert' option.<p></pre>

<pre>			*v:charconvert_to* *charconvert_to-variable*</pre>
v:charconvert_to
<pre>		The name of the character encoding of a file after conversion.</pre>
<pre>		Only valid while evaluating the 'charconvert' option.<p></pre>

<pre>					*v:cmdarg* *cmdarg-variable*</pre>
v:cmdarg	This variable is used for two purposes:
<pre>		1. The extra arguments given to a file read/write command.</pre>
<pre>		   Currently these are "++enc=" and "++ff=".  This variable is</pre>
<pre>		   set before an autocommand event for a file read/write</pre>
<pre>		   command is triggered.  There is a leading space to make it</pre>
<pre>		   possible to append this variable directly after the</pre>
<pre>		   read/write command.  Note: The "+cmd" argument isn't</pre>
<pre>		   included here, because it will be executed anyway.</pre>
<pre>		2. When printing a PostScript file with ":hardcopy" this is</pre>
<pre>		   the argument for the ":hardcopy" command.  This can be used</pre>
<pre>		   in 'printexpr'.<p></pre>

<pre>					*v:cmdbang* *cmdbang-variable*</pre>
v:cmdbang	Set like v:cmdarg for a file read/write command.  When a "!"
<pre>		was used the value is 1, otherwise it is 0.  Note that this</pre>
<pre>		can only be used in autocommands.  For user commands |<bang>|</pre>
<pre>		can be used.<p></pre>

<pre>				*v:completed_item* *completed_item-variable*</pre>
v:completed_item
<pre>		|Dictionary| containing the |complete-items| for the most</pre>
<pre>		recently completed word after |CompleteDone|.  The</pre>
<pre>		|Dictionary| is empty if the completion failed.<p></pre>

<pre>					*v:count* *count-variable*</pre>
v:count		The count given for the last Normal mode command.  Can be used
<pre>		to get the count before a mapping.  Read-only.  Example: ></pre>
<pre>	:map _x :<C-U>echo "the count is " . v:count<CR></pre>
<		Note: The <C-U> is required to remove the line range that you
<pre>		get when typing ':' after a count.</pre>
<pre>		When there are two counts, as in "3d2w", they are multiplied,</pre>
<pre>		just like what happens in the command, "d6w" for the example.</pre>
<pre>		Also used for evaluating the 'formatexpr' option.</pre>
<pre>		"count" also works, for backwards compatibility, unless</pre>
<pre>		|scriptversion| is 3 or higher.<p></pre>

<pre>					*v:count1* *count1-variable*</pre>
v:count1	Just like "v:count", but defaults to one when no count is
<pre>		used.<p></pre>

<pre>						*v:ctype* *ctype-variable*</pre>
v:ctype		The current locale setting for characters of the runtime
<pre>		environment.  This allows Vim scripts to be aware of the</pre>
<pre>		current locale encoding.  Technical: it's the value of</pre>
<pre>		LC_CTYPE.  When not using a locale the value is "C".</pre>
<pre>		This variable can not be set directly, use the |:language|</pre>
<pre>		command.</pre>
<pre>		See |multi-lang|.<p></pre>

<pre>					*v:dying* *dying-variable*</pre>
v:dying		Normally zero.  When a deadly signal is caught it's set to
<pre>		one.  When multiple signals are caught the number increases.</pre>
<pre>		Can be used in an autocommand to check if Vim didn't</pre>
<pre>		terminate normally. {only works on Unix}</pre>
<pre>		Example: ></pre>
<pre>	:au VimLeave * if v:dying | echo "\nAAAAaaaarrrggghhhh!!!\n" | endif</pre>
<		Note: if another deadly signal is caught when v:dying is one,
<pre>		VimLeave autocommands will not be executed.<p></pre>

<pre>					*v:echospace* *echospace-variable*</pre>
v:echospace	Number of screen cells that can be used for an `:echo` message
<pre>		in the last screen line before causing the |hit-enter-prompt|.</pre>
<pre>		Depends on 'showcmd', 'ruler' and 'columns'.  You need to</pre>
<pre>		check 'cmdheight' for whether there are full-width lines</pre>
<pre>		available above the last line.<p></pre>

<pre>					*v:errmsg* *errmsg-variable*</pre>
v:errmsg	Last given error message.  It's allowed to set this variable.
<pre>		Example: ></pre>
<pre>	:let v:errmsg = ""</pre>
<pre>	:silent! next</pre>
<pre>	:if v:errmsg != ""</pre>
<pre>	:  ... handle error</pre>
<		"errmsg" also works, for backwards compatibility, unless
<pre>		|scriptversion| is 3 or higher.<p></pre>

<pre>				*v:errors* *errors-variable* *assert-return*</pre>
v:errors	Errors found by assert functions, such as |assert_true()|.
<pre>		This is a list of strings.</pre>
<pre>		The assert functions append an item when an assert fails.</pre>
<pre>		The return value indicates this: a one is returned if an item</pre>
<pre>		was added to v:errors, otherwise zero is returned.</pre>
<pre>		To remove old results make it empty: ></pre>
<pre>	:let v:errors = []</pre>
<		If v:errors is set to anything but a list it is made an empty
<pre>		list by the assert function.<p></pre>

<pre>					*v:event* *event-variable*</pre>
v:event		Dictionary containing information about the current
<pre>		|autocommand|.  The dictionary is emptied when the |autocommand|</pre>
<pre>		finishes, please refer to |dict-identity| for how to get an</pre>
<pre>		independent copy of it.<p></pre>

<pre>					*v:exception* *exception-variable*</pre>
v:exception	The value of the exception most recently caught and not
<pre>		finished.  See also |v:throwpoint| and |throw-variables|.</pre>
<pre>		Example: ></pre>
<pre>	:try</pre>
<pre>	:  throw "oops"</pre>
<pre>	:catch /.*/</pre>
<pre>	:  echo "caught " .. v:exception</pre>
<pre>	:endtry</pre>
<		Output: "caught oops".<p>

<pre>					*v:false* *false-variable*</pre>
v:false		A Number with value zero. Used to put "false" in JSON.  See
<pre>		|json_encode()|.</pre>
<pre>		When used as a string this evaluates to "v:false". ></pre>
<pre>			echo v:false</pre>
<			v:false ~
<pre>		That is so that eval() can parse the string back to the same</pre>
<pre>		value.  Read-only.<p></pre>

<pre>					*v:fcs_reason* *fcs_reason-variable*</pre>
v:fcs_reason	The reason why the |FileChangedShell| event was triggered.
<pre>		Can be used in an autocommand to decide what to do and/or what</pre>
<pre>		to set v:fcs_choice to.  Possible values:</pre>
<pre>			deleted		file no longer exists</pre>
<pre>			conflict	file contents, mode or timestamp was</pre>
<pre>					changed and buffer is modified</pre>
<pre>			changed		file contents has changed</pre>
<pre>			mode		mode of file changed</pre>
<pre>			time		only file timestamp changed<p></pre>

<pre>					*v:fcs_choice* *fcs_choice-variable*</pre>
v:fcs_choice	What should happen after a |FileChangedShell| event was
<pre>		triggered.  Can be used in an autocommand to tell Vim what to</pre>
<pre>		do with the affected buffer:</pre>
<pre>			reload		Reload the buffer (does not work if</pre>
<pre>					the file was deleted).</pre>
<pre>			ask		Ask the user what to do, as if there</pre>
<pre>					was no autocommand.  Except that when</pre>
<pre>					only the timestamp changed nothing</pre>
<pre>					will happen.</pre>
<pre>			<empty>		Nothing, the autocommand should do</pre>
<pre>					everything that needs to be done.</pre>
<pre>		The default is empty.  If another (invalid) value is used then</pre>
<pre>		Vim behaves like it is empty, there is no warning message.<p></pre>

<pre>					*v:fname_in* *fname_in-variable*</pre>
v:fname_in	The name of the input file.  Valid while evaluating:
<pre>			option		used for ~</pre>
<pre>			'charconvert'	file to be converted</pre>
<pre>			'diffexpr'	original file</pre>
<pre>			'patchexpr'	original file</pre>
<pre>			'printexpr'	file to be printed</pre>
<pre>		And set to the swap file name for |SwapExists|.<p></pre>

<pre>					*v:fname_out* *fname_out-variable*</pre>
v:fname_out	The name of the output file.  Only valid while
<pre>		evaluating:</pre>
<pre>			option		used for ~</pre>
<pre>			'charconvert'	resulting converted file (*)</pre>
<pre>			'diffexpr'	output of diff</pre>
<pre>			'patchexpr'	resulting patched file</pre>
<pre>		(*) When doing conversion for a write command (e.g., ":w</pre>
<pre>		file") it will be equal to v:fname_in.  When doing conversion</pre>
<pre>		for a read command (e.g., ":e file") it will be a temporary</pre>
<pre>		file and different from v:fname_in.<p></pre>

<pre>					*v:fname_new* *fname_new-variable*</pre>
v:fname_new	The name of the new version of the file.  Only valid while
<pre>		evaluating 'diffexpr'.<p></pre>

<pre>					*v:fname_diff* *fname_diff-variable*</pre>
v:fname_diff	The name of the diff (patch) file.  Only valid while
<pre>		evaluating 'patchexpr'.<p></pre>

<pre>					*v:folddashes* *folddashes-variable*</pre>
v:folddashes	Used for 'foldtext': dashes representing foldlevel of a closed
<pre>		fold.</pre>
<pre>		Read-only in the |sandbox|. |fold-foldtext|<p></pre>

<pre>					*v:foldlevel* *foldlevel-variable*</pre>
v:foldlevel	Used for 'foldtext': foldlevel of closed fold.
<pre>		Read-only in the |sandbox|. |fold-foldtext|<p></pre>

<pre>					*v:foldend* *foldend-variable*</pre>
v:foldend	Used for 'foldtext': last line of closed fold.
<pre>		Read-only in the |sandbox|. |fold-foldtext|<p></pre>

<pre>					*v:foldstart* *foldstart-variable*</pre>
v:foldstart	Used for 'foldtext': first line of closed fold.
<pre>		Read-only in the |sandbox|. |fold-foldtext|<p></pre>

<pre>					*v:hlsearch* *hlsearch-variable*</pre>
v:hlsearch	Variable that indicates whether search highlighting is on.
<pre>		Setting it makes sense only if 'hlsearch' is enabled which</pre>
<pre>		requires |+extra_search|. Setting this variable to zero acts</pre>
<pre>		like the |:nohlsearch| command, setting it to one acts like ></pre>
<pre>			let &hlsearch = &hlsearch</pre>
<		Note that the value is restored when returning from a
<pre>		function. |function-search-undo|.<p></pre>

<pre>					*v:insertmode* *insertmode-variable*</pre>
v:insertmode	Used for the |InsertEnter| and |InsertChange| autocommand
<pre>		events.  Values:</pre>
<pre>			i	Insert mode</pre>
<pre>			r	Replace mode</pre>
<pre>			v	Virtual Replace mode<p></pre>

<pre>						*v:key* *key-variable*</pre>
v:key		Key of the current item of a |Dictionary|.  Only valid while
<pre>		evaluating the expression used with |map()| and |filter()|.</pre>
<pre>		Read-only.<p></pre>

<pre>						*v:lang* *lang-variable*</pre>
v:lang		The current locale setting for messages of the runtime
<pre>		environment.  This allows Vim scripts to be aware of the</pre>
<pre>		current language.  Technical: it's the value of LC_MESSAGES.</pre>
<pre>		The value is system dependent.</pre>
<pre>		This variable can not be set directly, use the |:language|</pre>
<pre>		command.</pre>
<pre>		It can be different from |v:ctype| when messages are desired</pre>
<pre>		in a different language than what is used for character</pre>
<pre>		encoding.  See |multi-lang|.<p></pre>

<pre>						*v:lc_time* *lc_time-variable*</pre>
v:lc_time	The current locale setting for time messages of the runtime
<pre>		environment.  This allows Vim scripts to be aware of the</pre>
<pre>		current language.  Technical: it's the value of LC_TIME.</pre>
<pre>		This variable can not be set directly, use the |:language|</pre>
<pre>		command.  See |multi-lang|.<p></pre>

<pre>						*v:lnum* *lnum-variable*</pre>
v:lnum		Line number for the 'foldexpr' |fold-expr|, 'formatexpr' and
<pre>		'indentexpr' expressions, tab page number for 'guitablabel'</pre>
<pre>		and 'guitabtooltip'.  Only valid while one of these</pre>
<pre>		expressions is being evaluated.  Read-only when in the</pre>
<pre>		|sandbox|.<p></pre>

<pre>					*v:mouse_win* *mouse_win-variable*</pre>
v:mouse_win	Window number for a mouse click obtained with |getchar()|.
<pre>		First window has number 1, like with |winnr()|.  The value is</pre>
<pre>		zero when there was no mouse button click.<p></pre>

<pre>					*v:mouse_winid* *mouse_winid-variable*</pre>
v:mouse_winid	Window ID for a mouse click obtained with |getchar()|.
<pre>		The value is zero when there was no mouse button click.<p></pre>

<pre>					*v:mouse_lnum* *mouse_lnum-variable*</pre>
v:mouse_lnum	Line number for a mouse click obtained with |getchar()|.
<pre>		This is the text line number, not the screen line number.  The</pre>
<pre>		value is zero when there was no mouse button click.<p></pre>

<pre>					*v:mouse_col* *mouse_col-variable*</pre>
v:mouse_col	Column number for a mouse click obtained with |getchar()|.
<pre>		This is the screen column number, like with |virtcol()|.  The</pre>
<pre>		value is zero when there was no mouse button click.<p></pre>

<pre>					*v:none* *none-variable* *None*</pre>
v:none		An empty String. Used to put an empty item in JSON.  See
<pre>		|json_encode()|.</pre>
<pre>		When used as a number this evaluates to zero.</pre>
<pre>		When used as a string this evaluates to "v:none". ></pre>
<pre>			echo v:none</pre>
<			v:none ~
<pre>		That is so that eval() can parse the string back to the same</pre>
<pre>		value.  Read-only.<p></pre>

<pre>					*v:null* *null-variable*</pre>
v:null		An empty String. Used to put "null" in JSON.  See
<pre>		|json_encode()|.</pre>
<pre>		When used as a number this evaluates to zero.</pre>
<pre>		When used as a string this evaluates to "v:null". ></pre>
<pre>			echo v:null</pre>
<			v:null ~
<pre>		That is so that eval() can parse the string back to the same</pre>
<pre>		value.  Read-only.<p></pre>

<pre>					*v:oldfiles* *oldfiles-variable*</pre>
v:oldfiles	List of file names that is loaded from the |viminfo| file on
<pre>		startup.  These are the files that Vim remembers marks for.</pre>
<pre>		The length of the List is limited by the ' argument of the</pre>
<pre>		'viminfo' option (default is 100).</pre>
<pre>		When the |viminfo| file is not used the List is empty.</pre>
<pre>		Also see |:oldfiles| and |c_#<|.</pre>
<pre>		The List can be modified, but this has no effect on what is</pre>
<pre>		stored in the |viminfo| file later.  If you use values other</pre>
<pre>		than String this will cause trouble.</pre>
<pre>		{only when compiled with the |+viminfo| feature}<p></pre>

<pre>						    *v:option_new*</pre>
v:option_new    New value of the option. Valid while executing an |OptionSet|
<pre>		autocommand.</pre>
<pre>						    *v:option_old*</pre>
v:option_old    Old value of the option. Valid while executing an |OptionSet|
<pre>		autocommand. Depending on the command used for setting and the</pre>
<pre>		kind of option this is either the local old value or the</pre>
<pre>		global old value.</pre>
<pre>						    *v:option_oldlocal*</pre>
v:option_oldlocal
<pre>		Old local value of the option. Valid while executing an</pre>
<pre>		|OptionSet| autocommand.</pre>
<pre>						    *v:option_oldglobal*</pre>
v:option_oldglobal
<pre>		Old global value of the option. Valid while executing an</pre>
<pre>		|OptionSet| autocommand.</pre>
<pre>						    *v:option_type*</pre>
v:option_type   Scope of the set command. Valid while executing an
<pre>		|OptionSet| autocommand. Can be either "global" or "local"</pre>
<pre>						    *v:option_command*</pre>
v:option_command
<pre>		Command used to set the option. Valid while executing an</pre>
<pre>		|OptionSet| autocommand.</pre>
<pre>			value		option was set via   ~</pre>
<pre>			"setlocal"	|:setlocal| or ":let l:xxx"</pre>
<pre>			"setglobal"	|:setglobal| or ":let g:xxx"</pre>
<pre>			"set"		|:set| or |:let|</pre>
<pre>			"modeline"	|modeline|</pre>
<pre>					*v:operator* *operator-variable*</pre>
v:operator	The last operator given in Normal mode.  This is a single
<pre>		character except for commands starting with <g> or <z>,</pre>
<pre>		in which case it is two characters.  Best used alongside</pre>
<pre>		|v:prevcount| and |v:register|.  Useful if you want to cancel</pre>
<pre>		Operator-pending mode and then use the operator, e.g.: ></pre>
<pre>			:omap O <Esc>:call MyMotion(v:operator)<CR></pre>
<		The value remains set until another operator is entered, thus
<pre>		don't expect it to be empty.</pre>
<pre>		v:operator is not set for |:delete|, |:yank| or other Ex</pre>
<pre>		commands.</pre>
<pre>		Read-only.<p></pre>

<pre>					*v:prevcount* *prevcount-variable*</pre>
v:prevcount	The count given for the last but one Normal mode command.
<pre>		This is the v:count value of the previous command.  Useful if</pre>
<pre>		you want to cancel Visual or Operator-pending mode and then</pre>
<pre>		use the count, e.g.: ></pre>
<pre>			:vmap % <Esc>:call MyFilter(v:prevcount)<CR></pre>
<		Read-only.<p>

<pre>					*v:profiling* *profiling-variable*</pre>
v:profiling	Normally zero.  Set to one after using ":profile start".
<pre>		See |profiling|.<p></pre>

<pre>					*v:progname* *progname-variable*</pre>
v:progname	Contains the name (with path removed) with which Vim was
<pre>		invoked.  Allows you to do special initialisations for |view|,</pre>
<pre>		|evim| etc., or any other name you might symlink to Vim.</pre>
<pre>		Read-only.<p></pre>

<pre>					*v:progpath* *progpath-variable*</pre>
v:progpath	Contains the command with which Vim was invoked, in a form
<pre>		that when passed to the shell will run the same Vim executable</pre>
<pre>		as the current one (if $PATH remains unchanged).</pre>
<pre>		Useful if you want to message a Vim server using a</pre>
<pre>		|--remote-expr|.</pre>
<pre>		To get the full path use: ></pre>
<pre>			echo exepath(v:progpath)</pre>
<		If the command has a relative path it will be expanded to the
<pre>		full path, so that it still works after `:cd`. Thus starting</pre>
<pre>		"./vim" results in "/home/user/path/to/vim/src/vim".</pre>
<pre>		On Linux and other systems it will always be the full path.</pre>
<pre>		On Mac it may just be "vim" and using exepath() as mentioned</pre>
<pre>		above should be used to get the full path.</pre>
<pre>		On MS-Windows the executable may be called "vim.exe", but the</pre>
<pre>		".exe" is not added to v:progpath.</pre>
<pre>		Read-only.<p></pre>

<pre>					*v:register* *register-variable*</pre>
v:register	The name of the register in effect for the current normal mode
<pre>		command (regardless of whether that command actually used a</pre>
<pre>		register).  Or for the currently executing normal mode mapping</pre>
<pre>		(use this in custom commands that take a register).</pre>
<pre>		If none is supplied it is the default register '"', unless</pre>
<pre>		'clipboard' contains "unnamed" or "unnamedplus", then it is</pre>
<pre>		'*' or '+'.</pre>
<pre>		Also see |getreg()| and |setreg()|<p></pre>

<pre>					*v:scrollstart* *scrollstart-variable*</pre>
v:scrollstart	String describing the script or function that caused the
<pre>		screen to scroll up.  It's only set when it is empty, thus the</pre>
<pre>		first reason is remembered.  It is set to "Unknown" for a</pre>
<pre>		typed command.</pre>
<pre>		This can be used to find out why your script causes the</pre>
<pre>		hit-enter prompt.<p></pre>

<pre>					*v:servername* *servername-variable*</pre>
v:servername	The resulting registered |client-server-name| if any.
<pre>		Read-only.<p></pre>


v:searchforward			*v:searchforward* *searchforward-variable*
<pre>		Search direction:  1 after a forward search, 0 after a</pre>
<pre>		backward search.  It is reset to forward when directly setting</pre>
<pre>		the last search pattern, see |quote/|.</pre>
<pre>		Note that the value is restored when returning from a</pre>
<pre>		function. |function-search-undo|.</pre>
<pre>		Read-write.<p></pre>

<pre>					*v:shell_error* *shell_error-variable*</pre>
v:shell_error	Result of the last shell command.  When non-zero, the last
<pre>		shell command had an error.  When zero, there was no problem.</pre>
<pre>		This only works when the shell returns the error code to Vim.</pre>
<pre>		The value -1 is often used when the command could not be</pre>
<pre>		executed.  Read-only.</pre>
<pre>		Example: ></pre>
<pre>	:!mv foo bar</pre>
<pre>	:if v:shell_error</pre>
<pre>	:  echo 'could not rename "foo" to "bar"!'</pre>
<pre>	:endif</pre>
<		"shell_error" also works, for backwards compatibility, unless
<pre>		|scriptversion| is 3 or higher.<p></pre>

<pre>					*v:statusmsg* *statusmsg-variable*</pre>
v:statusmsg	Last given status message.  It's allowed to set this variable.<p>

<pre>					*v:swapname* *swapname-variable*</pre>
v:swapname	Only valid when executing |SwapExists| autocommands: Name of
<pre>		the swap file found.  Read-only.<p></pre>

<pre>					*v:swapchoice* *swapchoice-variable*</pre>
v:swapchoice	|SwapExists| autocommands can set this to the selected choice
<pre>		for handling an existing swap file:</pre>
<pre>			'o'	Open read-only</pre>
<pre>			'e'	Edit anyway</pre>
<pre>			'r'	Recover</pre>
<pre>			'd'	Delete swapfile</pre>
<pre>			'q'	Quit</pre>
<pre>			'a'	Abort</pre>
<pre>		The value should be a single-character string.  An empty value</pre>
<pre>		results in the user being asked, as would happen when there is</pre>
<pre>		no SwapExists autocommand.  The default is empty.<p></pre>

<pre>					*v:swapcommand* *swapcommand-variable*</pre>
v:swapcommand	Normal mode command to be executed after a file has been
<pre>		opened.  Can be used for a |SwapExists| autocommand to have</pre>
<pre>		another Vim open the file and jump to the right place.  For</pre>
<pre>		example, when jumping to a tag the value is ":tag tagname\r".</pre>
<pre>		For ":edit +cmd file" the value is ":cmd\r".<p></pre>

<pre>				*v:t_TYPE* *v:t_bool* *t_bool-variable*</pre>
v:t_bool	Value of |Boolean| type.  Read-only.  See: |type()|
<pre>					*v:t_channel* *t_channel-variable*</pre>
v:t_channel	Value of |Channel| type.  Read-only.  See: |type()|
<pre>					*v:t_dict* *t_dict-variable*</pre>
v:t_dict	Value of |Dictionary| type.  Read-only.  See: |type()|
<pre>					*v:t_float* *t_float-variable*</pre>
v:t_float	Value of |Float| type.  Read-only.  See: |type()|
<pre>					*v:t_func* *t_func-variable*</pre>
v:t_func	Value of |Funcref| type.  Read-only.  See: |type()|
<pre>					*v:t_job* *t_job-variable*</pre>
v:t_job		Value of |Job| type.  Read-only.  See: |type()|
<pre>					*v:t_list* *t_list-variable*</pre>
v:t_list	Value of |List| type.  Read-only.  See: |type()|
<pre>					*v:t_none* *t_none-variable*</pre>
v:t_none	Value of |None| type.  Read-only.  See: |type()|
<pre>					*v:t_number* *t_number-variable*</pre>
v:t_number	Value of |Number| type.  Read-only.  See: |type()|
<pre>					*v:t_string* *t_string-variable*</pre>
v:t_string	Value of |String| type.  Read-only.  See: |type()|
<pre>					*v:t_blob* *t_blob-variable*</pre>
v:t_blob	Value of |Blob| type.  Read-only.  See: |type()|<p>

<pre>				*v:termresponse* *termresponse-variable*</pre>
v:termresponse	The escape sequence returned by the terminal for the |t_RV|
<pre>		termcap entry.  It is set when Vim receives an escape sequence</pre>
<pre>		that starts with ESC [ or CSI, then '>' or '?' and ends in a</pre>
<pre>		'c', with only digits and ';' in between.</pre>
<pre>		When this option is set, the TermResponse autocommand event is</pre>
<pre>		fired, so that you can react to the response from the</pre>
<pre>		terminal.</pre>
<pre>		The response from a new xterm is: "<Esc>[> Pp ; Pv ; Pc c".  Pp</pre>
<pre>		is the terminal type: 0 for vt100 and 1 for vt220.  Pv is the</pre>
<pre>		patch level (since this was introduced in patch 95, it's</pre>
<pre>		always 95 or bigger).  Pc is always zero.</pre>
<pre>		{only when compiled with |+termresponse| feature}<p></pre>

<pre>						*v:termblinkresp*</pre>
v:termblinkresp	The escape sequence returned by the terminal for the |t_RC|
<pre>		termcap entry.  This is used to find out whether the terminal</pre>
<pre>		cursor is blinking. This is used by |term_getcursor()|.<p></pre>

<pre>						*v:termstyleresp*</pre>
v:termstyleresp	The escape sequence returned by the terminal for the |t_RS|
<pre>		termcap entry.  This is used to find out what the shape of the</pre>
<pre>		cursor is.  This is used by |term_getcursor()|.<p></pre>

<pre>						*v:termrbgresp*</pre>
v:termrbgresp	The escape sequence returned by the terminal for the |t_RB|
<pre>		termcap entry.  This is used to find out what the terminal</pre>
<pre>		background color is, see 'background'.<p></pre>

<pre>						*v:termrfgresp*</pre>
v:termrfgresp	The escape sequence returned by the terminal for the |t_RF|
<pre>		termcap entry.  This is used to find out what the terminal</pre>
<pre>		foreground color is.<p></pre>

<pre>						*v:termu7resp*</pre>
v:termu7resp	The escape sequence returned by the terminal for the |t_u7|
<pre>		termcap entry.  This is used to find out what the terminal</pre>
<pre>		does with ambiguous width characters, see 'ambiwidth'.<p></pre>

<pre>					*v:testing* *testing-variable*</pre>
v:testing	Must be set before using `test_garbagecollect_now()`.
<pre>		Also, when set certain error messages won't be shown for 2</pre>
<pre>		seconds. (e.g. "'dictionary' option is empty")<p></pre>

<pre>				*v:this_session* *this_session-variable*</pre>
v:this_session	Full filename of the last loaded or saved session file.  See
<pre>		|:mksession|.  It is allowed to set this variable.  When no</pre>
<pre>		session file has been saved, this variable is empty.</pre>
<pre>		"this_session" also works, for backwards compatibility, unless</pre>
<pre>		|scriptversion| is 3 or higher<p></pre>

<pre>					*v:throwpoint* *throwpoint-variable*</pre>
v:throwpoint	The point where the exception most recently caught and not
<pre>		finished was thrown.  Not set when commands are typed.  See</pre>
<pre>		also |v:exception| and |throw-variables|.</pre>
<pre>		Example: ></pre>
<pre>	:try</pre>
<pre>	:  throw "oops"</pre>
<pre>	:catch /.*/</pre>
<pre>	:  echo "Exception from" v:throwpoint</pre>
<pre>	:endtry</pre>
<		Output: "Exception from test.vim, line 2"<p>

<pre>						*v:true* *true-variable*</pre>
v:true		A Number with value one. Used to put "true" in JSON.  See
<pre>		|json_encode()|.</pre>
<pre>		When used as a string this evaluates to "v:true". ></pre>
<pre>			echo v:true</pre>
<			v:true ~
<pre>		That is so that eval() can parse the string back to the same</pre>
<pre>		value.  Read-only.</pre>
<pre>						*v:val* *val-variable*</pre>
v:val		Value of the current item of a |List| or |Dictionary|.  Only
<pre>		valid while evaluating the expression used with |map()| and</pre>
<pre>		|filter()|.  Read-only.<p></pre>

<pre>					*v:version* *version-variable*</pre>
v:version	Version number of Vim: Major version number times 100 plus
<pre>		minor version number.  Version 5.0 is 500.  Version 5.1</pre>
<pre>		is 501.  Read-only.  "version" also works, for backwards</pre>
<pre>		compatibility, unless |scriptversion| is 3 or higher.</pre>
<pre>		Use |has()| to check if a certain patch was included, e.g.: ></pre>
<pre>			if has("patch-7.4.123")</pre>
<		Note that patch numbers are specific to the version, thus both
<pre>		version 5.0 and 5.1 may have a patch 123, but these are</pre>
<pre>		completely different.<p></pre>

<pre>					*v:versionlong* *versionlong-variable*</pre>
v:versionlong	Like v:version, but also including the patchlevel in the last
<pre>		four digits.  Version 8.1 with patch 123 has value 8010123.</pre>
<pre>		This can be used like this: ></pre>
<pre>			if v:versionlong >= 8010123</pre>
<		However, if there are gaps in the list of patches included
<pre>		this will not work well.  This can happen if a recent patch</pre>
<pre>		was included into an older version, e.g. for a security fix.</pre>
<pre>		Use the has() function to make sure the patch is actually</pre>
<pre>		included.<p></pre>

<pre>				*v:vim_did_enter* *vim_did_enter-variable*</pre>
v:vim_did_enter	Zero until most of startup is done.  It is set to one just
<pre>		before |VimEnter| autocommands are triggered.<p></pre>

<pre>					*v:warningmsg* *warningmsg-variable*</pre>
v:warningmsg	Last given warning message.  It's allowed to set this variable.<p>

<pre>					*v:windowid* *windowid-variable*</pre>
v:windowid	When any X11 based GUI is running or when running in a
<pre>		terminal and Vim connects to the X server (|-X|) this will be</pre>
<pre>		set to the window ID.</pre>
<pre>		When an MS-Windows GUI is running this will be set to the</pre>
<pre>		window handle.</pre>
<pre>		Otherwise the value is zero.</pre>
<pre>		Note: for windows inside Vim use |winnr()| or |win_getid()|,</pre>
<pre>		see |window-ID|.<p></pre>

* Builtin Functions					*functions*<p>

See |function-list| for a list grouped by what the function is used for.<p>

(Use CTRL-] on the function name to jump to the full explanation.)<p>

USAGE				RESULT	DESCRIPTION	~<p>

abs({expr})			Float or Number  absolute value of {expr}
acos({expr})			Float	arc cosine of {expr}
add({object}, {item})		List/Blob   append {item} to {object}
and({expr}, {expr})		Number	bitwise AND
append({lnum}, {text})		Number	append {text} below line {lnum}
appendbufline({expr}, {lnum}, {text})
<pre>				Number	append {text} below line {lnum}</pre>
<pre>					in buffer {expr}</pre>
argc([{winid}])			Number	number of files in the argument list
argidx()			Number	current index in the argument list
arglistid([{winnr} [, {tabnr}]]) Number	argument list id
argv({nr} [, {winid}])		String	{nr} entry of the argument list
argv([-1, {winid}])		List	the argument list
assert_beeps({cmd})		Number	assert {cmd} causes a beep
assert_equal({exp}, {act} [, {msg}])
<pre>				Number	assert {exp} is equal to {act}</pre>
assert_equalfile({fname-one}, {fname-two})
<pre>				Number	assert file contents is equal</pre>
assert_exception({error} [, {msg}])
<pre>				Number	assert {error} is in v:exception</pre>
assert_fails({cmd} [, {error} [, {msg}]])
<pre>				Number	assert {cmd} fails</pre>
assert_false({actual} [, {msg}])
<pre>				Number	assert {actual} is false</pre>
assert_inrange({lower}, {upper}, {actual} [, {msg}])
<pre>				Number	assert {actual} is inside the range</pre>
assert_match({pat}, {text} [, {msg}])
<pre>				Number	assert {pat} matches {text}</pre>
assert_notequal({exp}, {act} [, {msg}])
<pre>				Number	assert {exp} is not equal {act}</pre>
assert_notmatch({pat}, {text} [, {msg}])
<pre>				Number	assert {pat} not matches {text}</pre>
assert_report({msg})		Number	report a test failure
assert_true({actual} [, {msg}])	Number	assert {actual} is true
asin({expr})			Float	arc sine of {expr}
atan({expr})			Float	arc tangent of {expr}
atan2({expr1}, {expr2})		Float	arc tangent of {expr1} / {expr2}
balloon_gettext()		String	current text in the balloon
balloon_show({expr})		none	show {expr} inside the balloon
balloon_split({msg})		List	split {msg} as used for a balloon
browse({save}, {title}, {initdir}, {default})
<pre>				String	put up a file requester</pre>
browsedir({title}, {initdir})	String	put up a directory requester
bufadd({name})			Number	add a buffer to the buffer list
bufexists({expr})		Number	|TRUE| if buffer {expr} exists
buflisted({expr})		Number	|TRUE| if buffer {expr} is listed
bufload({expr})			Number	load buffer {expr} if not loaded yet
bufloaded({expr})		Number	|TRUE| if buffer {expr} is loaded
bufname([{expr}])		String	Name of the buffer {expr}
bufnr([{expr} [, {create}]])	Number	Number of the buffer {expr}
bufwinid({expr})		Number	window ID of buffer {expr}
bufwinnr({expr})		Number	window number of buffer {expr}
byte2line({byte})		Number	line number at byte count {byte}
byteidx({expr}, {nr})		Number	byte index of {nr}'th char in {expr}
byteidxcomp({expr}, {nr})	Number	byte index of {nr}'th char in {expr}
call({func}, {arglist} [, {dict}])
<pre>				any	call {func} with arguments {arglist}</pre>
ceil({expr})			Float	round {expr} up
ch_canread({handle})		Number	check if there is something to read
ch_close({handle})		none	close {handle}
ch_close_in({handle})		none	close in part of {handle}
ch_evalexpr({handle}, {expr} [, {options}])
<pre>				any	evaluate {expr} on JSON {handle}</pre>
ch_evalraw({handle}, {string} [, {options}])
<pre>				any	evaluate {string} on raw {handle}</pre>
ch_getbufnr({handle}, {what})	Number	get buffer number for {handle}/{what}
ch_getjob({channel})		Job	get the Job of {channel}
ch_info({handle})		String	info about channel {handle}
ch_log({msg} [, {handle}])	none	write {msg} in the channel log file
ch_logfile({fname} [, {mode}])	none	start logging channel activity
ch_open({address} [, {options}])
<pre>				Channel	open a channel to {address}</pre>
ch_read({handle} [, {options}]) String	read from {handle}
ch_readblob({handle} [, {options}])
<pre>				Blob	read Blob from {handle}</pre>
ch_readraw({handle} [, {options}])
<pre>				String	read raw from {handle}</pre>
ch_sendexpr({handle}, {expr} [, {options}])
<pre>				any	send {expr} over JSON {handle}</pre>
ch_sendraw({handle}, {expr} [, {options}])
<pre>				any	send {expr} over raw {handle}</pre>
ch_setoptions({handle}, {options})
<pre>				none	set options for {handle}</pre>
ch_status({handle} [, {options}])
<pre>				String	status of channel {handle}</pre>
changenr()			Number	current change number
char2nr({expr} [, {utf8}])	Number	ASCII/UTF8 value of first char in {expr}
chdir({dir})			String	change current working directory
cindent({lnum})			Number	C indent for line {lnum}
clearmatches([{win}])		none	clear all matches
col({expr})			Number	column nr of cursor or mark
complete({startcol}, {matches}) none	set Insert mode completion
complete_add({expr})		Number	add completion match
complete_check()		Number	check for key typed during completion
complete_info([{what}])		Dict	get current completion information
confirm({msg} [, {choices} [, {default} [, {type}]]])
<pre>				Number	number of choice picked by user</pre>
copy({expr})			any	make a shallow copy of {expr}
cos({expr})			Float	cosine of {expr}
cosh({expr})			Float	hyperbolic cosine of {expr}
count({comp}, {expr} [, {ic} [, {start}]])
<pre>				Number	count how many {expr} are in {comp}</pre>
cscope_connection([{num}, {dbpath} [, {prepend}]])
<pre>				Number	checks existence of cscope connection</pre>
cursor({lnum}, {col} [, {off}])
<pre>				Number	move cursor to {lnum}, {col}, {off}</pre>
cursor({list})			Number	move cursor to position in {list}
debugbreak({pid})		Number  interrupt process being debugged
deepcopy({expr} [, {noref}])	any	make a full copy of {expr}
delete({fname} [, {flags}])	Number	delete the file or directory {fname}
deletebufline({expr}, {first} [, {last}])
<pre>				Number	delete lines from buffer {expr}</pre>
did_filetype()			Number	|TRUE| if FileType autocmd event used
diff_filler({lnum})		Number	diff filler lines about {lnum}
diff_hlID({lnum}, {col})	Number	diff highlighting at {lnum}/{col}
empty({expr})			Number	|TRUE| if {expr} is empty
environ()			Dict	return environment variables
escape({string}, {chars})	String	escape {chars} in {string} with '\'
eval({string})			any	evaluate {string} into its value
eventhandler()			Number	|TRUE| if inside an event handler
executable({expr})		Number	1 if executable {expr} exists
execute({command})		String	execute {command} and get the output
exepath({expr})			String	full path of the command {expr}
exists({expr})			Number	|TRUE| if {expr} exists
extend({expr1}, {expr2} [, {expr3}])
<pre>				List/Dict insert items of {expr2} into {expr1}</pre>
exp({expr})			Float	exponential of {expr}
expand({expr} [, {nosuf} [, {list}]])
<pre>				any	expand special keywords in {expr}</pre>
expandcmd({expr})		String	expand {expr} like with `:edit`
feedkeys({string} [, {mode}])	Number	add key sequence to typeahead buffer
filereadable({file})		Number	|TRUE| if {file} is a readable file
filewritable({file})		Number	|TRUE| if {file} is a writable file
filter({expr1}, {expr2})	List/Dict  remove items from {expr1} where
<pre>					{expr2} is 0</pre>
finddir({name} [, {path} [, {count}]])
<pre>				String	find directory {name} in {path}</pre>
findfile({name} [, {path} [, {count}]])
<pre>				String	find file {name} in {path}</pre>
float2nr({expr})		Number	convert Float {expr} to a Number
floor({expr})			Float	round {expr} down
fmod({expr1}, {expr2})		Float	remainder of {expr1} / {expr2}
fnameescape({fname})		String	escape special characters in {fname}
fnamemodify({fname}, {mods})	String	modify file name
foldclosed({lnum})		Number	first line of fold at {lnum} if closed
foldclosedend({lnum})		Number	last line of fold at {lnum} if closed
foldlevel({lnum})		Number	fold level at {lnum}
foldtext()			String	line displayed for closed fold
foldtextresult({lnum})		String	text for closed fold at {lnum}
foreground()			Number	bring the Vim window to the foreground
funcref({name} [, {arglist}] [, {dict}])
<pre>				Funcref	reference to function {name}</pre>
function({name} [, {arglist}] [, {dict}])
<pre>				Funcref	named reference to function {name}</pre>
garbagecollect([{atexit}])	none	free memory, breaking cyclic references
get({list}, {idx} [, {def}])	any	get item {idx} from {list} or {def}
get({dict}, {key} [, {def}])	any	get item {key} from {dict} or {def}
get({func}, {what})		any	get property of funcref/partial {func}
getbufinfo([{expr}])		List	information about buffers
getbufline({expr}, {lnum} [, {end}])
<pre>				List	lines {lnum} to {end} of buffer {expr}</pre>
getbufvar({expr}, {varname} [, {def}])
<pre>				any	variable {varname} in buffer {expr}</pre>
getchangelist([{expr}])		List	list of change list items
getchar([expr])			Number	get one character from the user
getcharmod()			Number	modifiers for the last typed character
getcharsearch()			Dict	last character search
getcmdline()			String	return the current command-line
getcmdpos()			Number	return cursor position in command-line
getcmdtype()			String	return current command-line type
getcmdwintype()			String	return current command-line window type
getcompletion({pat}, {type} [, {filtered}])
<pre>				List	list of cmdline completion matches</pre>
getcurpos()			List	position of the cursor
getcwd([{winnr} [, {tabnr}]])	String	get the current working directory
getenv({name})			String	return environment variable
getfontname([{name}])		String	name of font being used
getfperm({fname})		String	file permissions of file {fname}
getfsize({fname})		Number	size in bytes of file {fname}
getftime({fname})		Number	last modification time of file
getftype({fname})		String	description of type of file {fname}
getimstatus()			Number	|TRUE| if the IME status is active
getjumplist([{winnr} [, {tabnr}]])
<pre>				List	list of jump list items</pre>
getline({lnum})			String	line {lnum} of current buffer
getline({lnum}, {end})		List	lines {lnum} to {end} of current buffer
getloclist({nr} [, {what}])	List	list of location list items
getmatches([{win}])		List	list of current matches
getmousepos()			Dict	last known mouse position
getpid()			Number	process ID of Vim
getpos({expr})			List	position of cursor, mark, etc.
getqflist([{what}])		List	list of quickfix items
getreg([{regname} [, 1 [, {list}]]])
<pre>				String or List   contents of register</pre>
getregtype([{regname}])		String	type of register
gettabinfo([{expr}])		List	list of tab pages
gettabvar({nr}, {varname} [, {def}])
<pre>				any	variable {varname} in tab {nr} or {def}</pre>
gettabwinvar({tabnr}, {winnr}, {name} [, {def}])
<pre>				any	{name} in {winnr} in tab page {tabnr}</pre>
gettagstack([{nr}])		Dict	get the tag stack of window {nr}
getwininfo([{winid}])		List	list of info about each window
getwinpos([{timeout}])		List	X and Y coord in pixels of the Vim window
getwinposx()			Number	X coord in pixels of the Vim window
getwinposy()			Number	Y coord in pixels of the Vim window
getwinvar({nr}, {varname} [, {def}])
<pre>				any	variable {varname} in window {nr}</pre>
glob({expr} [, {nosuf} [, {list} [, {alllinks}]]])
<pre>				any	expand file wildcards in {expr}</pre>
glob2regpat({expr})		String	convert a glob pat into a search pat
globpath({path}, {expr} [, {nosuf} [, {list} [, {alllinks}]]])
<pre>				String	do glob({expr}) for all dirs in {path}</pre>
has({feature})			Number	|TRUE| if feature {feature} supported
has_key({dict}, {key})		Number	|TRUE| if {dict} has entry {key}
haslocaldir([{winnr} [, {tabnr}]])
<pre>				Number	|TRUE| if the window executed |:lcd|</pre>
<pre>					or |:tcd|</pre>
hasmapto({what} [, {mode} [, {abbr}]])
<pre>				Number	|TRUE| if mapping to {what} exists</pre>
histadd({history}, {item})	String	add an item to a history
histdel({history} [, {item}])	String	remove an item from a history
histget({history} [, {index}])	String	get the item {index} from a history
histnr({history})		Number	highest index of a history
hlexists({name})		Number	|TRUE| if highlight group {name} exists
hlID({name})			Number	syntax ID of highlight group {name}
hostname()			String	name of the machine Vim is running on
iconv({expr}, {from}, {to})	String	convert encoding of {expr}
indent({lnum})			Number	indent of line {lnum}
index({object}, {expr} [, {start} [, {ic}]])
<pre>				Number	index in {object} where {expr} appears</pre>
input({prompt} [, {text} [, {completion}]])
<pre>				String	get input from the user</pre>
inputdialog({prompt} [, {text} [, {completion}]])
<pre>				String	like input() but in a GUI dialog</pre>
inputlist({textlist})		Number	let the user pick from a choice list
inputrestore()			Number	restore typeahead
inputsave()			Number	save and clear typeahead
inputsecret({prompt} [, {text}]) String	like input() but hiding the text
insert({object}, {item} [, {idx}]) List	insert {item} in {object} [before {idx}]
interrupt()			none	interrupt script execution
invert({expr})			Number	bitwise invert
isdirectory({directory})	Number	|TRUE| if {directory} is a directory
isinf({expr})			Number	determine if {expr} is infinity value
<pre>					(positive or negative)</pre>
islocked({expr})		Number	|TRUE| if {expr} is locked
isnan({expr})			Number	|TRUE| if {expr} is NaN
items({dict})			List	key-value pairs in {dict}
job_getchannel({job})		Channel	get the channel handle for {job}
job_info([{job}])		Dict	get information about {job}
job_setoptions({job}, {options}) none	set options for {job}
job_start({command} [, {options}])
<pre>				Job	start a job</pre>
job_status({job})		String	get the status of {job}
job_stop({job} [, {how}])	Number	stop {job}
join({list} [, {sep}])		String	join {list} items into one String
js_decode({string})		any	decode JS style JSON
js_encode({expr})		String	encode JS style JSON
json_decode({string})		any	decode JSON
json_encode({expr})		String	encode JSON
keys({dict})			List	keys in {dict}
len({expr})			Number	the length of {expr}
libcall({lib}, {func}, {arg})	String	call {func} in library {lib} with {arg}
libcallnr({lib}, {func}, {arg})	Number	idem, but return a Number
line({expr} [, {winid}])	Number	line nr of cursor, last line or mark
line2byte({lnum})		Number	byte count of line {lnum}
lispindent({lnum})		Number	Lisp indent for line {lnum}
list2str({list} [, {utf8}])	String	turn numbers in {list} into a String
listener_add({callback} [, {buf}])
<pre>				Number	add a callback to listen to changes</pre>
listener_flush([{buf}])		none	invoke listener callbacks
listener_remove({id})		none	remove a listener callback
localtime()			Number	current time
log({expr})			Float	natural logarithm (base e) of {expr}
log10({expr})			Float	logarithm of Float {expr} to base 10
luaeval({expr} [, {expr}])	any	evaluate |Lua| expression
map({expr1}, {expr2})		List/Dict  change each item in {expr1} to {expr}
maparg({name} [, {mode} [, {abbr} [, {dict}]]])
<pre>				String or Dict</pre>
<pre>					rhs of mapping {name} in mode {mode}</pre>
mapcheck({name} [, {mode} [, {abbr}]])
<pre>				String	check for mappings matching {name}</pre>
match({expr}, {pat} [, {start} [, {count}]])
<pre>				Number	position where {pat} matches in {expr}</pre>
matchadd({group}, {pattern} [, {priority} [, {id} [, {dict}]]])
<pre>				Number	highlight {pattern} with {group}</pre>
matchaddpos({group}, {pos} [, {priority} [, {id} [, {dict}]]])
<pre>				Number	highlight positions with {group}</pre>
matcharg({nr})			List	arguments of |:match|
matchdelete({id} [, {win}])	Number	delete match identified by {id}
matchend({expr}, {pat} [, {start} [, {count}]])
<pre>				Number	position where {pat} ends in {expr}</pre>
matchlist({expr}, {pat} [, {start} [, {count}]])
<pre>				List	match and submatches of {pat} in {expr}</pre>
matchstr({expr}, {pat} [, {start} [, {count}]])
<pre>				String	{count}'th match of {pat} in {expr}</pre>
matchstrpos({expr}, {pat} [, {start} [, {count}]])
<pre>				List	{count}'th match of {pat} in {expr}</pre>
max({expr})			Number	maximum value of items in {expr}
min({expr})			Number	minimum value of items in {expr}
mkdir({name} [, {path} [, {prot}]])
<pre>				Number	create directory {name}</pre>
mode([expr])			String	current editing mode
mzeval({expr})			any	evaluate |MzScheme| expression
nextnonblank({lnum})		Number	line nr of non-blank line >= {lnum}
nr2char({expr} [, {utf8}])	String	single char with ASCII/UTF8 value {expr}
or({expr}, {expr})		Number	bitwise OR
pathshorten({expr})		String	shorten directory names in a path
perleval({expr})		any	evaluate |Perl| expression
popup_atcursor({what}, {options}) Number create popup window near the cursor
popup_beval({what}, {options})	Number	create popup window for 'ballooneval'
popup_clear()			none	close all popup windows
popup_close({id} [, {result}])	none	close popup window {id}
popup_create({what}, {options}) Number	create a popup window
popup_dialog({what}, {options}) Number	create a popup window used as a dialog
popup_filter_menu({id}, {key})  Number	filter for a menu popup window
popup_filter_yesno({id}, {key}) Number	filter for a dialog popup window
popup_findinfo()		Number	get window ID of info popup window
popup_findpreview()		Number	get window ID of preview popup window
popup_getoptions({id})		Dict	get options of popup window {id}
popup_getpos({id})		Dict	get position of popup window {id}
popup_hide({id})		none	hide popup menu {id}
popup_menu({what}, {options})	Number	create a popup window used as a menu
popup_move({id}, {options})	none	set position of popup window {id}
popup_notification({what}, {options})
<pre>				Number	create a notification popup window</pre>
popup_show({id})		none	unhide popup window {id}
popup_setoptions({id}, {options})
<pre>				none	set options for popup window {id}</pre>
popup_settext({id}, {text})	none	set the text of popup window {id}
pow({x}, {y})			Float	{x} to the power of {y}
prevnonblank({lnum})		Number	line nr of non-blank line <= {lnum}
printf({fmt}, {expr1}...)	String	format text
prompt_setcallback({buf}, {expr}) none	set prompt callback function
prompt_setinterrupt({buf}, {text}) none	set prompt interrupt function
prompt_setprompt({buf}, {text}) none	set prompt text
prop_add({lnum}, {col}, {props})  none	add a text property
prop_clear({lnum} [, {lnum-end} [, {props}]])
<pre>				none	remove all text properties</pre>
prop_find({props} [, {direction}])
<pre>				Dict	search for a text property</pre>
prop_list({lnum} [, {props})	List	text properties in {lnum}
prop_remove({props} [, {lnum} [, {lnum-end}]])
<pre>				Number	remove a text property</pre>
prop_type_add({name}, {props})	none	define a new property type
prop_type_change({name}, {props})
<pre>				none	change an existing property type</pre>
prop_type_delete({name} [, {props}])
<pre>				none	delete a property type</pre>
prop_type_get([{name} [, {props}])
<pre>				Dict	get property type values</pre>
prop_type_list([{props}])	List	get list of property types
pum_getpos()			Dict	position and size of pum if visible
pumvisible()			Number	whether popup menu is visible
pyeval({expr})			any	evaluate |Python| expression
py3eval({expr})			any	evaluate |python3| expression
pyxeval({expr})			any	evaluate |python_x| expression
rand([{expr}])			Number	get pseudo-random number
range({expr} [, {max} [, {stride}]])
<pre>				List	items from {expr} to {max}</pre>
readdir({dir} [, {expr}])	List	file names in {dir} selected by {expr}
readfile({fname} [, {type} [, {max}]])
<pre>				List	get list of lines from file {fname}</pre>
reg_executing()			String	get the executing register name
reg_recording()			String	get the recording register name
reltime([{start} [, {end}]])	List	get time value
reltimefloat({time})		Float	turn the time value into a Float
reltimestr({time})		String	turn time value into a String
remote_expr({server}, {string} [, {idvar} [, {timeout}]])
<pre>				String	send expression</pre>
remote_foreground({server})	Number	bring Vim server to the foreground
remote_peek({serverid} [, {retvar}])
<pre>				Number	check for reply string</pre>
remote_read({serverid} [, {timeout}])
<pre>				String	read reply string</pre>
remote_send({server}, {string} [, {idvar}])
<pre>				String	send key sequence</pre>
remote_startserver({name})	none	become server {name}
remove({list}, {idx} [, {end}])	any/List
<pre>					remove items {idx}-{end} from {list}</pre>
remove({blob}, {idx} [, {end}])	Number/Blob
<pre>					remove bytes {idx}-{end} from {blob}</pre>
remove({dict}, {key})		any	remove entry {key} from {dict}
rename({from}, {to})		Number	rename (move) file from {from} to {to}
repeat({expr}, {count})		String	repeat {expr} {count} times
resolve({filename})		String	get filename a shortcut points to
reverse({list})			List	reverse {list} in-place
round({expr})			Float	round off {expr}
rubyeval({expr})		any	evaluate |Ruby| expression
screenattr({row}, {col})	Number	attribute at screen position
screenchar({row}, {col})	Number	character at screen position
screenchars({row}, {col})	List	List of characters at screen position
screencol()			Number	current cursor column
screenpos({winid}, {lnum}, {col}) Dict	screen row and col of a text character
screenrow()			Number	current cursor row
screenstring({row}, {col})	String	characters at screen position
search({pattern} [, {flags} [, {stopline} [, {timeout}]]])
<pre>				Number	search for {pattern}</pre>
searchdecl({name} [, {global} [, {thisblock}]])
<pre>				Number	search for variable declaration</pre>
searchpair({start}, {middle}, {end} [, {flags} [, {skip} [...]]])
<pre>				Number	search for other end of start/end pair</pre>
searchpairpos({start}, {middle}, {end} [, {flags} [, {skip} [...]]])
<pre>				List	search for other end of start/end pair</pre>
searchpos({pattern} [, {flags} [, {stopline} [, {timeout}]]])
<pre>				List	search for {pattern}</pre>
server2client({clientid}, {string})
<pre>				Number	send reply string</pre>
serverlist()			String	get a list of available servers
setbufline({expr}, {lnum}, {text})
<pre>				Number	set line {lnum} to {text} in buffer</pre>
<pre>					{expr}</pre>
setbufvar({expr}, {varname}, {val})
<pre>				none	set {varname} in buffer {expr} to {val}</pre>
setcharsearch({dict})		Dict	set character search from {dict}
setcmdpos({pos})		Number	set cursor position in command-line
setenv({name}, {val})		none	set environment variable
setfperm({fname}, {mode})	Number	set {fname} file permissions to {mode}
setline({lnum}, {line})		Number	set line {lnum} to {line}
setloclist({nr}, {list} [, {action} [, {what}]])
<pre>				Number	modify location list using {list}</pre>
setmatches({list} [, {win}])	Number	restore a list of matches
setpos({expr}, {list})		Number	set the {expr} position to {list}
setqflist({list} [, {action} [, {what}]])
<pre>				Number	modify quickfix list using {list}</pre>
setreg({n}, {v} [, {opt}])	Number	set register to value and type
settabvar({nr}, {varname}, {val}) none	set {varname} in tab page {nr} to {val}
settabwinvar({tabnr}, {winnr}, {varname}, {val})
<pre>				none	set {varname} in window {winnr} in tab</pre>
<pre>					page {tabnr} to {val}</pre>
settagstack({nr}, {dict} [, {action}])
<pre>				Number	modify tag stack using {dict}</pre>
setwinvar({nr}, {varname}, {val}) none	set {varname} in window {nr} to {val}
sha256({string})		String	SHA256 checksum of {string}
shellescape({string} [, {special}])
<pre>				String	escape {string} for use as shell</pre>
<pre>					command argument</pre>
shiftwidth([{col}])		Number	effective value of 'shiftwidth'
sign_define({name} [, {dict}])	Number	define or update a sign
sign_define({list})		List	define or update a list of signs
sign_getdefined([{name}])	List	get a list of defined signs
sign_getplaced([{expr} [, {dict}]])
<pre>				List	get a list of placed signs</pre>
sign_jump({id}, {group}, {expr})
<pre>				Number	jump to a sign</pre>
sign_place({id}, {group}, {name}, {expr} [, {dict}])
<pre>				Number	place a sign</pre>
sign_placelist({list})		List	place a list of signs
sign_undefine([{name}])		Number	undefine a sign
sign_undefine({list})		List	undefine a list of signs
sign_unplace({group} [, {dict}])
<pre>				Number	unplace a sign</pre>
sign_unplacelist({list})	List	unplace a list of signs
simplify({filename})		String	simplify filename as much as possible
sin({expr})			Float	sine of {expr}
sinh({expr})			Float	hyperbolic sine of {expr}
sort({list} [, {func} [, {dict}]])
<pre>				List	sort {list}, using {func} to compare</pre>
sound_clear()			none	stop playing all sounds
sound_playevent({name} [, {callback}])
<pre>				Number	play an event sound</pre>
sound_playfile({path} [, {callback}])
<pre>				Number	play sound file {path}</pre>
sound_stop({id})		none	stop playing sound {id}
soundfold({word})		String	sound-fold {word}
spellbadword()			String	badly spelled word at cursor
spellsuggest({word} [, {max} [, {capital}]])
<pre>				List	spelling suggestions</pre>
split({expr} [, {pat} [, {keepempty}]])
<pre>				List	make |List| from {pat} separated {expr}</pre>
sqrt({expr})			Float	square root of {expr}
srand([{expr}])			List	get seed for |rand()|
state([{what}])			String	current state of Vim
str2float({expr})		Float	convert String to Float
str2list({expr} [, {utf8}])	List	convert each character of {expr} to
<pre>					ASCII/UTF8 value</pre>
str2nr({expr} [, {base} [, {quoted}]])
<pre>				Number	convert String to Number</pre>
strchars({expr} [, {skipcc}])	Number	character length of the String {expr}
strcharpart({str}, {start} [, {len}])
<pre>				String	{len} characters of {str} at {start}</pre>
strdisplaywidth({expr} [, {col}]) Number display length of the String {expr}
strftime({format} [, {time}])	String	format time with a specified format
strgetchar({str}, {index})	Number	get char {index} from {str}
stridx({haystack}, {needle} [, {start}])
<pre>				Number	index of {needle} in {haystack}</pre>
string({expr})			String	String representation of {expr} value
strlen({expr})			Number	length of the String {expr}
strpart({str}, {start} [, {len}])
<pre>				String	{len} characters of {str} at {start}</pre>
strptime({format}, {timestring})
<pre>				Number	Convert {timestring} to unix timestamp</pre>
strridx({haystack}, {needle} [, {start}])
<pre>				Number	last index of {needle} in {haystack}</pre>
strtrans({expr})		String	translate string to make it printable
strwidth({expr})		Number	display cell length of the String {expr}
submatch({nr} [, {list}])	String or List
<pre>					specific match in ":s" or substitute()</pre>
substitute({expr}, {pat}, {sub}, {flags})
<pre>				String	all {pat} in {expr} replaced with {sub}</pre>
swapinfo({fname})		Dict	information about swap file {fname}
swapname({expr})		String	swap file of buffer {expr}
synID({lnum}, {col}, {trans})	Number	syntax ID at {lnum} and {col}
synIDattr({synID}, {what} [, {mode}])
<pre>				String	attribute {what} of syntax ID {synID}</pre>
synIDtrans({synID})		Number	translated syntax ID of {synID}
synconcealed({lnum}, {col})	List	info about concealing
synstack({lnum}, {col})		List	stack of syntax IDs at {lnum} and {col}
system({expr} [, {input}])	String	output of shell command/filter {expr}
systemlist({expr} [, {input}])	List	output of shell command/filter {expr}
tabpagebuflist([{arg}])		List	list of buffer numbers in tab page
tabpagenr([{arg}])		Number	number of current or last tab page
tabpagewinnr({tabarg} [, {arg}]) Number	number of current window in tab page
taglist({expr} [, {filename}])	List	list of tags matching {expr}
tagfiles()			List	tags files used
tan({expr})			Float	tangent of {expr}
tanh({expr})			Float	hyperbolic tangent of {expr}
tempname()			String	name for a temporary file
term_dumpdiff({filename}, {filename} [, {options}])
<pre>				Number  display difference between two dumps</pre>
term_dumpload({filename} [, {options}])
<pre>				Number	displaying a screen dump</pre>
term_dumpwrite({buf}, {filename} [, {options}])
<pre>				none	dump terminal window contents</pre>
term_getaltscreen({buf})	Number	get the alternate screen flag
term_getansicolors({buf})	List	get ANSI palette in GUI color mode
term_getattr({attr}, {what})	Number	get the value of attribute {what}
term_getcursor({buf})		List	get the cursor position of a terminal
term_getjob({buf})		Job	get the job associated with a terminal
term_getline({buf}, {row})	String	get a line of text from a terminal
term_getscrolled({buf})		Number	get the scroll count of a terminal
term_getsize({buf})		List	get the size of a terminal
term_getstatus({buf})		String	get the status of a terminal
term_gettitle({buf})		String	get the title of a terminal
term_gettty({buf}, [{input}])	String	get the tty name of a terminal
term_list()			List	get the list of terminal buffers
term_scrape({buf}, {row})	List	get row of a terminal screen
term_sendkeys({buf}, {keys})	none	send keystrokes to a terminal
term_setapi({buf}, {expr})	none	set |terminal-api| function name prefix
term_setansicolors({buf}, {colors})
<pre>				none	set ANSI palette in GUI color mode</pre>
term_setkill({buf}, {how})	none	set signal to stop job in terminal
term_setrestore({buf}, {command}) none	set command to restore terminal
term_setsize({buf}, {rows}, {cols})
<pre>				none	set the size of a terminal</pre>
term_start({cmd} [, {options}])	Number	open a terminal window and run a job
term_wait({buf} [, {time}])	Number  wait for screen to be updated
test_alloc_fail({id}, {countdown}, {repeat})
<pre>				none	make memory allocation fail</pre>
test_autochdir()		none	enable 'autochdir' during startup
test_feedinput({string})	none	add key sequence to input buffer
test_garbagecollect_now()	none	free memory right now for testing
test_garbagecollect_soon()	none	free memory soon for testing
test_getvalue({string})		any	get value of an internal variable
test_ignore_error({expr})	none	ignore a specific error
test_null_blob()		Blob	null value for testing
test_null_channel()		Channel	null value for testing
test_null_dict()		Dict	null value for testing
test_null_job()			Job	null value for testing
test_null_list()		List	null value for testing
test_null_partial()		Funcref	null value for testing
test_null_string()		String	null value for testing
test_option_not_set({name})	none	reset flag indicating option was set
test_override({expr}, {val})	none	test with Vim internal overrides
test_refcount({expr})		Number	get the reference count of {expr}
test_scrollbar({which}, {value}, {dragging})
<pre>				none	scroll in the GUI for testing</pre>
test_setmouse({row}, {col})	none	set the mouse position for testing
test_settime({expr})		none	set current time for testing
timer_info([{id}])		List	information about timers
timer_pause({id}, {pause})	none	pause or unpause a timer
timer_start({time}, {callback} [, {options}])
<pre>				Number	create a timer</pre>
timer_stop({timer})		none	stop a timer
timer_stopall()			none	stop all timers
tolower({expr})			String	the String {expr} switched to lowercase
toupper({expr})			String	the String {expr} switched to uppercase
tr({src}, {fromstr}, {tostr})	String	translate chars of {src} in {fromstr}
<pre>					to chars in {tostr}</pre>
trim({text} [, {mask}])		String	trim characters in {mask} from {text}
trunc({expr})			Float	truncate Float {expr}
type({name})			Number	type of variable {name}
undofile({name})		String	undo file name for {name}
undotree()			List	undo file tree
uniq({list} [, {func} [, {dict}]])
<pre>				List	remove adjacent duplicates from a list</pre>
values({dict})			List	values in {dict}
virtcol({expr})			Number	screen column of cursor or mark
visualmode([expr])		String	last visual mode used
wildmenumode()			Number	whether 'wildmenu' mode is active
win_execute({id}, {command} [, {silent}])
<pre>				String	execute {command} in window {id}</pre>
win_findbuf({bufnr})		List	find windows containing {bufnr}
win_getid([{win} [, {tab}]])	Number	get window ID for {win} in {tab}
win_gotoid({expr})		Number	go to window with ID {expr}
win_id2tabwin({expr})		List	get tab and window nr from window ID
win_id2win({expr})		Number	get window nr from window ID
win_screenpos({nr})		List	get screen position of window {nr}
win_splitmove({nr}, {target} [, {options}])
<pre>				Number	move window {nr} to split of {target}</pre>
winbufnr({nr})			Number	buffer number of window {nr}
wincol()			Number	window column of the cursor
winheight({nr})			Number	height of window {nr}
winlayout([{tabnr}])		List	layout of windows in tab {tabnr}
winline()			Number	window line of the cursor
winnr([{expr}])			Number	number of current window
winrestcmd()			String	returns command to restore window sizes
winrestview({dict})		none	restore view of current window
winsaveview()			Dict	save view of current window
winwidth({nr})			Number	width of window {nr}
wordcount()			Dict	get byte/char/word statistics
writefile({object}, {fname} [, {flags}])
<pre>				Number	write |Blob| or |List| of lines to file</pre>
xor({expr}, {expr})		Number	bitwise XOR<p>


abs({expr})							*abs()*
<pre>		Return the absolute value of {expr}.  When {expr} evaluates to</pre>
<pre>		a |Float| abs() returns a |Float|.  When {expr} can be</pre>
<pre>		converted to a |Number| abs() returns a |Number|.  Otherwise</pre>
<pre>		abs() gives an error message and returns -1.</pre>
<pre>		Examples: ></pre>
<pre>			echo abs(1.456)</pre>
<			1.456  >
<pre>			echo abs(-5.456)</pre>
<			5.456  >
<pre>			echo abs(-4)</pre>
<			4<p>

<pre>		Can also be used as a |method|: ></pre>
<pre>			Compute()->abs()<p></pre>

<		{only available when compiled with the |+float| feature}<p>


acos({expr})							*acos()*
<pre>		Return the arc cosine of {expr} measured in radians, as a</pre>
<pre>		|Float| in the range of [0, pi].</pre>
<pre>		{expr} must evaluate to a |Float| or a |Number| in the range</pre>
<pre>		[-1, 1].</pre>
<pre>		Examples: ></pre>
<pre>			:echo acos(0)</pre>
<			1.570796 >
<pre>			:echo acos(-0.5)</pre>
<			2.094395<p>

<pre>		Can also be used as a |method|: ></pre>
<pre>			Compute()->acos()<p></pre>

<		{only available when compiled with the |+float| feature}<p>


add({object}, {expr})					*add()*
<pre>		Append the item {expr} to |List| or |Blob| {object}.  Returns</pre>
<pre>		the resulting |List| or |Blob|.  Examples: ></pre>
<pre>			:let alist = add([1, 2, 3], item)</pre>
<pre>			:call add(mylist, "woodstock")</pre>
<		Note that when {expr} is a |List| it is appended as a single
<pre>		item.  Use |extend()| to concatenate |Lists|.</pre>
<pre>		When {object} is a |Blob| then  {expr} must be a number.</pre>
<pre>		Use |insert()| to add an item at another position.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			mylist->add(val1)->add(val2)<p></pre>


and({expr}, {expr})					*and()*
<pre>		Bitwise AND on the two arguments.  The arguments are converted</pre>
<pre>		to a number.  A List, Dict or Float argument causes an error.</pre>
<pre>		Example: ></pre>
<pre>			:let flag = and(bits, 0x80)</pre>
<		Can also be used as a |method|: >
<pre>			:let flag = bits->and(0x80)<p></pre>


append({lnum}, {text})					*append()*
<pre>		When {text} is a |List|: Append each item of the |List| as a</pre>
<pre>		text line below line {lnum} in the current buffer.</pre>
<pre>		Otherwise append {text} as one text line below line {lnum} in</pre>
<pre>		the current buffer.</pre>
<pre>		{lnum} can be zero to insert a line before the first one.</pre>
<pre>		Returns 1 for failure ({lnum} out of range or out of memory),</pre>
<pre>		0 for success.  Example: ></pre>
<pre>			:let failed = append(line('$'), "# THE END")</pre>
<pre>			:let failed = append(0, ["Chapter 1", "the beginning"])<p></pre>

<		Can also be used as a |method| after a List: >
<pre>			mylist->append(lnum)<p></pre>


appendbufline({expr}, {lnum}, {text})			*appendbufline()*
<pre>		Like |append()| but append the text in buffer {expr}.<p></pre>

<pre>		This function works only for loaded buffers. First call</pre>
<pre>		|bufload()| if needed.<p></pre>

<pre>		For the use of {expr}, see |bufname()|.<p></pre>

<pre>		{lnum} is used like with |append()|.  Note that using |line()|</pre>
<pre>		would use the current buffer, not the one appending to.</pre>
<pre>		Use "$" to append at the end of the buffer.<p></pre>

<pre>		On success 0 is returned, on failure 1 is returned.<p></pre>

<pre>		If {expr} is not a valid buffer or {lnum} is not valid, an</pre>
<pre>		error message is given. Example: ></pre>
<pre>			:let failed = appendbufline(13, 0, "# THE START")</pre>
<
<pre>		Can also be used as a |method| after a List: ></pre>
<pre>			mylist->appendbufline(buf, lnum)<p></pre>


argc([{winid}])					*argc()*
<pre>		The result is the number of files in the argument list.  See</pre>
<pre>		|arglist|.</pre>
<pre>		If {winid} is not supplied, the argument list of the current</pre>
<pre>		window is used.</pre>
<pre>		If {winid} is -1, the global argument list is used.</pre>
<pre>		Otherwise {winid} specifies the window of which the argument</pre>
<pre>		list is used: either the window number or the window ID.</pre>
<pre>		Returns -1 if the {winid} argument is invalid.<p></pre>

<pre>							*argidx()*</pre>
argidx()	The result is the current index in the argument list.  0 is
<pre>		the first file.  argc() - 1 is the last one.  See |arglist|.<p></pre>

<pre>							*arglistid()*</pre>
arglistid([{winnr} [, {tabnr}]])
<pre>		Return the argument list ID.  This is a number which</pre>
<pre>		identifies the argument list being used.  Zero is used for the</pre>
<pre>		global argument list.  See |arglist|.</pre>
<pre>		Returns -1 if the arguments are invalid.<p></pre>

<pre>		Without arguments use the current window.</pre>
<pre>		With {winnr} only use this window in the current tab page.</pre>
<pre>		With {winnr} and {tabnr} use the window in the specified tab</pre>
<pre>		page.</pre>
<pre>		{winnr} can be the window number or the |window-ID|.<p></pre>

<pre>							*argv()*</pre>
argv([{nr} [, {winid}])
<pre>		The result is the {nr}th file in the argument list.  See</pre>
<pre>		|arglist|.  "argv(0)" is the first one.  Example: ></pre>
<pre>	:let i = 0</pre>
<pre>	:while i < argc()</pre>
<pre>	:  let f = escape(fnameescape(argv(i)), '.')</pre>
<pre>	:  exe 'amenu Arg.' . f . ' :e ' . f . '<CR>'</pre>
<pre>	:  let i = i + 1</pre>
<pre>	:endwhile</pre>
<		Without the {nr} argument, or when {nr} is -1, a |List| with
<pre>		the whole |arglist| is returned.<p></pre>

<pre>		The {winid} argument specifies the window ID, see |argc()|.</pre>
<pre>		For the Vim command line arguments see |v:argv|.<p></pre>


assert_ functions are documented here: |assert-functions-details|<p>


asin({expr})						*asin()*
<pre>		Return the arc sine of {expr} measured in radians, as a |Float|</pre>
<pre>		in the range of [-pi/2, pi/2].</pre>
<pre>		{expr} must evaluate to a |Float| or a |Number| in the range</pre>
<pre>		[-1, 1].</pre>
<pre>		Examples: ></pre>
<pre>			:echo asin(0.8)</pre>
<			0.927295 >
<pre>			:echo asin(-0.5)</pre>
<			-0.523599<p>

<pre>		Can also be used as a |method|: ></pre>
<pre>			Compute()->asin()</pre>
<
<pre>		{only available when compiled with the |+float| feature}<p></pre>


atan({expr})						*atan()*
<pre>		Return the principal value of the arc tangent of {expr}, in</pre>
<pre>		the range [-pi/2, +pi/2] radians, as a |Float|.</pre>
<pre>		{expr} must evaluate to a |Float| or a |Number|.</pre>
<pre>		Examples: ></pre>
<pre>			:echo atan(100)</pre>
<			1.560797 >
<pre>			:echo atan(-4.01)</pre>
<			-1.326405<p>

<pre>		Can also be used as a |method|: ></pre>
<pre>			Compute()->atan()</pre>
<
<pre>		{only available when compiled with the |+float| feature}<p></pre>


atan2({expr1}, {expr2})					*atan2()*
<pre>		Return the arc tangent of {expr1} / {expr2}, measured in</pre>
<pre>		radians, as a |Float| in the range [-pi, pi].</pre>
<pre>		{expr1} and {expr2} must evaluate to a |Float| or a |Number|.</pre>
<pre>		Examples: ></pre>
<pre>			:echo atan2(-1, 1)</pre>
<			-0.785398 >
<pre>			:echo atan2(1, -1)</pre>
<			2.356194<p>

<pre>		Can also be used as a |method|: ></pre>
<pre>			Compute()->atan(1)</pre>
<
<pre>		{only available when compiled with the |+float| feature}<p></pre>

balloon_gettext()					*balloon_gettext()*
<pre>		Return the current text in the balloon.  Only for the string,</pre>
<pre>		not used for the List.<p></pre>

balloon_show({expr})					*balloon_show()*
<pre>		Show {expr} inside the balloon.  For the GUI {expr} is used as</pre>
<pre>		a string.  For a terminal {expr} can be a list, which contains</pre>
<pre>		the lines of the balloon.  If {expr} is not a list it will be</pre>
<pre>		split with |balloon_split()|.</pre>
<pre>		If {expr} is an empty string any existing balloon is removed.<p></pre>

<pre>		Example: ></pre>
<pre>			func GetBalloonContent()</pre>
<pre>			   " ... initiate getting the content</pre>
<pre>			   return ''</pre>
<pre>			endfunc</pre>
<pre>			set balloonexpr=GetBalloonContent()<p></pre>

<pre>			func BalloonCallback(result)</pre>
<pre>			  call balloon_show(a:result)</pre>
<pre>			endfunc</pre>
<		Can also be used as a |method|: >
<pre>			GetText()->balloon_show()</pre>
<
<pre>		The intended use is that fetching the content of the balloon</pre>
<pre>		is initiated from 'balloonexpr'.  It will invoke an</pre>
<pre>		asynchronous method, in which a callback invokes</pre>
<pre>		balloon_show().  The 'balloonexpr' itself can return an</pre>
<pre>		empty string or a placeholder.<p></pre>

<pre>		When showing a balloon is not possible nothing happens, no</pre>
<pre>		error message.</pre>
<pre>		{only available when compiled with the |+balloon_eval| or</pre>
<pre>		|+balloon_eval_term| feature}<p></pre>

balloon_split({msg})					*balloon_split()*
<pre>		Split {msg} into lines to be displayed in a balloon.  The</pre>
<pre>		splits are made for the current window size and optimize to</pre>
<pre>		show debugger output.</pre>
<pre>		Returns a |List| with the split lines.</pre>
<pre>		Can also be used as a |method|: ></pre>
<pre>			GetText()->balloon_split()->balloon_show()<p></pre>

<		{only available when compiled with the |+balloon_eval_term|
<pre>		feature}<p></pre>

<pre>							*browse()*</pre>
browse({save}, {title}, {initdir}, {default})
<pre>		Put up a file requester.  This only works when "has("browse")"</pre>
<pre>		returns |TRUE| (only in some GUI versions).</pre>
<pre>		The input fields are:</pre>
<pre>		    {save}	when |TRUE|, select file to write</pre>
<pre>		    {title}	title for the requester</pre>
<pre>		    {initdir}	directory to start browsing in</pre>
<pre>		    {default}	default file name</pre>
<pre>		An empty string is returned when the "Cancel" button is hit,</pre>
<pre>		something went wrong, or browsing is not possible.<p></pre>

<pre>							*browsedir()*</pre>
browsedir({title}, {initdir})
<pre>		Put up a directory requester.  This only works when</pre>
<pre>		"has("browse")" returns |TRUE| (only in some GUI versions).</pre>
<pre>		On systems where a directory browser is not supported a file</pre>
<pre>		browser is used.  In that case: select a file in the directory</pre>
<pre>		to be used.</pre>
<pre>		The input fields are:</pre>
<pre>		    {title}	title for the requester</pre>
<pre>		    {initdir}	directory to start browsing in</pre>
<pre>		When the "Cancel" button is hit, something went wrong, or</pre>
<pre>		browsing is not possible, an empty string is returned.<p></pre>

bufadd({name})						*bufadd()*
<pre>		Add a buffer to the buffer list with {name}.</pre>
<pre>		If a buffer for file {name} already exists, return that buffer</pre>
<pre>		number.  Otherwise return the buffer number of the newly</pre>
<pre>		created buffer.  When {name} is an empty string then a new</pre>
<pre>		buffer is always created.</pre>
<pre>		The buffer will not have 'buflisted' set and not be loaded</pre>
<pre>		yet.  To add some text to the buffer use this: ></pre>
<pre>			let bufnr = bufadd('someName')</pre>
<pre>			call bufload(bufnr)</pre>
<pre>			call setbufline(bufnr, 1, ['some', 'text'])</pre>
<		Can also be used as a |method|: >
<pre>			let bufnr = 'somename'->bufadd()<p></pre>

bufexists({expr})					*bufexists()*
<pre>		The result is a Number, which is |TRUE| if a buffer called</pre>
<pre>		{expr} exists.</pre>
<pre>		If the {expr} argument is a number, buffer numbers are used.</pre>
<pre>		Number zero is the alternate buffer for the current window.<p></pre>

<pre>		If the {expr} argument is a string it must match a buffer name</pre>
<pre>		exactly.  The name can be:</pre>
<pre>		- Relative to the current directory.</pre>
<pre>		- A full path.</pre>
<pre>		- The name of a buffer with 'buftype' set to "nofile".</pre>
<pre>		- A URL name.</pre>
<pre>		Unlisted buffers will be found.</pre>
<pre>		Note that help files are listed by their short name in the</pre>
<pre>		output of |:buffers|, but bufexists() requires using their</pre>
<pre>		long name to be able to find them.</pre>
<pre>		bufexists() may report a buffer exists, but to use the name</pre>
<pre>		with a |:buffer| command you may need to use |expand()|.  Esp</pre>
<pre>		for MS-Windows 8.3 names in the form "c:\DOCUME~1"</pre>
<pre>		Use "bufexists(0)" to test for the existence of an alternate</pre>
<pre>		file name.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			let exists = 'somename'->bufexists()</pre>
<
<pre>		Obsolete name: buffer_exists().		*buffer_exists()*<p></pre>

buflisted({expr})					*buflisted()*
<pre>		The result is a Number, which is |TRUE| if a buffer called</pre>
<pre>		{expr} exists and is listed (has the 'buflisted' option set).</pre>
<pre>		The {expr} argument is used like with |bufexists()|.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			let listed = 'somename'->buflisted()<p></pre>

bufload({expr})						*bufload()*
<pre>		Ensure the buffer {expr} is loaded.  When the buffer name</pre>
<pre>		refers to an existing file then the file is read.  Otherwise</pre>
<pre>		the buffer will be empty.  If the buffer was already loaded</pre>
<pre>		then there is no change.</pre>
<pre>		If there is an existing swap file for the file of the buffer,</pre>
<pre>		there will be no dialog, the buffer will be loaded anyway.</pre>
<pre>		The {expr} argument is used like with |bufexists()|.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			eval 'somename'->bufload()<p></pre>

bufloaded({expr})					*bufloaded()*
<pre>		The result is a Number, which is |TRUE| if a buffer called</pre>
<pre>		{expr} exists and is loaded (shown in a window or hidden).</pre>
<pre>		The {expr} argument is used like with |bufexists()|.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			let loaded = 'somename'->bufloaded()<p></pre>

bufname([{expr}])					*bufname()*
<pre>		The result is the name of a buffer, as it is displayed by the</pre>
<pre>		":ls" command.</pre>
<pre>		If {expr} is omitted the current buffer is used.</pre>
<pre>		If {expr} is a Number, that buffer number's name is given.</pre>
<pre>		Number zero is the alternate buffer for the current window.</pre>
<pre>		If {expr} is a String, it is used as a |file-pattern| to match</pre>
<pre>		with the buffer names.  This is always done like 'magic' is</pre>
<pre>		set and 'cpoptions' is empty.  When there is more than one</pre>
<pre>		match an empty string is returned.</pre>
<pre>		"" or "%" can be used for the current buffer, "#" for the</pre>
<pre>		alternate buffer.</pre>
<pre>		A full match is preferred, otherwise a match at the start, end</pre>
<pre>		or middle of the buffer name is accepted.  If you only want a</pre>
<pre>		full match then put "^" at the start and "$" at the end of the</pre>
<pre>		pattern.</pre>
<pre>		Listed buffers are found first.  If there is a single match</pre>
<pre>		with a listed buffer, that one is returned.  Next unlisted</pre>
<pre>		buffers are searched for.</pre>
<pre>		If the {expr} is a String, but you want to use it as a buffer</pre>
<pre>		number, force it to be a Number by adding zero to it: ></pre>
<pre>			:echo bufname("3" + 0)</pre>
<		Can also be used as a |method|: >
<pre>			echo bufnr->bufname()<p></pre>

<		If the buffer doesn't exist, or doesn't have a name, an empty
<pre>		string is returned. ></pre>
<pre>	bufname("#")		alternate buffer name</pre>
<pre>	bufname(3)		name of buffer 3</pre>
<pre>	bufname("%")		name of current buffer</pre>
<pre>	bufname("file2")	name of buffer where "file2" matches.</pre>
<							*buffer_name()*
<pre>		Obsolete name: buffer_name().<p></pre>

<pre>							*bufnr()*</pre>
bufnr([{expr} [, {create}]])
<pre>		The result is the number of a buffer, as it is displayed by</pre>
<pre>		the ":ls" command.  For the use of {expr}, see |bufname()|</pre>
<pre>		above.<p></pre>

<pre>		If the buffer doesn't exist, -1 is returned.  Or, if the</pre>
<pre>		{create} argument is present and not zero, a new, unlisted,</pre>
<pre>		buffer is created and its number is returned.  Example: ></pre>
<pre>			let newbuf = bufnr('Scratch001', 1)</pre>
<		Using an empty name uses the current buffer. To create a new
<pre>		buffer with an empty name use |bufadd()|.<p></pre>

<pre>		bufnr("$") is the last buffer: ></pre>
<pre>			:let last_buffer = bufnr("$")</pre>
<		The result is a Number, which is the highest buffer number
<pre>		of existing buffers.  Note that not all buffers with a smaller</pre>
<pre>		number necessarily exist, because ":bwipeout" may have removed</pre>
<pre>		them.  Use bufexists() to test for the existence of a buffer.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			echo bufref->bufnr()</pre>
<
<pre>		Obsolete name: buffer_number().		*buffer_number()*</pre>
<pre>							*last_buffer_nr()*</pre>
<pre>		Obsolete name for bufnr("$"): last_buffer_nr().<p></pre>

bufwinid({expr})					*bufwinid()*
<pre>		The result is a Number, which is the |window-ID| of the first</pre>
<pre>		window associated with buffer {expr}.  For the use of {expr},</pre>
<pre>		see |bufname()| above.  If buffer {expr} doesn't exist or</pre>
<pre>		there is no such window, -1 is returned.  Example: ><p></pre>

<pre>	echo "A window containing buffer 1 is " . (bufwinid(1))</pre>
<
<pre>		Only deals with the current tab page.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			FindBuffer()->bufwinid()<p></pre>

bufwinnr({expr})					*bufwinnr()*
<pre>		Like |bufwinid()| but return the window number instead of the</pre>
<pre>		|window-ID|.</pre>
<pre>		If buffer {expr} doesn't exist or there is no such window, -1</pre>
<pre>		is returned.  Example: ><p></pre>

<pre>	echo "A window containing buffer 1 is " . (bufwinnr(1))<p></pre>

<		The number can be used with |CTRL-W_w| and ":wincmd w"
<pre>		|:wincmd|.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			FindBuffer()->bufwinnr()<p></pre>

byte2line({byte})					*byte2line()*
<pre>		Return the line number that contains the character at byte</pre>
<pre>		count {byte} in the current buffer.  This includes the</pre>
<pre>		end-of-line character, depending on the 'fileformat' option</pre>
<pre>		for the current buffer.  The first character has byte count</pre>
<pre>		one.</pre>
<pre>		Also see |line2byte()|, |go| and |:goto|.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetOffset()->byte2line()<p></pre>

<		{not available when compiled without the |+byte_offset|
<pre>		feature}<p></pre>

byteidx({expr}, {nr})					*byteidx()*
<pre>		Return byte index of the {nr}'th character in the string</pre>
<pre>		{expr}.  Use zero for the first character, it returns zero.</pre>
<pre>		This function is only useful when there are multibyte</pre>
<pre>		characters, otherwise the returned value is equal to {nr}.</pre>
<pre>		Composing characters are not counted separately, their byte</pre>
<pre>		length is added to the preceding base character.  See</pre>
<pre>		|byteidxcomp()| below for counting composing characters</pre>
<pre>		separately.</pre>
<pre>		Example : ></pre>
<pre>			echo matchstr(str, ".", byteidx(str, 3))</pre>
<		will display the fourth character.  Another way to do the
<pre>		same: ></pre>
<pre>			let s = strpart(str, byteidx(str, 3))</pre>
<pre>			echo strpart(s, 0, byteidx(s, 1))</pre>
<		Also see |strgetchar()| and |strcharpart()|.<p>

<pre>		If there are less than {nr} characters -1 is returned.</pre>
<pre>		If there are exactly {nr} characters the length of the string</pre>
<pre>		in bytes is returned.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetName()->byteidx(idx)<p></pre>

byteidxcomp({expr}, {nr})					*byteidxcomp()*
<pre>		Like byteidx(), except that a composing character is counted</pre>
<pre>		as a separate character.  Example: ></pre>
<pre>			let s = 'e' . nr2char(0x301)</pre>
<pre>			echo byteidx(s, 1)</pre>
<pre>			echo byteidxcomp(s, 1)</pre>
<pre>			echo byteidxcomp(s, 2)</pre>
<		The first and third echo result in 3 ('e' plus composing
<pre>		character is 3 bytes), the second echo results in 1 ('e' is</pre>
<pre>		one byte).</pre>
<pre>		Only works different from byteidx() when 'encoding' is set to</pre>
<pre>		a Unicode encoding.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetName()->byteidxcomp(idx)<p></pre>

call({func}, {arglist} [, {dict}])			*call()* *E699*
<pre>		Call function {func} with the items in |List| {arglist} as</pre>
<pre>		arguments.</pre>
<pre>		{func} can either be a |Funcref| or the name of a function.</pre>
<pre>		a:firstline and a:lastline are set to the cursor line.</pre>
<pre>		Returns the return value of the called function.</pre>
<pre>		{dict} is for functions with the "dict" attribute.  It will be</pre>
<pre>		used to set the local variable "self". |Dictionary-function|<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetFunc()->call([arg, arg], dict)<p></pre>

ceil({expr})							*ceil()*
<pre>		Return the smallest integral value greater than or equal to</pre>
<pre>		{expr} as a |Float| (round up).</pre>
<pre>		{expr} must evaluate to a |Float| or a |Number|.</pre>
<pre>		Examples: ></pre>
<pre>			echo ceil(1.456)</pre>
<			2.0  >
<pre>			echo ceil(-5.456)</pre>
<			-5.0  >
<pre>			echo ceil(4.0)</pre>
<			4.0<p>

<pre>		Can also be used as a |method|: ></pre>
<pre>			Compute()->ceil()</pre>
<
<pre>		{only available when compiled with the |+float| feature}<p></pre>


ch_ functions are documented here: |channel-functions-details|<p>


changenr()						*changenr()*
<pre>		Return the number of the most recent change.  This is the same</pre>
<pre>		number as what is displayed with |:undolist| and can be used</pre>
<pre>		with the |:undo| command.</pre>
<pre>		When a change was made it is the number of that change.  After</pre>
<pre>		redo it is the number of the redone change.  After undo it is</pre>
<pre>		one less than the number of the undone change.<p></pre>

char2nr({expr} [, {utf8}])					*char2nr()*
<pre>		Return number value of the first char in {expr}.  Examples: ></pre>
<pre>			char2nr(" ")		returns 32</pre>
<pre>			char2nr("ABC")		returns 65</pre>
<		When {utf8} is omitted or zero, the current 'encoding' is used.
<pre>		Example for "utf-8": ></pre>
<pre>			char2nr("á")		returns 225</pre>
<pre>			char2nr("á"[0])		returns 195</pre>
<		With {utf8} set to 1, always treat as utf-8 characters.
<pre>		A combining character is a separate character.</pre>
<pre>		|nr2char()| does the opposite.</pre>
<pre>		To turn a string into a list of character numbers: ></pre>
<pre>		    let str = "ABC"</pre>
<pre>		    let list = map(split(str, '\zs'), {_, val -> char2nr(val)})</pre>
<		Result: [65, 66, 67]<p>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetChar()->char2nr()<p></pre>

chdir({dir})						*chdir()*
<pre>		Change the current working directory to {dir}.  The scope of</pre>
<pre>		the directory change depends on the directory of the current</pre>
<pre>		window:</pre>
<pre>			- If the current window has a window-local directory</pre>
<pre>			  (|:lcd|), then changes the window local directory.</pre>
<pre>			- Otherwise, if the current tabpage has a local</pre>
<pre>			  directory (|:tcd|) then changes the tabpage local</pre>
<pre>			  directory.</pre>
<pre>			- Otherwise, changes the global directory.</pre>
<pre>		If successful, returns the previous working directory.  Pass</pre>
<pre>		this to another chdir() to restore the directory.</pre>
<pre>		On failure, returns an empty string.<p></pre>

<pre>		Example: ></pre>
<pre>			let save_dir = chdir(newdir)</pre>
<pre>			if save_dir != ""</pre>
<pre>			   " ... do some work</pre>
<pre>			   call chdir(save_dir)</pre>
<pre>			endif<p></pre>

<		Can also be used as a |method|: >
<pre>			GetDir()->chdir()</pre>
<
cindent({lnum})						*cindent()*
<pre>		Get the amount of indent for line {lnum} according the C</pre>
<pre>		indenting rules, as with 'cindent'.</pre>
<pre>		The indent is counted in spaces, the value of 'tabstop' is</pre>
<pre>		relevant.  {lnum} is used just like in |getline()|.</pre>
<pre>		When {lnum} is invalid or Vim was not compiled the |+cindent|</pre>
<pre>		feature, -1 is returned.</pre>
<pre>		See |C-indenting|.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetLnum()->cindent()<p></pre>

clearmatches([{win}])					*clearmatches()*
<pre>		Clears all matches previously defined for the current window</pre>
<pre>		by |matchadd()| and the |:match| commands.</pre>
<pre>		If {win} is specified, use the window with this number or</pre>
<pre>		window ID instead of the current window.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetWin()->clearmatches()</pre>
<
<pre>							*col()*</pre>
col({expr})	The result is a Number, which is the byte index of the column
<pre>		position given with {expr}.  The accepted positions are:</pre>
<pre>		    .	    the cursor position</pre>
<pre>		    $	    the end of the cursor line (the result is the</pre>
<pre>			    number of bytes in the cursor line plus one)</pre>
<pre>		    'x	    position of mark x (if the mark is not set, 0 is</pre>
<pre>			    returned)</pre>
<pre>		    v       In Visual mode: the start of the Visual area (the</pre>
<pre>			    cursor is the end).  When not in Visual mode</pre>
<pre>			    returns the cursor position.  Differs from |'<| in</pre>
<pre>			    that it's updated right away.</pre>
<pre>		Additionally {expr} can be [lnum, col]: a |List| with the line</pre>
<pre>		and column number. Most useful when the column is "$", to get</pre>
<pre>		the last column of a specific line.  When "lnum" or "col" is</pre>
<pre>		out of range then col() returns zero.</pre>
<pre>		To get the line number use |line()|.  To get both use</pre>
<pre>		|getpos()|.</pre>
<pre>		For the screen column position use |virtcol()|.</pre>
<pre>		Note that only marks in the current file can be used.</pre>
<pre>		Examples: ></pre>
<pre>			col(".")		column of cursor</pre>
<pre>			col("$")		length of cursor line plus one</pre>
<pre>			col("'t")		column of mark t</pre>
<pre>			col("'" . markname)	column of mark markname</pre>
<		The first column is 1.  0 is returned for an error.
<pre>		For an uppercase mark the column may actually be in another</pre>
<pre>		buffer.</pre>
<pre>		For the cursor position, when 'virtualedit' is active, the</pre>
<pre>		column is one higher if the cursor is after the end of the</pre>
<pre>		line.  This can be used to obtain the column in Insert mode: ></pre>
<pre>			:imap <F2> <C-O>:let save_ve = &ve<CR></pre>
<pre>				\<C-O>:set ve=all<CR></pre>
<pre>				\<C-O>:echo col(".") . "\n" <Bar></pre>
<pre>				\let &ve = save_ve<CR><p></pre>

<		Can also be used as a |method|: >
<pre>			GetPos()->col()</pre>
<<p>

complete({startcol}, {matches})			*complete()* *E785*
<pre>		Set the matches for Insert mode completion.</pre>
<pre>		Can only be used in Insert mode.  You need to use a mapping</pre>
<pre>		with CTRL-R = (see |i_CTRL-R|).  It does not work after CTRL-O</pre>
<pre>		or with an expression mapping.</pre>
<pre>		{startcol} is the byte offset in the line where the completed</pre>
<pre>		text start.  The text up to the cursor is the original text</pre>
<pre>		that will be replaced by the matches.  Use col('.') for an</pre>
<pre>		empty string.  "col('.') - 1" will replace one character by a</pre>
<pre>		match.</pre>
<pre>		{matches} must be a |List|.  Each |List| item is one match.</pre>
<pre>		See |complete-items| for the kind of items that are possible.</pre>
<pre>		Note that the after calling this function you need to avoid</pre>
<pre>		inserting anything that would cause completion to stop.</pre>
<pre>		The match can be selected with CTRL-N and CTRL-P as usual with</pre>
<pre>		Insert mode completion.  The popup menu will appear if</pre>
<pre>		specified, see |ins-completion-menu|.</pre>
<pre>		Example: ></pre>
<pre>	inoremap <F5> <C-R>=ListMonths()<CR><p></pre>

<pre>	func! ListMonths()</pre>
<pre>	  call complete(col('.'), ['January', 'February', 'March',</pre>
<pre>		\ 'April', 'May', 'June', 'July', 'August', 'September',</pre>
<pre>		\ 'October', 'November', 'December'])</pre>
<pre>	  return ''</pre>
<pre>	endfunc</pre>
<		This isn't very useful, but it shows how it works.  Note that
<pre>		an empty string is returned to avoid a zero being inserted.<p></pre>

<pre>		Can also be used as a |method|, the base is passed as the</pre>
<pre>		second argument: ></pre>
<pre>			GetMatches()->complete(col('.'))<p></pre>

complete_add({expr})				*complete_add()*
<pre>		Add {expr} to the list of matches.  Only to be used by the</pre>
<pre>		function specified with the 'completefunc' option.</pre>
<pre>		Returns 0 for failure (empty string or out of memory),</pre>
<pre>		1 when the match was added, 2 when the match was already in</pre>
<pre>		the list.</pre>
<pre>		See |complete-functions| for an explanation of {expr}.  It is</pre>
<pre>		the same as one item in the list that 'omnifunc' would return.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetMoreMatches()->complete_add()<p></pre>

complete_check()				*complete_check()*
<pre>		Check for a key typed while looking for completion matches.</pre>
<pre>		This is to be used when looking for matches takes some time.</pre>
<pre>		Returns |TRUE| when searching for matches is to be aborted,</pre>
<pre>		zero otherwise.</pre>
<pre>		Only to be used by the function specified with the</pre>
<pre>		'completefunc' option.<p></pre>

<pre>							*complete_info()*</pre>
complete_info([{what}])
<pre>		Returns a Dictionary with information about Insert mode</pre>
<pre>		completion.  See |ins-completion|.</pre>
<pre>		The items are:</pre>
<pre>		   mode		Current completion mode name string.</pre>
<pre>				See |complete_info_mode| for the values.</pre>
<pre>		   pum_visible	|TRUE| if popup menu is visible.</pre>
<pre>				See |pumvisible()|.</pre>
<pre>		   items	List of completion matches.  Each item is a</pre>
<pre>				dictionary containing the entries "word",</pre>
<pre>				"abbr", "menu", "kind", "info" and "user_data".</pre>
<pre>				See |complete-items|.</pre>
<pre>		   selected	Selected item index.  First index is zero.</pre>
<pre>				Index is -1 if no item is selected (showing</pre>
<pre>				typed text only)</pre>
<pre>		   inserted	Inserted string. [NOT IMPLEMENT YET]<p></pre>

<pre>							*complete_info_mode*</pre>
<pre>		mode values are:</pre>
<pre>		   ""		     Not in completion mode</pre>
<pre>		   "keyword"	     Keyword completion |i_CTRL-X_CTRL-N|</pre>
<pre>		   "ctrl_x"	     Just pressed CTRL-X |i_CTRL-X|</pre>
<pre>		   "whole_line"	     Whole lines |i_CTRL-X_CTRL-L|</pre>
<pre>		   "files"	     File names |i_CTRL-X_CTRL-F|</pre>
<pre>		   "tags"	     Tags |i_CTRL-X_CTRL-]|</pre>
<pre>		   "path_defines"    Definition completion |i_CTRL-X_CTRL-D|</pre>
<pre>		   "path_patterns"   Include completion |i_CTRL-X_CTRL-I|</pre>
<pre>		   "dictionary"	     Dictionary |i_CTRL-X_CTRL-K|</pre>
<pre>		   "thesaurus"	     Thesaurus |i_CTRL-X_CTRL-T|</pre>
<pre>		   "cmdline"	     Vim Command line |i_CTRL-X_CTRL-V|</pre>
<pre>		   "function"	     User defined completion |i_CTRL-X_CTRL-U|</pre>
<pre>		   "omni"	     Omni completion |i_CTRL-X_CTRL-O|</pre>
<pre>		   "spell"	     Spelling suggestions |i_CTRL-X_s|</pre>
<pre>		   "eval"            |complete()| completion</pre>
<pre>		   "unknown"	     Other internal modes<p></pre>

<pre>		If the optional {what} list argument is supplied, then only</pre>
<pre>		the items listed in {what} are returned.  Unsupported items in</pre>
<pre>		{what} are silently ignored.<p></pre>

<pre>		To get the position and size of the popup menu, see</pre>
<pre>		|pum_getpos()|. It's also available in |v:event| during the</pre>
<pre>		|CompleteChanged| event.<p></pre>

<pre>		Examples: ></pre>
<pre>			" Get all items</pre>
<pre>			call complete_info()</pre>
<pre>			" Get only 'mode'</pre>
<pre>			call complete_info(['mode'])</pre>
<pre>			" Get only 'mode' and 'pum_visible'</pre>
<pre>			call complete_info(['mode', 'pum_visible'])<p></pre>

<		Can also be used as a |method|: >
<pre>			GetItems()->complete_info()</pre>
<
<pre>						*confirm()*</pre>
confirm({msg} [, {choices} [, {default} [, {type}]]])
<pre>		confirm() offers the user a dialog, from which a choice can be</pre>
<pre>		made.  It returns the number of the choice.  For the first</pre>
<pre>		choice this is 1.</pre>
<pre>		Note: confirm() is only supported when compiled with dialog</pre>
<pre>		support, see |+dialog_con| and |+dialog_gui|.<p></pre>

<pre>		{msg} is displayed in a |dialog| with {choices} as the</pre>
<pre>		alternatives.  When {choices} is missing or empty, "&OK" is</pre>
<pre>		used (and translated).</pre>
<pre>		{msg} is a String, use '\n' to include a newline.  Only on</pre>
<pre>		some systems the string is wrapped when it doesn't fit.<p></pre>

<pre>		{choices} is a String, with the individual choices separated</pre>
<pre>		by '\n', e.g. ></pre>
<pre>			confirm("Save changes?", "&Yes\n&No\n&Cancel")</pre>
<		The letter after the '&' is the shortcut key for that choice.
<pre>		Thus you can type 'c' to select "Cancel".  The shortcut does</pre>
<pre>		not need to be the first letter: ></pre>
<pre>			confirm("file has been modified", "&Save\nSave &All")</pre>
<		For the console, the first letter of each choice is used as
<pre>		the default shortcut key.<p></pre>

<pre>		The optional {default} argument is the number of the choice</pre>
<pre>		that is made if the user hits <CR>.  Use 1 to make the first</pre>
<pre>		choice the default one.  Use 0 to not set a default.  If</pre>
<pre>		{default} is omitted, 1 is used.<p></pre>

<pre>		The optional {type} argument gives the type of dialog.  This</pre>
<pre>		is only used for the icon of the GTK, Mac, Motif and Win32</pre>
<pre>		GUI.  It can be one of these values: "Error", "Question",</pre>
<pre>		"Info", "Warning" or "Generic".  Only the first character is</pre>
<pre>		relevant.  When {type} is omitted, "Generic" is used.<p></pre>

<pre>		If the user aborts the dialog by pressing <Esc>, CTRL-C,</pre>
<pre>		or another valid interrupt key, confirm() returns 0.<p></pre>

<pre>		An example: ></pre>
<pre>   :let choice = confirm("What do you want?", "&Apples\n&Oranges\n&Bananas", 2)</pre>
<pre>   :if choice == 0</pre>
<pre>   :	echo "make up your mind!"</pre>
<pre>   :elseif choice == 3</pre>
<pre>   :	echo "tasteful"</pre>
<pre>   :else</pre>
<pre>   :	echo "I prefer bananas myself."</pre>
<pre>   :endif</pre>
<		In a GUI dialog, buttons are used.  The layout of the buttons
<pre>		depends on the 'v' flag in 'guioptions'.  If it is included,</pre>
<pre>		the buttons are always put vertically.  Otherwise,  confirm()</pre>
<pre>		tries to put the buttons in one horizontal line.  If they</pre>
<pre>		don't fit, a vertical layout is used anyway.  For some systems</pre>
<pre>		the horizontal layout is always used.<p></pre>

<pre>		Can also be used as a |method|in: ></pre>
<pre>			BuildMessage()->confirm("&Yes\n&No")</pre>
<
<pre>							*copy()*</pre>
copy({expr})	Make a copy of {expr}.  For Numbers and Strings this isn't
<pre>		different from using {expr} directly.</pre>
<pre>		When {expr} is a |List| a shallow copy is created.  This means</pre>
<pre>		that the original |List| can be changed without changing the</pre>
<pre>		copy, and vice versa.  But the items are identical, thus</pre>
<pre>		changing an item changes the contents of both |Lists|.</pre>
<pre>		A |Dictionary| is copied in a similar way as a |List|.</pre>
<pre>		Also see |deepcopy()|.</pre>
<pre>		Can also be used as a |method|: ></pre>
<pre>			mylist->copy()<p></pre>

cos({expr})						*cos()*
<pre>		Return the cosine of {expr}, measured in radians, as a |Float|.</pre>
<pre>		{expr} must evaluate to a |Float| or a |Number|.</pre>
<pre>		Examples: ></pre>
<pre>			:echo cos(100)</pre>
<			0.862319 >
<pre>			:echo cos(-4.01)</pre>
<			-0.646043<p>

<pre>		Can also be used as a |method|: ></pre>
<pre>			Compute()->cos()</pre>
<
<pre>		{only available when compiled with the |+float| feature}<p></pre>


cosh({expr})						*cosh()*
<pre>		Return the hyperbolic cosine of {expr} as a |Float| in the range</pre>
<pre>		[1, inf].</pre>
<pre>		{expr} must evaluate to a |Float| or a |Number|.</pre>
<pre>		Examples: ></pre>
<pre>			:echo cosh(0.5)</pre>
<			1.127626 >
<pre>			:echo cosh(-0.5)</pre>
<			-1.127626<p>

<pre>		Can also be used as a |method|: ></pre>
<pre>			Compute()->cosh()</pre>
<
<pre>		{only available when compiled with the |+float| feature}<p></pre>


count({comp}, {expr} [, {ic} [, {start}]])			*count()*
<pre>		Return the number of times an item with value {expr} appears</pre>
<pre>		in |String|, |List| or |Dictionary| {comp}.<p></pre>

<pre>		If {start} is given then start with the item with this index.</pre>
<pre>		{start} can only be used with a |List|.<p></pre>

<pre>		When {ic} is given and it's |TRUE| then case is ignored.<p></pre>

<pre>		When {comp} is a string then the number of not overlapping</pre>
<pre>		occurrences of {expr} is returned. Zero is returned when</pre>
<pre>		{expr} is an empty string.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			mylist->count(val)</pre>
<
<pre>							*cscope_connection()*</pre>
cscope_connection([{num} , {dbpath} [, {prepend}]])
<pre>		Checks for the existence of a |cscope| connection.  If no</pre>
<pre>		parameters are specified, then the function returns:</pre>
<pre>			0, if cscope was not available (not compiled in), or</pre>
<pre>			   if there are no cscope connections;</pre>
<pre>			1, if there is at least one cscope connection.<p></pre>

<pre>		If parameters are specified, then the value of {num}</pre>
<pre>		determines how existence of a cscope connection is checked:<p></pre>

<pre>		{num}	Description of existence check</pre>
<pre>		-----	------------------------------</pre>
<pre>		0	Same as no parameters (e.g., "cscope_connection()").</pre>
<pre>		1	Ignore {prepend}, and use partial string matches for</pre>
<pre>			{dbpath}.</pre>
<pre>		2	Ignore {prepend}, and use exact string matches for</pre>
<pre>			{dbpath}.</pre>
<pre>		3	Use {prepend}, use partial string matches for both</pre>
<pre>			{dbpath} and {prepend}.</pre>
<pre>		4	Use {prepend}, use exact string matches for both</pre>
<pre>			{dbpath} and {prepend}.<p></pre>

<pre>		Note: All string comparisons are case sensitive!<p></pre>

<pre>		Examples.  Suppose we had the following (from ":cs show"): ><p></pre>

<pre>  # pid    database name			prepend path</pre>
<pre>  0 27664  cscope.out				/usr/local</pre>
<
<pre>		Invocation					Return Val ~</pre>
<pre>		----------					---------- ></pre>
<pre>		cscope_connection()					1</pre>
<pre>		cscope_connection(1, "out")				1</pre>
<pre>		cscope_connection(2, "out")				0</pre>
<pre>		cscope_connection(3, "out")				0</pre>
<pre>		cscope_connection(3, "out", "local")			1</pre>
<pre>		cscope_connection(4, "out")				0</pre>
<pre>		cscope_connection(4, "out", "local")			0</pre>
<pre>		cscope_connection(4, "cscope.out", "/usr/local")	1</pre>
<
cursor({lnum}, {col} [, {off}])				*cursor()*
cursor({list})
<pre>		Positions the cursor at the column (byte count) {col} in the</pre>
<pre>		line {lnum}.  The first column is one.<p></pre>

<pre>		When there is one argument {list} this is used as a |List|</pre>
<pre>		with two, three or four item:</pre>
<pre>			[{lnum}, {col}]</pre>
<pre>			[{lnum}, {col}, {off}]</pre>
<pre>			[{lnum}, {col}, {off}, {curswant}]</pre>
<pre>		This is like the return value of |getpos()| or |getcurpos()|,</pre>
<pre>		but without the first item.<p></pre>

<pre>		Does not change the jumplist.</pre>
<pre>		If {lnum} is greater than the number of lines in the buffer,</pre>
<pre>		the cursor will be positioned at the last line in the buffer.</pre>
<pre>		If {lnum} is zero, the cursor will stay in the current line.</pre>
<pre>		If {col} is greater than the number of bytes in the line,</pre>
<pre>		the cursor will be positioned at the last character in the</pre>
<pre>		line.</pre>
<pre>		If {col} is zero, the cursor will stay in the current column.</pre>
<pre>		If {curswant} is given it is used to set the preferred column</pre>
<pre>		for vertical movement.  Otherwise {col} is used.<p></pre>

<pre>		When 'virtualedit' is used {off} specifies the offset in</pre>
<pre>		screen columns from the start of the character.  E.g., a</pre>
<pre>		position within a <Tab> or after the last character.</pre>
<pre>		Returns 0 when the position could be set, -1 otherwise.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetCursorPos()->cursor()<p></pre>

debugbreak({pid})					*debugbreak()*
<pre>		Specifically used to interrupt a program being debugged.  It</pre>
<pre>		will cause process {pid} to get a SIGTRAP.  Behavior for other</pre>
<pre>		processes is undefined. See |terminal-debugger|.</pre>
<pre>		{only available on MS-Windows}<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetPid()->debugbreak()<p></pre>

deepcopy({expr} [, {noref}])				*deepcopy()* *E698*
<pre>		Make a copy of {expr}.  For Numbers and Strings this isn't</pre>
<pre>		different from using {expr} directly.</pre>
<pre>		When {expr} is a |List| a full copy is created.  This means</pre>
<pre>		that the original |List| can be changed without changing the</pre>
<pre>		copy, and vice versa.  When an item is a |List| or</pre>
<pre>		|Dictionary|, a copy for it is made, recursively.  Thus</pre>
<pre>		changing an item in the copy does not change the contents of</pre>
<pre>		the original |List|.</pre>
<pre>		A |Dictionary| is copied in a similar way as a |List|.</pre>
<pre>		When {noref} is omitted or zero a contained |List| or</pre>
<pre>		|Dictionary| is only copied once.  All references point to</pre>
<pre>		this single copy.  With {noref} set to 1 every occurrence of a</pre>
<pre>		|List| or |Dictionary| results in a new copy.  This also means</pre>
<pre>		that a cyclic reference causes deepcopy() to fail.</pre>
<pre>								*E724*</pre>
<pre>		Nesting is possible up to 100 levels.  When there is an item</pre>
<pre>		that refers back to a higher level making a deep copy with</pre>
<pre>		{noref} set to 1 will fail.</pre>
<pre>		Also see |copy()|.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetObject()->deepcopy()<p></pre>

delete({fname} [, {flags}])					*delete()*
<pre>		Without {flags} or with {flags} empty: Deletes the file by the</pre>
<pre>		name {fname}.  This also works when {fname} is a symbolic link.<p></pre>

<pre>		When {flags} is "d": Deletes the directory by the name</pre>
<pre>		{fname}.  This fails when directory {fname} is not empty.<p></pre>

<pre>		When {flags} is "rf": Deletes the directory by the name</pre>
<pre>		{fname} and everything in it, recursively.  BE CAREFUL!</pre>
<pre>		Note: on MS-Windows it is not possible to delete a directory</pre>
<pre>		that is being used.<p></pre>

<pre>		A symbolic link itself is deleted, not what it points to.<p></pre>

<pre>		The result is a Number, which is 0 if the delete operation was</pre>
<pre>		successful and -1 when the deletion failed or partly failed.<p></pre>

<pre>		Use |remove()| to delete an item from a |List|.</pre>
<pre>		To delete a line from the buffer use |:delete| or</pre>
<pre>		|deletebufline()|.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetName()->delete()<p></pre>

deletebufline({expr}, {first} [, {last}])		*deletebufline()*
<pre>		Delete lines {first} to {last} (inclusive) from buffer {expr}.</pre>
<pre>		If {last} is omitted then delete line {first} only.</pre>
<pre>		On success 0 is returned, on failure 1 is returned.<p></pre>

<pre>		This function works only for loaded buffers. First call</pre>
<pre>		|bufload()| if needed.<p></pre>

<pre>		For the use of {expr}, see |bufname()| above.<p></pre>

<pre>		{first} and {last} are used like with |getline()|. Note that</pre>
<pre>		when using |line()| this refers to the current buffer. Use "$"</pre>
<pre>		to refer to the last line in buffer {expr}.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetBuffer()->deletebufline(1)</pre>
<
<pre>							*did_filetype()*</pre>
did_filetype()	Returns |TRUE| when autocommands are being executed and the
<pre>		FileType event has been triggered at least once.  Can be used</pre>
<pre>		to avoid triggering the FileType event again in the scripts</pre>
<pre>		that detect the file type. |FileType|</pre>
<pre>		Returns |FALSE| when `:setf FALLBACK` was used.</pre>
<pre>		When editing another file, the counter is reset, thus this</pre>
<pre>		really checks if the FileType event has been triggered for the</pre>
<pre>		current buffer.  This allows an autocommand that starts</pre>
<pre>		editing another buffer to set 'filetype' and load a syntax</pre>
<pre>		file.<p></pre>

diff_filler({lnum})					*diff_filler()*
<pre>		Returns the number of filler lines above line {lnum}.</pre>
<pre>		These are the lines that were inserted at this point in</pre>
<pre>		another diff'ed window.  These filler lines are shown in the</pre>
<pre>		display but don't exist in the buffer.</pre>
<pre>		{lnum} is used like with |getline()|.  Thus "." is the current</pre>
<pre>		line, "'m" mark m, etc.</pre>
<pre>		Returns 0 if the current window is not in diff mode.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetLnum()->diff_filler()<p></pre>

diff_hlID({lnum}, {col})				*diff_hlID()*
<pre>		Returns the highlight ID for diff mode at line {lnum} column</pre>
<pre>		{col} (byte index).  When the current line does not have a</pre>
<pre>		diff change zero is returned.</pre>
<pre>		{lnum} is used like with |getline()|.  Thus "." is the current</pre>
<pre>		line, "'m" mark m, etc.</pre>
<pre>		{col} is 1 for the leftmost column, {lnum} is 1 for the first</pre>
<pre>		line.</pre>
<pre>		The highlight ID can be used with |synIDattr()| to obtain</pre>
<pre>		syntax information about the highlighting.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetLnum()->diff_hlID(col)</pre>
environ()						*environ()*
<pre>		Return all of environment variables as dictionary. You can</pre>
<pre>		check if an environment variable exists like this: ></pre>
<pre>			:echo has_key(environ(), 'HOME')</pre>
<		Note that the variable name may be CamelCase; to ignore case
<pre>		use this: ></pre>
<pre>			:echo index(keys(environ()), 'HOME', 0, 1) != -1<p></pre>

empty({expr})						*empty()*
<pre>		Return the Number 1 if {expr} is empty, zero otherwise.</pre>
<pre>		- A |List| or |Dictionary| is empty when it does not have any</pre>
<pre>		  items.</pre>
<pre>		- A |String| is empty when its length is zero.</pre>
<pre>		- A |Number| and |Float| are empty when their value is zero.</pre>
<pre>		- |v:false|, |v:none| and |v:null| are empty, |v:true| is not.</pre>
<pre>		- A |Job| is empty when it failed to start.</pre>
<pre>		- A |Channel| is empty when it is closed.</pre>
<pre>		- A |Blob| is empty when its length is zero.<p></pre>

<pre>		For a long |List| this is much faster than comparing the</pre>
<pre>		length with zero.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			mylist->empty()<p></pre>

escape({string}, {chars})				*escape()*
<pre>		Escape the characters in {chars} that occur in {string} with a</pre>
<pre>		backslash.  Example: ></pre>
<pre>			:echo escape('c:\program files\vim', ' \')</pre>
<		results in: >
<pre>			c:\\program\ files\\vim</pre>
<		Also see |shellescape()| and |fnameescape()|.<p>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetText()->escape(' \')</pre>
<
<pre>							*eval()*</pre>
eval({string})	Evaluate {string} and return the result.  Especially useful to
<pre>		turn the result of |string()| back into the original value.</pre>
<pre>		This works for Numbers, Floats, Strings, Blobs and composites</pre>
<pre>		of them.  Also works for |Funcref|s that refer to existing</pre>
<pre>		functions.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			argv->join()->eval()<p></pre>

eventhandler()						*eventhandler()*
<pre>		Returns 1 when inside an event handler.  That is that Vim got</pre>
<pre>		interrupted while waiting for the user to type a character,</pre>
<pre>		e.g., when dropping a file on Vim.  This means interactive</pre>
<pre>		commands cannot be used.  Otherwise zero is returned.<p></pre>

executable({expr})					*executable()*
<pre>		This function checks if an executable with the name {expr}</pre>
<pre>		exists.  {expr} must be the name of the program without any</pre>
<pre>		arguments.</pre>
<pre>		executable() uses the value of $PATH and/or the normal</pre>
<pre>		searchpath for programs.		*PATHEXT*</pre>
<pre>		On MS-DOS and MS-Windows the ".exe", ".bat", etc. can</pre>
<pre>		optionally be included.  Then the extensions in $PATHEXT are</pre>
<pre>		tried.  Thus if "foo.exe" does not exist, "foo.exe.bat" can be</pre>
<pre>		found.  If $PATHEXT is not set then ".exe;.com;.bat;.cmd" is</pre>
<pre>		used.  A dot by itself can be used in $PATHEXT to try using</pre>
<pre>		the name without an extension.  When 'shell' looks like a</pre>
<pre>		Unix shell, then the name is also tried without adding an</pre>
<pre>		extension.</pre>
<pre>		On MS-DOS and MS-Windows it only checks if the file exists and</pre>
<pre>		is not a directory, not if it's really executable.</pre>
<pre>		On MS-Windows an executable in the same directory as Vim is</pre>
<pre>		always found.  Since this directory is added to $PATH it</pre>
<pre>		should also work to execute it |win32-PATH|.</pre>
<pre>		The result is a Number:</pre>
<pre>			1	exists</pre>
<pre>			0	does not exist</pre>
<pre>			-1	not implemented on this system</pre>
<pre>		|exepath()| can be used to get the full path of an executable.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetCommand()->executable()<p></pre>

execute({command} [, {silent}])					*execute()*
<pre>		Execute an Ex command or commands and return the output as a</pre>
<pre>		string.</pre>
<pre>		{command} can be a string or a List.  In case of a List the</pre>
<pre>		lines are executed one by one.</pre>
<pre>		This is equivalent to: ></pre>
<pre>			redir => var</pre>
<pre>			{command}</pre>
<pre>			redir END</pre>
<
<pre>		The optional {silent} argument can have these values:</pre>
<pre>			""		no `:silent` used</pre>
<pre>			"silent"	`:silent` used</pre>
<pre>			"silent!"	`:silent!` used</pre>
<pre>		The default is "silent".  Note that with "silent!", unlike</pre>
<pre>		`:redir`, error messages are dropped.  When using an external</pre>
<pre>		command the screen may be messed up, use `system()` instead.</pre>
<pre>							*E930*</pre>
<pre>		It is not possible to use `:redir` anywhere in {command}.<p></pre>

<pre>		To get a list of lines use |split()| on the result: ></pre>
<pre>			split(execute('args'), "\n")<p></pre>

<		To execute a command in another window than the current one
<pre>		use `win_execute()`.<p></pre>

<pre>		When used recursively the output of the recursive call is not</pre>
<pre>		included in the output of the higher level call.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetCommand()->execute()<p></pre>

exepath({expr})						*exepath()*
<pre>		If {expr} is an executable and is either an absolute path, a</pre>
<pre>		relative path or found in $PATH, return the full path.</pre>
<pre>		Note that the current directory is used when {expr} starts</pre>
<pre>		with "./", which may be a problem for Vim: ></pre>
<pre>			echo exepath(v:progpath)</pre>
<		If {expr} cannot be found in $PATH or is not executable then
<pre>		an empty string is returned.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetCommand()->exepath()</pre>
<
<pre>							*exists()*</pre>
exists({expr})	The result is a Number, which is |TRUE| if {expr} is defined,
<pre>		zero otherwise.<p></pre>

<pre>		For checking for a supported feature use |has()|.</pre>
<pre>		For checking if a file exists use |filereadable()|.<p></pre>

<pre>		The {expr} argument is a string, which contains one of these:</pre>
<pre>			&option-name	Vim option (only checks if it exists,</pre>
<pre>					not if it really works)</pre>
<pre>			+option-name	Vim option that works.</pre>
<pre>			$ENVNAME	environment variable (could also be</pre>
<pre>					done by comparing with an empty</pre>
<pre>					string)</pre>
<pre>			*funcname	built-in function (see |functions|)</pre>
<pre>					or user defined function (see</pre>
<pre>					|user-functions|). Also works for a</pre>
<pre>					variable that is a Funcref.</pre>
<pre>			varname		internal variable (see</pre>
<pre>					|internal-variables|).  Also works</pre>
<pre>					for |curly-braces-names|, |Dictionary|</pre>
<pre>					entries, |List| items, etc.  Beware</pre>
<pre>					that evaluating an index may cause an</pre>
<pre>					error message for an invalid</pre>
<pre>					expression.  E.g.: ></pre>
<pre>					   :let l = [1, 2, 3]</pre>
<pre>					   :echo exists("l[5]")</pre>
<					   0 >
<pre>					   :echo exists("l[xx]")</pre>
<					   E121: Undefined variable: xx
<pre>					   0</pre>
<pre>			:cmdname	Ex command: built-in command, user</pre>
<pre>					command or command modifier |:command|.</pre>
<pre>					Returns:</pre>
<pre>					1  for match with start of a command</pre>
<pre>					2  full match with a command</pre>
<pre>					3  matches several user commands</pre>
<pre>					To check for a supported command</pre>
<pre>					always check the return value to be 2.</pre>
<pre>			:2match		The |:2match| command.</pre>
<pre>			:3match		The |:3match| command.</pre>
<pre>			#event		autocommand defined for this event</pre>
<pre>			#event#pattern	autocommand defined for this event and</pre>
<pre>					pattern (the pattern is taken</pre>
<pre>					literally and compared to the</pre>
<pre>					autocommand patterns character by</pre>
<pre>					character)</pre>
<pre>			#group		autocommand group exists</pre>
<pre>			#group#event	autocommand defined for this group and</pre>
<pre>					event.</pre>
<pre>			#group#event#pattern</pre>
<pre>					autocommand defined for this group,</pre>
<pre>					event and pattern.</pre>
<pre>			##event		autocommand for this event is</pre>
<pre>					supported.<p></pre>

<pre>		Examples: ></pre>
<pre>			exists("&shortname")</pre>
<pre>			exists("$HOSTNAME")</pre>
<pre>			exists("*strftime")</pre>
<pre>			exists("*s:MyFunc")</pre>
<pre>			exists("bufcount")</pre>
<pre>			exists(":Make")</pre>
<pre>			exists("#CursorHold")</pre>
<pre>			exists("#BufReadPre#*.gz")</pre>
<pre>			exists("#filetypeindent")</pre>
<pre>			exists("#filetypeindent#FileType")</pre>
<pre>			exists("#filetypeindent#FileType#*")</pre>
<pre>			exists("##ColorScheme")</pre>
<		There must be no space between the symbol (&/$/*/#) and the
<pre>		name.</pre>
<pre>		There must be no extra characters after the name, although in</pre>
<pre>		a few cases this is ignored.  That may become more strict in</pre>
<pre>		the future, thus don't count on it!</pre>
<pre>		Working example: ></pre>
<pre>			exists(":make")</pre>
<		NOT working example: >
<pre>			exists(":make install")<p></pre>

<		Note that the argument must be a string, not the name of the
<pre>		variable itself.  For example: ></pre>
<pre>			exists(bufcount)</pre>
<		This doesn't check for existence of the "bufcount" variable,
<pre>		but gets the value of "bufcount", and checks if that exists.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			Varname()->exists()<p></pre>

exp({expr})						*exp()*
<pre>		Return the exponential of {expr} as a |Float| in the range</pre>
<pre>		[0, inf].</pre>
<pre>		{expr} must evaluate to a |Float| or a |Number|.</pre>
<pre>		Examples: ></pre>
<pre>			:echo exp(2)</pre>
<			7.389056 >
<pre>			:echo exp(-1)</pre>
<			0.367879<p>

<pre>		Can also be used as a |method|: ></pre>
<pre>			Compute()->exp()</pre>
<
<pre>		{only available when compiled with the |+float| feature}<p></pre>


expand({expr} [, {nosuf} [, {list}]])				*expand()*
<pre>		Expand wildcards and the following special keywords in {expr}.</pre>
<pre>		'wildignorecase' applies.<p></pre>

<pre>		If {list} is given and it is |TRUE|, a List will be returned.</pre>
<pre>		Otherwise the result is a String and when there are several</pre>
<pre>		matches, they are separated by <NL> characters.  [Note: in</pre>
<pre>		version 5.0 a space was used, which caused problems when a</pre>
<pre>		file name contains a space]<p></pre>

<pre>		If the expansion fails, the result is an empty string.  A name</pre>
<pre>		for a non-existing file is not included, unless {expr} does</pre>
<pre>		not start with '%', '#' or '<', see below.<p></pre>

<pre>		When {expr} starts with '%', '#' or '<', the expansion is done</pre>
<pre>		like for the |cmdline-special| variables with their associated</pre>
<pre>		modifiers.  Here is a short overview:<p></pre>

<pre>			%		current file name</pre>
<pre>			#		alternate file name</pre>
<pre>			#n		alternate file name n</pre>
<pre>			<cfile>		file name under the cursor</pre>
<pre>			<afile>		autocmd file name</pre>
<pre>			<abuf>		autocmd buffer number (as a String!)</pre>
<pre>			<amatch>	autocmd matched name</pre>
<pre>			<sfile>		sourced script file or function name</pre>
<pre>			<slnum>		sourced script line number or function</pre>
<pre>					line number</pre>
<pre>			<sflnum>	script file line number, also when in</pre>
<pre>					a function</pre>
<pre>			<cword>		word under the cursor</pre>
<pre>			<cWORD>		WORD under the cursor</pre>
<pre>			<client>	the {clientid} of the last received</pre>
<pre>					message |server2client()|</pre>
<pre>		Modifiers:</pre>
<pre>			:p		expand to full path</pre>
<pre>			:h		head (last path component removed)</pre>
<pre>			:t		tail (last path component only)</pre>
<pre>			:r		root (one extension removed)</pre>
<pre>			:e		extension only<p></pre>

<pre>		Example: ></pre>
<pre>			:let &tags = expand("%:p:h") . "/tags"</pre>
<		Note that when expanding a string that starts with '%', '#' or
<pre>		'<', any following text is ignored.  This does NOT work: ></pre>
<pre>			:let doesntwork = expand("%:h.bak")</pre>
<		Use this: >
<pre>			:let doeswork = expand("%:h") . ".bak"</pre>
<		Also note that expanding "<cfile>" and others only returns the
<pre>		referenced file name without further expansion.  If "<cfile>"</pre>
<pre>		is "~/.cshrc", you need to do another expand() to have the</pre>
<pre>		"~/" expanded into the path of the home directory: ></pre>
<pre>			:echo expand(expand("<cfile>"))</pre>
<
<pre>		There cannot be white space between the variables and the</pre>
<pre>		following modifier.  The |fnamemodify()| function can be used</pre>
<pre>		to modify normal file names.<p></pre>

<pre>		When using '%' or '#', and the current or alternate file name</pre>
<pre>		is not defined, an empty string is used.  Using "%:p" in a</pre>
<pre>		buffer with no name, results in the current directory, with a</pre>
<pre>		'/' added.<p></pre>

<pre>		When {expr} does not start with '%', '#' or '<', it is</pre>
<pre>		expanded like a file name is expanded on the command line.</pre>
<pre>		'suffixes' and 'wildignore' are used, unless the optional</pre>
<pre>		{nosuf} argument is given and it is |TRUE|.</pre>
<pre>		Names for non-existing files are included.  The "**" item can</pre>
<pre>		be used to search in a directory tree.  For example, to find</pre>
<pre>		all "README" files in the current directory and below: ></pre>
<pre>			:echo expand("**/README")</pre>
<
<pre>		expand() can also be used to expand variables and environment</pre>
<pre>		variables that are only known in a shell.  But this can be</pre>
<pre>		slow, because a shell may be used to do the expansion.  See</pre>
<pre>		|expr-env-expand|.</pre>
<pre>		The expanded variable is still handled like a list of file</pre>
<pre>		names.  When an environment variable cannot be expanded, it is</pre>
<pre>		left unchanged.  Thus ":echo expand('$FOOBAR')" results in</pre>
<pre>		"$FOOBAR".<p></pre>

<pre>		See |glob()| for finding existing files.  See |system()| for</pre>
<pre>		getting the raw output of an external command.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			Getpattern()->expand()<p></pre>

expandcmd({expr})					*expandcmd()*
<pre>		Expand special items in {expr} like what is done for an Ex</pre>
<pre>		command such as `:edit`.  This expands special keywords, like</pre>
<pre>		with |expand()|, and environment variables, anywhere in</pre>
<pre>		{expr}.  "~user" and "~/path" are only expanded at the start.</pre>
<pre>		Returns the expanded string.  Example: ></pre>
<pre>			:echo expandcmd('make %<.o')<p></pre>

<		Can also be used as a |method|: >
<pre>			GetCommand()->expandcmd()</pre>
<
extend({expr1}, {expr2} [, {expr3}])			*extend()*
<pre>		{expr1} and {expr2} must be both |Lists| or both</pre>
<pre>		|Dictionaries|.<p></pre>

<pre>		If they are |Lists|: Append {expr2} to {expr1}.</pre>
<pre>		If {expr3} is given insert the items of {expr2} before item</pre>
<pre>		{expr3} in {expr1}.  When {expr3} is zero insert before the</pre>
<pre>		first item.  When {expr3} is equal to len({expr1}) then</pre>
<pre>		{expr2} is appended.</pre>
<pre>		Examples: ></pre>
<pre>			:echo sort(extend(mylist, [7, 5]))</pre>
<pre>			:call extend(mylist, [2, 3], 1)</pre>
<		When {expr1} is the same List as {expr2} then the number of
<pre>		items copied is equal to the original length of the List.</pre>
<pre>		E.g., when {expr3} is 1 you get N new copies of the first item</pre>
<pre>		(where N is the original length of the List).</pre>
<pre>		Use |add()| to concatenate one item to a list.  To concatenate</pre>
<pre>		two lists into a new list use the + operator: ></pre>
<pre>			:let newlist = [1, 2, 3] + [4, 5]</pre>
<
<pre>		If they are |Dictionaries|:</pre>
<pre>		Add all entries from {expr2} to {expr1}.</pre>
<pre>		If a key exists in both {expr1} and {expr2} then {expr3} is</pre>
<pre>		used to decide what to do:</pre>
<pre>		{expr3} = "keep": keep the value of {expr1}</pre>
<pre>		{expr3} = "force": use the value of {expr2}</pre>
<pre>		{expr3} = "error": give an error message		*E737*</pre>
<pre>		When {expr3} is omitted then "force" is assumed.<p></pre>

<pre>		{expr1} is changed when {expr2} is not empty.  If necessary</pre>
<pre>		make a copy of {expr1} first.</pre>
<pre>		{expr2} remains unchanged.</pre>
<pre>		When {expr1} is locked and {expr2} is not empty the operation</pre>
<pre>		fails.</pre>
<pre>		Returns {expr1}.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			mylist->extend(otherlist)<p></pre>


feedkeys({string} [, {mode}])				*feedkeys()*
<pre>		Characters in {string} are queued for processing as if they</pre>
<pre>		come from a mapping or were typed by the user.<p></pre>

<pre>		By default the string is added to the end of the typeahead</pre>
<pre>		buffer, thus if a mapping is still being executed the</pre>
<pre>		characters come after them.  Use the 'i' flag to insert before</pre>
<pre>		other characters, they will be executed next, before any</pre>
<pre>		characters from a mapping.<p></pre>

<pre>		The function does not wait for processing of keys contained in</pre>
<pre>		{string}.<p></pre>

<pre>		To include special keys into {string}, use double-quotes</pre>
<pre>		and "\..." notation |expr-quote|. For example,</pre>
<pre>		feedkeys("\<CR>") simulates pressing of the <Enter> key. But</pre>
<pre>		feedkeys('\<CR>') pushes 5 characters.</pre>
<pre>		A special code that might be useful is <Ignore>, it exits the</pre>
<pre>		wait for a character without doing anything.  *<Ignore>*<p></pre>

<pre>		{mode} is a String, which can contain these character flags:</pre>
<pre>		'm'	Remap keys. This is default.  If {mode} is absent,</pre>
<pre>			keys are remapped.</pre>
<pre>		'n'	Do not remap keys.</pre>
<pre>		't'	Handle keys as if typed; otherwise they are handled as</pre>
<pre>			if coming from a mapping.  This matters for undo,</pre>
<pre>			opening folds, etc.</pre>
<pre>		'L'	Lowlevel input.  Only works for Unix or when using the</pre>
<pre>			GUI. Keys are used as if they were coming from the</pre>
<pre>			terminal.  Other flags are not used.  *E980*</pre>
<pre>		'i'	Insert the string instead of appending (see above).</pre>
<pre>		'x'	Execute commands until typeahead is empty.  This is</pre>
<pre>			similar to using ":normal!".  You can call feedkeys()</pre>
<pre>			several times without 'x' and then one time with 'x'</pre>
<pre>			(possibly with an empty {string}) to execute all the</pre>
<pre>			typeahead.  Note that when Vim ends in Insert mode it</pre>
<pre>			will behave as if <Esc> is typed, to avoid getting</pre>
<pre>			stuck, waiting for a character to be typed before the</pre>
<pre>			script continues.</pre>
<pre>			Note that if you manage to call feedkeys() while</pre>
<pre>			executing commands, thus calling it recursively, then</pre>
<pre>			all typehead will be consumed by the last call.</pre>
<pre>		'!'	When used with 'x' will not end Insert mode. Can be</pre>
<pre>			used in a test when a timer is set to exit Insert mode</pre>
<pre>			a little later.  Useful for testing CursorHoldI.<p></pre>

<pre>		Return value is always 0.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetInput()->feedkeys()<p></pre>

filereadable({file})					*filereadable()*
<pre>		The result is a Number, which is |TRUE| when a file with the</pre>
<pre>		name {file} exists, and can be read.  If {file} doesn't exist,</pre>
<pre>		or is a directory, the result is |FALSE|.  {file} is any</pre>
<pre>		expression, which is used as a String.</pre>
<pre>		If you don't care about the file being readable you can use</pre>
<pre>		|glob()|.</pre>
<pre>		{file} is used as-is, you may want to expand wildcards first: ></pre>
<pre>			echo filereadable('~/.vimrc')</pre>
<pre>			0</pre>
<pre>			echo filereadable(expand('~/.vimrc'))</pre>
<pre>			1<p></pre>

<		Can also be used as a |method|: >
<pre>			GetName()->filereadable()</pre>
<							*file_readable()*
<pre>		Obsolete name: file_readable().<p></pre>


filewritable({file})					*filewritable()*
<pre>		The result is a Number, which is 1 when a file with the</pre>
<pre>		name {file} exists, and can be written.  If {file} doesn't</pre>
<pre>		exist, or is not writable, the result is 0.  If {file} is a</pre>
<pre>		directory, and we can write to it, the result is 2.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetName()->filewriteable()<p></pre>


filter({expr1}, {expr2})				*filter()*
<pre>		{expr1} must be a |List| or a |Dictionary|.</pre>
<pre>		For each item in {expr1} evaluate {expr2} and when the result</pre>
<pre>		is zero remove the item from the |List| or |Dictionary|.</pre>
<pre>		{expr2} must be a |string| or |Funcref|.<p></pre>

<pre>		If {expr2} is a |string|, inside {expr2} |v:val| has the value</pre>
<pre>		of the current item.  For a |Dictionary| |v:key| has the key</pre>
<pre>		of the current item and for a |List| |v:key| has the index of</pre>
<pre>		the current item.</pre>
<pre>		Examples: ></pre>
<pre>			call filter(mylist, 'v:val !~ "OLD"')</pre>
<		Removes the items where "OLD" appears. >
<pre>			call filter(mydict, 'v:key >= 8')</pre>
<		Removes the items with a key below 8. >
<pre>			call filter(var, 0)</pre>
<		Removes all the items, thus clears the |List| or |Dictionary|.<p>

<pre>		Note that {expr2} is the result of expression and is then</pre>
<pre>		used as an expression again.  Often it is good to use a</pre>
<pre>		|literal-string| to avoid having to double backslashes.<p></pre>

<pre>		If {expr2} is a |Funcref| it must take two arguments:</pre>
<pre>			1. the key or the index of the current item.</pre>
<pre>			2. the value of the current item.</pre>
<pre>		The function must return |TRUE| if the item should be kept.</pre>
<pre>		Example that keeps the odd items of a list: ></pre>
<pre>			func Odd(idx, val)</pre>
<pre>			  return a:idx % 2 == 1</pre>
<pre>			endfunc</pre>
<pre>			call filter(mylist, function('Odd'))</pre>
<		It is shorter when using a |lambda|: >
<pre>			call filter(myList, {idx, val -> idx * val <= 42})</pre>
<		If you do not use "val" you can leave it out: >
<pre>			call filter(myList, {idx -> idx % 2 == 1})</pre>
<
<pre>		The operation is done in-place.  If you want a |List| or</pre>
<pre>		|Dictionary| to remain unmodified make a copy first: ></pre>
<pre>			:let l = filter(copy(mylist), 'v:val =~ "KEEP"')<p></pre>

<		Returns {expr1}, the |List| or |Dictionary| that was filtered.
<pre>		When an error is encountered while evaluating {expr2} no</pre>
<pre>		further items in {expr1} are processed.  When {expr2} is a</pre>
<pre>		Funcref errors inside a function are ignored, unless it was</pre>
<pre>		defined with the "abort" flag.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			mylist->filter(expr2)<p></pre>

finddir({name} [, {path} [, {count}]])				*finddir()*
<pre>		Find directory {name} in {path}.  Supports both downwards and</pre>
<pre>		upwards recursive directory searches.  See |file-searching|</pre>
<pre>		for the syntax of {path}.</pre>
<pre>		Returns the path of the first found match.  When the found</pre>
<pre>		directory is below the current directory a relative path is</pre>
<pre>		returned.  Otherwise a full path is returned.</pre>
<pre>		If {path} is omitted or empty then 'path' is used.</pre>
<pre>		If the optional {count} is given, find {count}'s occurrence of</pre>
<pre>		{name} in {path} instead of the first one.</pre>
<pre>		When {count} is negative return all the matches in a |List|.</pre>
<pre>		This is quite similar to the ex-command |:find|.</pre>
<pre>		{only available when compiled with the |+file_in_path|</pre>
<pre>		feature}<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetName()->finddir()<p></pre>

findfile({name} [, {path} [, {count}]])				*findfile()*
<pre>		Just like |finddir()|, but find a file instead of a directory.</pre>
<pre>		Uses 'suffixesadd'.</pre>
<pre>		Example: ></pre>
<pre>			:echo findfile("tags.vim", ".;")</pre>
<		Searches from the directory of the current file upwards until
<pre>		it finds the file "tags.vim".<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetName()->findfile()<p></pre>

float2nr({expr})					*float2nr()*
<pre>		Convert {expr} to a Number by omitting the part after the</pre>
<pre>		decimal point.</pre>
<pre>		{expr} must evaluate to a |Float| or a Number.</pre>
<pre>		When the value of {expr} is out of range for a |Number| the</pre>
<pre>		result is truncated to 0x7fffffff or -0x7fffffff (or when</pre>
<pre>		64-bit Number support is enabled, 0x7fffffffffffffff or</pre>
<pre>		-0x7fffffffffffffff).  NaN results in -0x80000000 (or when</pre>
<pre>		64-bit Number support is enabled, -0x8000000000000000).</pre>
<pre>		Examples: ></pre>
<pre>			echo float2nr(3.95)</pre>
<			3  >
<pre>			echo float2nr(-23.45)</pre>
<			-23  >
<pre>			echo float2nr(1.0e100)</pre>
<			2147483647  (or 9223372036854775807) >
<pre>			echo float2nr(-1.0e150)</pre>
<			-2147483647 (or -9223372036854775807) >
<pre>			echo float2nr(1.0e-100)</pre>
<			0<p>

<pre>		Can also be used as a |method|: ></pre>
<pre>			Compute()->float2nr()</pre>
<
<pre>		{only available when compiled with the |+float| feature}<p></pre>


floor({expr})							*floor()*
<pre>		Return the largest integral value less than or equal to</pre>
<pre>		{expr} as a |Float| (round down).</pre>
<pre>		{expr} must evaluate to a |Float| or a |Number|.</pre>
<pre>		Examples: ></pre>
<pre>			echo floor(1.856)</pre>
<			1.0  >
<pre>			echo floor(-5.456)</pre>
<			-6.0  >
<pre>			echo floor(4.0)</pre>
<			4.0<p>

<pre>		Can also be used as a |method|: ></pre>
<pre>			Compute()->floor()</pre>
<
<pre>		{only available when compiled with the |+float| feature}<p></pre>


fmod({expr1}, {expr2})					*fmod()*
<pre>		Return the remainder of {expr1} / {expr2}, even if the</pre>
<pre>		division is not representable.  Returns {expr1} - i * {expr2}</pre>
<pre>		for some integer i such that if {expr2} is non-zero, the</pre>
<pre>		result has the same sign as {expr1} and magnitude less than</pre>
<pre>		the magnitude of {expr2}.  If {expr2} is zero, the value</pre>
<pre>		returned is zero.  The value returned is a |Float|.</pre>
<pre>		{expr1} and {expr2} must evaluate to a |Float| or a |Number|.</pre>
<pre>		Examples: ></pre>
<pre>			:echo fmod(12.33, 1.22)</pre>
<			0.13 >
<pre>			:echo fmod(-12.33, 1.22)</pre>
<			-0.13<p>

<pre>		Can also be used as a |method|: ></pre>
<pre>			Compute()->fmod(1.22)</pre>
<
<pre>		{only available when compiled with |+float| feature}<p></pre>


fnameescape({string})					*fnameescape()*
<pre>		Escape {string} for use as file name command argument.  All</pre>
<pre>		characters that have a special meaning, such as '%' and '|'</pre>
<pre>		are escaped with a backslash.</pre>
<pre>		For most systems the characters escaped are</pre>
<pre>		" \t\n*?[{`$\\%#'\"|!<".  For systems where a backslash</pre>
<pre>		appears in a filename, it depends on the value of 'isfname'.</pre>
<pre>		A leading '+' and '>' is also escaped (special after |:edit|</pre>
<pre>		and |:write|).  And a "-" by itself (special after |:cd|).</pre>
<pre>		Example: ></pre>
<pre>			:let fname = '+some str%nge|name'</pre>
<pre>			:exe "edit " . fnameescape(fname)</pre>
<		results in executing: >
<pre>			edit \+some\ str\%nge\|name</pre>
<
<pre>		Can also be used as a |method|: ></pre>
<pre>			GetName()->fnameescape()<p></pre>

fnamemodify({fname}, {mods})				*fnamemodify()*
<pre>		Modify file name {fname} according to {mods}.  {mods} is a</pre>
<pre>		string of characters like it is used for file names on the</pre>
<pre>		command line.  See |filename-modifiers|.</pre>
<pre>		Example: ></pre>
<pre>			:echo fnamemodify("main.c", ":p:h")</pre>
<		results in: >
<pre>			/home/mool/vim/vim/src</pre>
<		Note: Environment variables don't work in {fname}, use
<pre>		|expand()| first then.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetName()->fnamemodify(':p:h')<p></pre>

foldclosed({lnum})					*foldclosed()*
<pre>		The result is a Number.  If the line {lnum} is in a closed</pre>
<pre>		fold, the result is the number of the first line in that fold.</pre>
<pre>		If the line {lnum} is not in a closed fold, -1 is returned.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetLnum()->foldclosed()<p></pre>

foldclosedend({lnum})					*foldclosedend()*
<pre>		The result is a Number.  If the line {lnum} is in a closed</pre>
<pre>		fold, the result is the number of the last line in that fold.</pre>
<pre>		If the line {lnum} is not in a closed fold, -1 is returned.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetLnum()->foldclosedend()<p></pre>

foldlevel({lnum})					*foldlevel()*
<pre>		The result is a Number, which is the foldlevel of line {lnum}</pre>
<pre>		in the current buffer.  For nested folds the deepest level is</pre>
<pre>		returned.  If there is no fold at line {lnum}, zero is</pre>
<pre>		returned.  It doesn't matter if the folds are open or closed.</pre>
<pre>		When used while updating folds (from 'foldexpr') -1 is</pre>
<pre>		returned for lines where folds are still to be updated and the</pre>
<pre>		foldlevel is unknown.  As a special case the level of the</pre>
<pre>		previous line is usually available.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetLnum()->foldlevel()</pre>
<
<pre>							*foldtext()*</pre>
foldtext()	Returns a String, to be displayed for a closed fold.  This is
<pre>		the default function used for the 'foldtext' option and should</pre>
<pre>		only be called from evaluating 'foldtext'.  It uses the</pre>
<pre>		|v:foldstart|, |v:foldend| and |v:folddashes| variables.</pre>
<pre>		The returned string looks like this: ></pre>
<pre>			+-- 45 lines: abcdef</pre>
<		The number of leading dashes depends on the foldlevel.  The
<pre>		"45" is the number of lines in the fold.  "abcdef" is the text</pre>
<pre>		in the first non-blank line of the fold.  Leading white space,</pre>
<pre>		"//" or "/*" and the text from the 'foldmarker' and</pre>
<pre>		'commentstring' options is removed.</pre>
<pre>		When used to draw the actual foldtext, the rest of the line</pre>
<pre>		will be filled with the fold char from the 'fillchars'</pre>
<pre>		setting.</pre>
<pre>		{not available when compiled without the |+folding| feature}<p></pre>

foldtextresult({lnum})					*foldtextresult()*
<pre>		Returns the text that is displayed for the closed fold at line</pre>
<pre>		{lnum}.  Evaluates 'foldtext' in the appropriate context.</pre>
<pre>		When there is no closed fold at {lnum} an empty string is</pre>
<pre>		returned.</pre>
<pre>		{lnum} is used like with |getline()|.  Thus "." is the current</pre>
<pre>		line, "'m" mark m, etc.</pre>
<pre>		Useful when exporting folded text, e.g., to HTML.</pre>
<pre>		{not available when compiled without the |+folding| feature}<p></pre>


<pre>		Can also be used as a |method|: ></pre>
<pre>			GetLnum()->foldtextresult()</pre>
<
<pre>							*foreground()*</pre>
foreground()	Move the Vim window to the foreground.  Useful when sent from
<pre>		a client to a Vim server. |remote_send()|</pre>
<pre>		On Win32 systems this might not work, the OS does not always</pre>
<pre>		allow a window to bring itself to the foreground.  Use</pre>
<pre>		|remote_foreground()| instead.</pre>
<pre>		{only in the Win32, Athena, Motif and GTK GUI versions and the</pre>
<pre>		Win32 console version}<p></pre>

<pre>						*funcref()*</pre>
funcref({name} [, {arglist}] [, {dict}])
<pre>		Just like |function()|, but the returned Funcref will lookup</pre>
<pre>		the function by reference, not by name.  This matters when the</pre>
<pre>		function {name} is redefined later.<p></pre>

<pre>		Unlike |function()|, {name} must be an existing user function.</pre>
<pre>		Also for autoloaded functions. {name} cannot be a builtin</pre>
<pre>		function.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetFuncname()->funcref([arg])</pre>
<
<pre>					*function()* *E700* *E922* *E923*</pre>
function({name} [, {arglist}] [, {dict}])
<pre>		Return a |Funcref| variable that refers to function {name}.</pre>
<pre>		{name} can be the name of a user defined function or an</pre>
<pre>		internal function.<p></pre>

<pre>		{name} can also be a Funcref or a partial.  When it is a</pre>
<pre>		partial the dict stored in it will be used and the {dict}</pre>
<pre>		argument is not allowed. E.g.: ></pre>
<pre>			let FuncWithArg = function(dict.Func, [arg])</pre>
<pre>			let Broken = function(dict.Func, [arg], dict)</pre>
<
<pre>		When using the Funcref the function will be found by {name},</pre>
<pre>		also when it was redefined later.  Use |funcref()| to keep the</pre>
<pre>		same function.<p></pre>

<pre>		When {arglist} or {dict} is present this creates a partial.</pre>
<pre>		That means the argument list and/or the dictionary is stored in</pre>
<pre>		the Funcref and will be used when the Funcref is called.<p></pre>

<pre>		The arguments are passed to the function in front of other</pre>
<pre>		arguments, but after any argument from |method|.  Example: ></pre>
<pre>			func Callback(arg1, arg2, name)</pre>
<pre>			...</pre>
<pre>			let Partial = function('Callback', ['one', 'two'])</pre>
<pre>			...</pre>
<pre>			call Partial('name')</pre>
<		Invokes the function as with: >
<pre>			call Callback('one', 'two', 'name')<p></pre>

<		With a |method|: >
<pre>			func Callback(one, two, three)</pre>
<pre>			...</pre>
<pre>			let Partial = function('Callback', ['two'])</pre>
<pre>			...</pre>
<pre>			eval 'one'->Partial('three')</pre>
<		Invokes the function as with: >
<pre>			call Callback('one', 'two', 'three')<p></pre>

<		The function() call can be nested to add more arguments to the
<pre>		Funcref.  The extra arguments are appended to the list of</pre>
<pre>		arguments.  Example: ></pre>
<pre>			func Callback(arg1, arg2, name)</pre>
<pre>			...</pre>
<pre>			let Func = function('Callback', ['one'])</pre>
<pre>			let Func2 = function(Func, ['two'])</pre>
<pre>			...</pre>
<pre>			call Func2('name')</pre>
<		Invokes the function as with: >
<pre>			call Callback('one', 'two', 'name')<p></pre>

<		The Dictionary is only useful when calling a "dict" function.
<pre>		In that case the {dict} is passed in as "self". Example: ></pre>
<pre>			function Callback() dict</pre>
<pre>			   echo "called for " . self.name</pre>
<pre>			endfunction</pre>
<pre>			...</pre>
<pre>			let context = {"name": "example"}</pre>
<pre>			let Func = function('Callback', context)</pre>
<pre>			...</pre>
<pre>			call Func()	" will echo: called for example</pre>
<		The use of function() is not needed when there are no extra
<pre>		arguments, these two are equivalent: ></pre>
<pre>			let Func = function('Callback', context)</pre>
<pre>			let Func = context.Callback<p></pre>

<		The argument list and the Dictionary can be combined: >
<pre>			function Callback(arg1, count) dict</pre>
<pre>			...</pre>
<pre>			let context = {"name": "example"}</pre>
<pre>			let Func = function('Callback', ['one'], context)</pre>
<pre>			...</pre>
<pre>			call Func(500)</pre>
<		Invokes the function as with: >
<pre>			call context.Callback('one', 500)</pre>
<
<pre>		Can also be used as a |method|: ></pre>
<pre>			GetFuncname()->function([arg])<p></pre>


garbagecollect([{atexit}])				*garbagecollect()*
<pre>		Cleanup unused |Lists|, |Dictionaries|, |Channels| and |Jobs|</pre>
<pre>		that have circular references.<p></pre>

<pre>		There is hardly ever a need to invoke this function, as it is</pre>
<pre>		automatically done when Vim runs out of memory or is waiting</pre>
<pre>		for the user to press a key after 'updatetime'.  Items without</pre>
<pre>		circular references are always freed when they become unused.</pre>
<pre>		This is useful if you have deleted a very big |List| and/or</pre>
<pre>		|Dictionary| with circular references in a script that runs</pre>
<pre>		for a long time.<p></pre>

<pre>		When the optional {atexit} argument is one, garbage</pre>
<pre>		collection will also be done when exiting Vim, if it wasn't</pre>
<pre>		done before.  This is useful when checking for memory leaks.<p></pre>

<pre>		The garbage collection is not done immediately but only when</pre>
<pre>		it's safe to perform.  This is when waiting for the user to</pre>
<pre>		type a character.  To force garbage collection immediately use</pre>
<pre>		|test_garbagecollect_now()|.<p></pre>

get({list}, {idx} [, {default}])			*get()*
<pre>		Get item {idx} from |List| {list}.  When this item is not</pre>
<pre>		available return {default}.  Return zero when {default} is</pre>
<pre>		omitted.</pre>
<pre>		Can also be used as a |method|: ></pre>
<pre>			mylist->get(idx)</pre>
get({blob}, {idx} [, {default}])
<pre>		Get byte {idx} from |Blob| {blob}.  When this byte is not</pre>
<pre>		available return {default}.  Return -1 when {default} is</pre>
<pre>		omitted.</pre>
get({dict}, {key} [, {default}])
<pre>		Get item with key {key} from |Dictionary| {dict}.  When this</pre>
<pre>		item is not available return {default}.  Return zero when</pre>
<pre>		{default} is omitted.  Useful example: ></pre>
<pre>			let val = get(g:, 'var_name', 'default')</pre>
<		This gets the value of g:var_name if it exists, and uses
<pre>		'default' when it does not exist.</pre>
get({func}, {what})
<pre>		Get an item with from Funcref {func}.  Possible values for</pre>
<pre>		{what} are:</pre>
<pre>			"name"	The function name</pre>
<pre>			"func"	The function</pre>
<pre>			"dict"	The dictionary</pre>
<pre>			"args"	The list with arguments<p></pre>

<pre>							*getbufinfo()*</pre>
getbufinfo([{expr}])
getbufinfo([{dict}])
<pre>		Get information about buffers as a List of Dictionaries.<p></pre>

<pre>		Without an argument information about all the buffers is</pre>
<pre>		returned.<p></pre>

<pre>		When the argument is a Dictionary only the buffers matching</pre>
<pre>		the specified criteria are returned.  The following keys can</pre>
<pre>		be specified in {dict}:</pre>
<pre>			buflisted	include only listed buffers.</pre>
<pre>			bufloaded	include only loaded buffers.</pre>
<pre>			bufmodified	include only modified buffers.<p></pre>

<pre>		Otherwise, {expr} specifies a particular buffer to return</pre>
<pre>		information for.  For the use of {expr}, see |bufname()|</pre>
<pre>		above.  If the buffer is found the returned List has one item.</pre>
<pre>		Otherwise the result is an empty list.<p></pre>

<pre>		Each returned List item is a dictionary with the following</pre>
<pre>		entries:</pre>
<pre>			bufnr		buffer number.</pre>
<pre>			changed		TRUE if the buffer is modified.</pre>
<pre>			changedtick	number of changes made to the buffer.</pre>
<pre>			hidden		TRUE if the buffer is hidden.</pre>
<pre>			lastused	timestamp in seconds, like</pre>
<pre>					|localtime()|, when the buffer was</pre>
<pre>					last used.</pre>
<pre>					{only with the |+viminfo| feature}</pre>
<pre>			listed		TRUE if the buffer is listed.</pre>
<pre>			lnum		current line number in buffer.</pre>
<pre>			loaded		TRUE if the buffer is loaded.</pre>
<pre>			name		full path to the file in the buffer.</pre>
<pre>			signs		list of signs placed in the buffer.</pre>
<pre>					Each list item is a dictionary with</pre>
<pre>					the following fields:</pre>
<pre>					    id	  sign identifier</pre>
<pre>					    lnum  line number</pre>
<pre>					    name  sign name</pre>
<pre>			variables	a reference to the dictionary with</pre>
<pre>					buffer-local variables.</pre>
<pre>			windows		list of |window-ID|s that display this</pre>
<pre>					buffer</pre>
<pre>			popups		list of popup |window-ID|s that</pre>
<pre>					display this buffer<p></pre>

<pre>		Examples: ></pre>
<pre>			for buf in getbufinfo()</pre>
<pre>			    echo buf.name</pre>
<pre>			endfor</pre>
<pre>			for buf in getbufinfo({'buflisted':1})</pre>
<pre>			    if buf.changed</pre>
<pre>				....</pre>
<pre>			    endif</pre>
<pre>			endfor</pre>
<
<pre>		To get buffer-local options use: ></pre>
<pre>			getbufvar({bufnr}, '&option_name')<p></pre>

<
<pre>							*getbufline()*</pre>
getbufline({expr}, {lnum} [, {end}])
<pre>		Return a |List| with the lines starting from {lnum} to {end}</pre>
<pre>		(inclusive) in the buffer {expr}.  If {end} is omitted, a</pre>
<pre>		|List| with only the line {lnum} is returned.<p></pre>

<pre>		For the use of {expr}, see |bufname()| above.<p></pre>

<pre>		For {lnum} and {end} "$" can be used for the last line of the</pre>
<pre>		buffer.  Otherwise a number must be used.<p></pre>

<pre>		When {lnum} is smaller than 1 or bigger than the number of</pre>
<pre>		lines in the buffer, an empty |List| is returned.<p></pre>

<pre>		When {end} is greater than the number of lines in the buffer,</pre>
<pre>		it is treated as {end} is set to the number of lines in the</pre>
<pre>		buffer.  When {end} is before {lnum} an empty |List| is</pre>
<pre>		returned.<p></pre>

<pre>		This function works only for loaded buffers.  For unloaded and</pre>
<pre>		non-existing buffers, an empty |List| is returned.<p></pre>

<pre>		Example: ></pre>
<pre>			:let lines = getbufline(bufnr("myfile"), 1, "$")<p></pre>

<		Can also be used as a |method|: >
<pre>			GetBufnr()->getbufline(lnum)<p></pre>

getbufvar({expr}, {varname} [, {def}])				*getbufvar()*
<pre>		The result is the value of option or local buffer variable</pre>
<pre>		{varname} in buffer {expr}.  Note that the name without "b:"</pre>
<pre>		must be used.</pre>
<pre>		When {varname} is empty returns a dictionary with all the</pre>
<pre>		buffer-local variables.</pre>
<pre>		When {varname} is equal to "&" returns a dictionary with all</pre>
<pre>		the buffer-local options.</pre>
<pre>		Otherwise, when {varname} starts with "&" returns the value of</pre>
<pre>		a buffer-local option.</pre>
<pre>		This also works for a global or buffer-local option, but it</pre>
<pre>		doesn't work for a global variable, window-local variable or</pre>
<pre>		window-local option.</pre>
<pre>		For the use of {expr}, see |bufname()| above.</pre>
<pre>		When the buffer or variable doesn't exist {def} or an empty</pre>
<pre>		string is returned, there is no error message.</pre>
<pre>		Examples: ></pre>
<pre>			:let bufmodified = getbufvar(1, "&mod")</pre>
<pre>			:echo "todo myvar = " . getbufvar("todo", "myvar")<p></pre>

<		Can also be used as a |method|: >
<pre>			GetBufnr()->getbufvar(varname)</pre>
<
getchangelist([{expr}])					*getchangelist()*
<pre>		Returns the |changelist| for the buffer {expr}. For the use</pre>
<pre>		of {expr}, see |bufname()| above. If buffer {expr} doesn't</pre>
<pre>		exist, an empty list is returned.<p></pre>

<pre>		The returned list contains two entries: a list with the change</pre>
<pre>		locations and the current position in the list.  Each</pre>
<pre>		entry in the change list is a dictionary with the following</pre>
<pre>		entries:</pre>
<pre>			col		column number</pre>
<pre>			coladd		column offset for 'virtualedit'</pre>
<pre>			lnum		line number</pre>
<pre>		If buffer {expr} is the current buffer, then the current</pre>
<pre>		position refers to the position in the list. For other</pre>
<pre>		buffers, it is set to the length of the list.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetBufnr()->getchangelist()<p></pre>

getchar([expr])						*getchar()*
<pre>		Get a single character from the user or input stream.</pre>
<pre>		If [expr] is omitted, wait until a character is available.</pre>
<pre>		If [expr] is 0, only get a character when one is available.</pre>
<pre>			Return zero otherwise.</pre>
<pre>		If [expr] is 1, only check if a character is available, it is</pre>
<pre>			not consumed.  Return zero if no character available.<p></pre>

<pre>		Without [expr] and when [expr] is 0 a whole character or</pre>
<pre>		special key is returned.  If it is a single character, the</pre>
<pre>		result is a number.  Use nr2char() to convert it to a String.</pre>
<pre>		Otherwise a String is returned with the encoded character.</pre>
<pre>		For a special key it's a String with a sequence of bytes</pre>
<pre>		starting with 0x80 (decimal: 128).  This is the same value as</pre>
<pre>		the String "\<Key>", e.g., "\<Left>".  The returned value is</pre>
<pre>		also a String when a modifier (shift, control, alt) was used</pre>
<pre>		that is not included in the character.<p></pre>

<pre>		When [expr] is 0 and Esc is typed, there will be a short delay</pre>
<pre>		while Vim waits to see if this is the start of an escape</pre>
<pre>		sequence.<p></pre>

<pre>		When [expr] is 1 only the first byte is returned.  For a</pre>
<pre>		one-byte character it is the character itself as a number.</pre>
<pre>		Use nr2char() to convert it to a String.<p></pre>

<pre>		Use getcharmod() to obtain any additional modifiers.<p></pre>

<pre>		When the user clicks a mouse button, the mouse event will be</pre>
<pre>		returned.  The position can then be found in |v:mouse_col|,</pre>
<pre>		|v:mouse_lnum|, |v:mouse_winid| and |v:mouse_win|.</pre>
<pre>		|getmousepos()| can also be used.  This example positions the</pre>
<pre>		mouse as it would normally happen: ></pre>
<pre>			let c = getchar()</pre>
<pre>			if c == "\<LeftMouse>" && v:mouse_win > 0</pre>
<pre>			  exe v:mouse_win . "wincmd w"</pre>
<pre>			  exe v:mouse_lnum</pre>
<pre>			  exe "normal " . v:mouse_col . "|"</pre>
<pre>			endif</pre>
<
<pre>		When using bracketed paste only the first character is</pre>
<pre>		returned, the rest of the pasted text is dropped.</pre>
<pre>		|xterm-bracketed-paste|.<p></pre>

<pre>		There is no prompt, you will somehow have to make clear to the</pre>
<pre>		user that a character has to be typed.</pre>
<pre>		There is no mapping for the character.</pre>
<pre>		Key codes are replaced, thus when the user presses the <Del></pre>
<pre>		key you get the code for the <Del> key, not the raw character</pre>
<pre>		sequence.  Examples: ></pre>
<pre>			getchar() == "\<Del>"</pre>
<pre>			getchar() == "\<S-Left>"</pre>
<		This example redefines "f" to ignore case: >
<pre>			:nmap f :call FindChar()<CR></pre>
<pre>			:function FindChar()</pre>
<pre>			:  let c = nr2char(getchar())</pre>
<pre>			:  while col('.') < col('$') - 1</pre>
<pre>			:    normal l</pre>
<pre>			:    if getline('.')[col('.') - 1] ==? c</pre>
<pre>			:      break</pre>
<pre>			:    endif</pre>
<pre>			:  endwhile</pre>
<pre>			:endfunction</pre>
<
<pre>		You may also receive synthetic characters, such as</pre>
<pre>		|<CursorHold>|. Often you will want to ignore this and get</pre>
<pre>		another character: ></pre>
<pre>			:function GetKey()</pre>
<pre>			:  let c = getchar()</pre>
<pre>			:  while c == "\<CursorHold>"</pre>
<pre>			:    let c = getchar()</pre>
<pre>			:  endwhile</pre>
<pre>			:  return c</pre>
<pre>			:endfunction<p></pre>

getcharmod()						*getcharmod()*
<pre>		The result is a Number which is the state of the modifiers for</pre>
<pre>		the last obtained character with getchar() or in another way.</pre>
<pre>		These values are added together:</pre>
<pre>			2	shift</pre>
<pre>			4	control</pre>
<pre>			8	alt (meta)</pre>
<pre>			16	meta (when it's different from ALT)</pre>
<pre>			32	mouse double click</pre>
<pre>			64	mouse triple click</pre>
<pre>			96	mouse quadruple click (== 32 + 64)</pre>
<pre>			128	command (Macintosh only)</pre>
<pre>		Only the modifiers that have not been included in the</pre>
<pre>		character itself are obtained.  Thus Shift-a results in "A"</pre>
<pre>		without a modifier.<p></pre>

getcharsearch()						*getcharsearch()*
<pre>		Return the current character search information as a {dict}</pre>
<pre>		with the following entries:<p></pre>

<pre>		    char	character previously used for a character</pre>
<pre>				search (|t|, |f|, |T|, or |F|); empty string</pre>
<pre>				if no character search has been performed</pre>
<pre>		    forward	direction of character search; 1 for forward,</pre>
<pre>				0 for backward</pre>
<pre>		    until	type of character search; 1 for a |t| or |T|</pre>
<pre>				character search, 0 for an |f| or |F|</pre>
<pre>				character search<p></pre>

<pre>		This can be useful to always have |;| and |,| search</pre>
<pre>		forward/backward regardless of the direction of the previous</pre>
<pre>		character search: ></pre>
<pre>			:nnoremap <expr> ; getcharsearch().forward ? ';' : ','</pre>
<pre>			:nnoremap <expr> , getcharsearch().forward ? ',' : ';'</pre>
<		Also see |setcharsearch()|.<p>

getcmdline()						*getcmdline()*
<pre>		Return the current command-line.  Only works when the command</pre>
<pre>		line is being edited, thus requires use of |c_CTRL-\_e| or</pre>
<pre>		|c_CTRL-R_=|.</pre>
<pre>		Example: ></pre>
<pre>			:cmap <F7> <C-\>eescape(getcmdline(), ' \')<CR></pre>
<		Also see |getcmdtype()|, |getcmdpos()| and |setcmdpos()|.
<pre>		Returns an empty string when entering a password or using</pre>
<pre>		|inputsecret()|.<p></pre>

getcmdpos()						*getcmdpos()*
<pre>		Return the position of the cursor in the command line as a</pre>
<pre>		byte count.  The first column is 1.</pre>
<pre>		Only works when editing the command line, thus requires use of</pre>
<pre>		|c_CTRL-\_e| or |c_CTRL-R_=| or an expression mapping.</pre>
<pre>		Returns 0 otherwise.</pre>
<pre>		Also see |getcmdtype()|, |setcmdpos()| and |getcmdline()|.<p></pre>

getcmdtype()						*getcmdtype()*
<pre>		Return the current command-line type. Possible return values</pre>
<pre>		are:</pre>
<pre>		    :	normal Ex command</pre>
<pre>		    >	debug mode command |debug-mode|</pre>
<pre>		    /	forward search command</pre>
<pre>		    ?	backward search command</pre>
<pre>		    @	|input()| command</pre>
<pre>		    -	|:insert| or |:append| command</pre>
<pre>		    =	|i_CTRL-R_=|</pre>
<pre>		Only works when editing the command line, thus requires use of</pre>
<pre>		|c_CTRL-\_e| or |c_CTRL-R_=| or an expression mapping.</pre>
<pre>		Returns an empty string otherwise.</pre>
<pre>		Also see |getcmdpos()|, |setcmdpos()| and |getcmdline()|.<p></pre>

getcmdwintype()						*getcmdwintype()*
<pre>		Return the current |command-line-window| type. Possible return</pre>
<pre>		values are the same as |getcmdtype()|. Returns an empty string</pre>
<pre>		when not in the command-line window.<p></pre>

getcompletion({pat}, {type} [, {filtered}])		*getcompletion()*
<pre>		Return a list of command-line completion matches. {type}</pre>
<pre>		specifies what for.  The following completion types are</pre>
<pre>		supported:<p></pre>

<pre>		arglist		file names in argument list</pre>
<pre>		augroup		autocmd groups</pre>
<pre>		buffer		buffer names</pre>
<pre>		behave		:behave suboptions</pre>
<pre>		color		color schemes</pre>
<pre>		command		Ex command (and arguments)</pre>
<pre>		compiler	compilers</pre>
<pre>		cscope		|:cscope| suboptions</pre>
<pre>		dir		directory names</pre>
<pre>		environment	environment variable names</pre>
<pre>		event		autocommand events</pre>
<pre>		expression	Vim expression</pre>
<pre>		file		file and directory names</pre>
<pre>		file_in_path	file and directory names in |'path'|</pre>
<pre>		filetype	filetype names |'filetype'|</pre>
<pre>		function	function name</pre>
<pre>		help		help subjects</pre>
<pre>		highlight	highlight groups</pre>
<pre>		history		:history suboptions</pre>
<pre>		locale		locale names (as output of locale -a)</pre>
<pre>		mapclear        buffer argument</pre>
<pre>		mapping		mapping name</pre>
<pre>		menu		menus</pre>
<pre>		messages	|:messages| suboptions</pre>
<pre>		option		options</pre>
<pre>		packadd		optional package |pack-add| names</pre>
<pre>		shellcmd	Shell command</pre>
<pre>		sign		|:sign| suboptions</pre>
<pre>		syntax		syntax file names |'syntax'|</pre>
<pre>		syntime		|:syntime| suboptions</pre>
<pre>		tag		tags</pre>
<pre>		tag_listfiles	tags, file names</pre>
<pre>		user		user names</pre>
<pre>		var		user variables<p></pre>

<pre>		If {pat} is an empty string, then all the matches are returned.</pre>
<pre>		Otherwise only items matching {pat} are returned. See</pre>
<pre>		|wildcards| for the use of special characters in {pat}.<p></pre>

<pre>		If the optional {filtered} flag is set to 1, then 'wildignore'</pre>
<pre>		is applied to filter the results.  Otherwise all the matches</pre>
<pre>		are returned. The 'wildignorecase' option always applies.<p></pre>

<pre>		If there are no matches, an empty list is returned.  An</pre>
<pre>		invalid value for {type} produces an error.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetPattern()->getcompletion('color')</pre>
<
<pre>							*getcurpos()*</pre>
getcurpos()	Get the position of the cursor.  This is like getpos('.'), but
<pre>		includes an extra item in the list:</pre>
<pre>		    [bufnum, lnum, col, off, curswant] ~</pre>
<pre>		The "curswant" number is the preferred column when moving the</pre>
<pre>		cursor vertically.  Also see |getpos()|.<p></pre>

<pre>		This can be used to save and restore the cursor position: ></pre>
<pre>			let save_cursor = getcurpos()</pre>
<pre>			MoveTheCursorAround</pre>
<pre>			call setpos('.', save_cursor)</pre>
<		Note that this only works within the window.  See
<pre>		|winrestview()| for restoring more state.</pre>
<pre>							*getcwd()*</pre>
getcwd([{winnr} [, {tabnr}]])
<pre>		The result is a String, which is the name of the current</pre>
<pre>		working directory.<p></pre>

<pre>		With {winnr} return the local current directory of this window</pre>
<pre>		in the current tab page.  {winnr} can be the window number or</pre>
<pre>		the |window-ID|.</pre>
<pre>		If {winnr} is -1 return the name of the global working</pre>
<pre>		directory.  See also |haslocaldir()|.<p></pre>

<pre>		With {winnr} and {tabnr} return the local current directory of</pre>
<pre>		the window in the specified tab page. If {winnr} is -1 return</pre>
<pre>		the working directory of the tabpage.</pre>
<pre>		If {winnr} is zero use the current window, if {tabnr} is zero</pre>
<pre>		use the current tabpage.</pre>
<pre>		Without any arguments, return the working directory of the</pre>
<pre>		current window.</pre>
<pre>		Return an empty string if the arguments are invalid.<p></pre>

<pre>		Examples: ></pre>
<pre>			" Get the working directory of the current window</pre>
<pre>			:echo getcwd()</pre>
<pre>			:echo getcwd(0)</pre>
<pre>			:echo getcwd(0, 0)</pre>
<pre>			" Get the working directory of window 3 in tabpage 2</pre>
<pre>			:echo getcwd(3, 2)</pre>
<pre>			" Get the global working directory</pre>
<pre>			:echo getcwd(-1)</pre>
<pre>			" Get the working directory of tabpage 3</pre>
<pre>			:echo getcwd(-1, 3)</pre>
<pre>			" Get the working directory of current tabpage</pre>
<pre>			:echo getcwd(-1, 0)<p></pre>

<		Can also be used as a |method|: >
<pre>			GetWinnr()->getcwd()</pre>
<
getenv({name})						*getenv()*
<pre>		Return the value of environment variable {name}.</pre>
<pre>		When the variable does not exist |v:null| is returned.  That</pre>
<pre>		is different from a variable set to an empty string, although</pre>
<pre>		some systems interpret the empty value as the variable being</pre>
<pre>		deleted.  See also |expr-env|.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetVarname()->getenv()<p></pre>

getfontname([{name}])					*getfontname()*
<pre>		Without an argument returns the name of the normal font being</pre>
<pre>		used.  Like what is used for the Normal highlight group</pre>
<pre>		|hl-Normal|.</pre>
<pre>		With an argument a check is done whether {name} is a valid</pre>
<pre>		font name.  If not then an empty string is returned.</pre>
<pre>		Otherwise the actual font name is returned, or {name} if the</pre>
<pre>		GUI does not support obtaining the real name.</pre>
<pre>		Only works when the GUI is running, thus not in your vimrc or</pre>
<pre>		gvimrc file.  Use the |GUIEnter| autocommand to use this</pre>
<pre>		function just after the GUI has started.</pre>
<pre>		Note that the GTK GUI accepts any font name, thus checking for</pre>
<pre>		a valid name does not work.<p></pre>

getfperm({fname})					*getfperm()*
<pre>		The result is a String, which is the read, write, and execute</pre>
<pre>		permissions of the given file {fname}.</pre>
<pre>		If {fname} does not exist or its directory cannot be read, an</pre>
<pre>		empty string is returned.</pre>
<pre>		The result is of the form "rwxrwxrwx", where each group of</pre>
<pre>		"rwx" flags represent, in turn, the permissions of the owner</pre>
<pre>		of the file, the group the file belongs to, and other users.</pre>
<pre>		If a user does not have a given permission the flag for this</pre>
<pre>		is replaced with the string "-".  Examples: ></pre>
<pre>			:echo getfperm("/etc/passwd")</pre>
<pre>			:echo getfperm(expand("~/.vimrc"))</pre>
<		This will hopefully (from a security point of view) display
<pre>		the string "rw-r--r--" or even "rw-------".<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetFilename()->getfperm()</pre>
<
<pre>		For setting permissions use |setfperm()|.<p></pre>

getfsize({fname})					*getfsize()*
<pre>		The result is a Number, which is the size in bytes of the</pre>
<pre>		given file {fname}.</pre>
<pre>		If {fname} is a directory, 0 is returned.</pre>
<pre>		If the file {fname} can't be found, -1 is returned.</pre>
<pre>		If the size of {fname} is too big to fit in a Number then -2</pre>
<pre>		is returned.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetFilename()->getfsize()<p></pre>

getftime({fname})					*getftime()*
<pre>		The result is a Number, which is the last modification time of</pre>
<pre>		the given file {fname}.  The value is measured as seconds</pre>
<pre>		since 1st Jan 1970, and may be passed to strftime().  See also</pre>
<pre>		|localtime()| and |strftime()|.</pre>
<pre>		If the file {fname} can't be found -1 is returned.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetFilename()->getftime()<p></pre>

getftype({fname})					*getftype()*
<pre>		The result is a String, which is a description of the kind of</pre>
<pre>		file of the given file {fname}.</pre>
<pre>		If {fname} does not exist an empty string is returned.</pre>
<pre>		Here is a table over different kinds of files and their</pre>
<pre>		results:</pre>
<pre>			Normal file		"file"</pre>
<pre>			Directory		"dir"</pre>
<pre>			Symbolic link		"link"</pre>
<pre>			Block device		"bdev"</pre>
<pre>			Character device	"cdev"</pre>
<pre>			Socket			"socket"</pre>
<pre>			FIFO			"fifo"</pre>
<pre>			All other		"other"</pre>
<pre>		Example: ></pre>
<pre>			getftype("/home")</pre>
<		Note that a type such as "link" will only be returned on
<pre>		systems that support it.  On some systems only "dir" and</pre>
<pre>		"file" are returned.  On MS-Windows a symbolic link to a</pre>
<pre>		directory returns "dir" instead of "link".<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetFilename()->getftype()<p></pre>

getimstatus()						*getimstatus()*
<pre>		The result is a Number, which is |TRUE| when the IME status is</pre>
<pre>		active.</pre>
<pre>		See 'imstatusfunc'.<p></pre>

getjumplist([{winnr} [, {tabnr}]])			*getjumplist()*
<pre>		Returns the |jumplist| for the specified window.<p></pre>

<pre>		Without arguments use the current window.</pre>
<pre>		With {winnr} only use this window in the current tab page.</pre>
<pre>		{winnr} can also be a |window-ID|.</pre>
<pre>		With {winnr} and {tabnr} use the window in the specified tab</pre>
<pre>		page.<p></pre>

<pre>		The returned list contains two entries: a list with the jump</pre>
<pre>		locations and the last used jump position number in the list.</pre>
<pre>		Each entry in the jump location list is a dictionary with</pre>
<pre>		the following entries:</pre>
<pre>			bufnr		buffer number</pre>
<pre>			col		column number</pre>
<pre>			coladd		column offset for 'virtualedit'</pre>
<pre>			filename	filename if available</pre>
<pre>			lnum		line number<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetWinnr()->getjumplist()<p></pre>

<							*getline()*
getline({lnum} [, {end}])
<pre>		Without {end} the result is a String, which is line {lnum}</pre>
<pre>		from the current buffer.  Example: ></pre>
<pre>			getline(1)</pre>
<		When {lnum} is a String that doesn't start with a
<pre>		digit, |line()| is called to translate the String into a Number.</pre>
<pre>		To get the line under the cursor: ></pre>
<pre>			getline(".")</pre>
<		When {lnum} is smaller than 1 or bigger than the number of
<pre>		lines in the buffer, an empty string is returned.<p></pre>

<pre>		When {end} is given the result is a |List| where each item is</pre>
<pre>		a line from the current buffer in the range {lnum} to {end},</pre>
<pre>		including line {end}.</pre>
<pre>		{end} is used in the same way as {lnum}.</pre>
<pre>		Non-existing lines are silently omitted.</pre>
<pre>		When {end} is before {lnum} an empty |List| is returned.</pre>
<pre>		Example: ></pre>
<pre>			:let start = line('.')</pre>
<pre>			:let end = search("^$") - 1</pre>
<pre>			:let lines = getline(start, end)<p></pre>

<		Can also be used as a |method|: >
<pre>			ComputeLnum()->getline()<p></pre>

<		To get lines from another buffer see |getbufline()|<p>

getloclist({nr} [, {what}])				*getloclist()*
<pre>		Returns a list with all the entries in the location list for</pre>
<pre>		window {nr}.  {nr} can be the window number or the |window-ID|.</pre>
<pre>		When {nr} is zero the current window is used.<p></pre>

<pre>		For a location list window, the displayed location list is</pre>
<pre>		returned.  For an invalid window number {nr}, an empty list is</pre>
<pre>		returned. Otherwise, same as |getqflist()|.<p></pre>

<pre>		If the optional {what} dictionary argument is supplied, then</pre>
<pre>		returns the items listed in {what} as a dictionary. Refer to</pre>
<pre>		|getqflist()| for the supported items in {what}.<p></pre>

<pre>		In addition to the items supported by |getqflist()| in {what},</pre>
<pre>		the following item is supported by |getloclist()|:<p></pre>

<pre>			filewinid	id of the window used to display files</pre>
<pre>					from the location list. This field is</pre>
<pre>					applicable only when called from a</pre>
<pre>					location list window. See</pre>
<pre>					|location-list-file-window| for more</pre>
<pre>					details.<p></pre>

getmatches([{win}])					*getmatches()*
<pre>		Returns a |List| with all matches previously defined for the</pre>
<pre>		current window by |matchadd()| and the |:match| commands.</pre>
<pre>		|getmatches()| is useful in combination with |setmatches()|,</pre>
<pre>		as |setmatches()| can restore a list of matches saved by</pre>
<pre>		|getmatches()|.</pre>
<pre>		Example: ></pre>
<pre>			:echo getmatches()</pre>
<			[{'group': 'MyGroup1', 'pattern': 'TODO',
<pre>			'priority': 10, 'id': 1}, {'group': 'MyGroup2',</pre>
<pre>			'pattern': 'FIXME', 'priority': 10, 'id': 2}] ></pre>
<pre>			:let m = getmatches()</pre>
<pre>			:call clearmatches()</pre>
<pre>			:echo getmatches()</pre>
<			[] >
<pre>			:call setmatches(m)</pre>
<pre>			:echo getmatches()</pre>
<			[{'group': 'MyGroup1', 'pattern': 'TODO',
<pre>			'priority': 10, 'id': 1}, {'group': 'MyGroup2',</pre>
<pre>			'pattern': 'FIXME', 'priority': 10, 'id': 2}] ></pre>
<pre>			:unlet m</pre>
<
getmousepos()						*getmousepos()*
<pre>		Returns a Dictionary with the last known position of the</pre>
<pre>		mouse.  This can be used in a mapping for a mouse click or in</pre>
<pre>		a filter of a popup window.  The items are:</pre>
<pre>			screenrow	screen row</pre>
<pre>			screencol	screen column</pre>
<pre>			winid		Window ID of the click</pre>
<pre>			winrow		row inside "winid"</pre>
<pre>			wincol		column inside "winid"</pre>
<pre>			line		text line inside "winid"</pre>
<pre>			column		text column inside "winid"</pre>
<pre>		All numbers are 1-based.<p></pre>

<pre>		If not over a window, e.g. when in the command line, then only</pre>
<pre>		"screenrow" and "screencol" are valid, the others are zero.<p></pre>

<pre>		When on the status line below a window or the vertical</pre>
<pre>		separater right of a window, the "line" and "column" values</pre>
<pre>		are zero.<p></pre>

<pre>		When the position is after the text then "column" is the</pre>
<pre>		length of the text in bytes.<p></pre>

<pre>		If the mouse is over a popup window then that window is used.<p></pre>


<pre>		When using |getchar()| the Vim variables |v:mouse_lnum|,</pre>
<pre>		|v:mouse_col| and |v:mouse_winid| also provide these values.<p></pre>

<pre>							*getpid()*</pre>
getpid()	Return a Number which is the process ID of the Vim process.
<pre>		On Unix and MS-Windows this is a unique number, until Vim</pre>
<pre>		exits.  On MS-DOS it's always zero.<p></pre>

<pre>							*getpos()*</pre>
getpos({expr})	Get the position for {expr}.  For possible values of {expr}
<pre>		see |line()|.  For getting the cursor position see</pre>
<pre>		|getcurpos()|.</pre>
<pre>		The result is a |List| with four numbers:</pre>
<pre>		    [bufnum, lnum, col, off]</pre>
<pre>		"bufnum" is zero, unless a mark like '0 or 'A is used, then it</pre>
<pre>		is the buffer number of the mark.</pre>
<pre>		"lnum" and "col" are the position in the buffer.  The first</pre>
<pre>		column is 1.</pre>
<pre>		The "off" number is zero, unless 'virtualedit' is used.  Then</pre>
<pre>		it is the offset in screen columns from the start of the</pre>
<pre>		character.  E.g., a position within a <Tab> or after the last</pre>
<pre>		character.</pre>
<pre>		Note that for '< and '> Visual mode matters: when it is "V"</pre>
<pre>		(visual line mode) the column of '< is zero and the column of</pre>
<pre>		'> is a large number.</pre>
<pre>		This can be used to save and restore the position of a mark: ></pre>
<pre>			let save_a_mark = getpos("'a")</pre>
<pre>			...</pre>
<pre>			call setpos("'a", save_a_mark)</pre>
<		Also see |getcurpos()| and |setpos()|.<p>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetMark()->getpos()<p></pre>


getqflist([{what}])					*getqflist()*
<pre>		Returns a list with all the current quickfix errors.  Each</pre>
<pre>		list item is a dictionary with these entries:</pre>
<pre>			bufnr	number of buffer that has the file name, use</pre>
<pre>				bufname() to get the name</pre>
<pre>			module	module name</pre>
<pre>			lnum	line number in the buffer (first line is 1)</pre>
<pre>			col	column number (first column is 1)</pre>
<pre>			vcol	|TRUE|: "col" is visual column</pre>
<pre>				|FALSE|: "col" is byte index</pre>
<pre>			nr	error number</pre>
<pre>			pattern	search pattern used to locate the error</pre>
<pre>			text	description of the error</pre>
<pre>			type	type of the error, 'E', '1', etc.</pre>
<pre>			valid	|TRUE|: recognized error message<p></pre>

<pre>		When there is no error list or it's empty, an empty list is</pre>
<pre>		returned. Quickfix list entries with non-existing buffer</pre>
<pre>		number are returned with "bufnr" set to zero.<p></pre>

<pre>		Useful application: Find pattern matches in multiple files and</pre>
<pre>		do something with them: ></pre>
<pre>			:vimgrep /theword/jg *.c</pre>
<pre>			:for d in getqflist()</pre>
<pre>			:   echo bufname(d.bufnr) ':' d.lnum '=' d.text</pre>
<pre>			:endfor</pre>
<
<pre>		If the optional {what} dictionary argument is supplied, then</pre>
<pre>		returns only the items listed in {what} as a dictionary. The</pre>
<pre>		following string items are supported in {what}:</pre>
<pre>			changedtick	get the total number of changes made</pre>
<pre>					to the list |quickfix-changedtick|</pre>
<pre>			context	get the |quickfix-context|</pre>
<pre>			efm	errorformat to use when parsing "lines". If</pre>
<pre>				not present, then the 'errorformat' option</pre>
<pre>				value is used.</pre>
<pre>			id	get information for the quickfix list with</pre>
<pre>				|quickfix-ID|; zero means the id for the</pre>
<pre>				current list or the list specified by "nr"</pre>
<pre>			idx	index of the current entry in the quickfix</pre>
<pre>				list specified by 'id' or 'nr'.</pre>
<pre>				See |quickfix-index|</pre>
<pre>			items	quickfix list entries</pre>
<pre>			lines	parse a list of lines using 'efm' and return</pre>
<pre>				the resulting entries.  Only a |List| type is</pre>
<pre>				accepted.  The current quickfix list is not</pre>
<pre>				modified. See |quickfix-parse|.</pre>
<pre>			nr	get information for this quickfix list; zero</pre>
<pre>				means the current quickfix list and "$" means</pre>
<pre>				the last quickfix list</pre>
<pre>			qfbufnr number of the buffer displayed in the quickfix</pre>
<pre>				window. Returns 0 if the quickfix buffer is</pre>
<pre>				not present. See |quickfix-buffer|.</pre>
<pre>			size	number of entries in the quickfix list</pre>
<pre>			title	get the list title |quickfix-title|</pre>
<pre>			winid	get the quickfix |window-ID|</pre>
<pre>			all	all of the above quickfix properties</pre>
<pre>		Non-string items in {what} are ignored. To get the value of a</pre>
<pre>		particular item, set it to zero.</pre>
<pre>		If "nr" is not present then the current quickfix list is used.</pre>
<pre>		If both "nr" and a non-zero "id" are specified, then the list</pre>
<pre>		specified by "id" is used.</pre>
<pre>		To get the number of lists in the quickfix stack, set "nr" to</pre>
<pre>		"$" in {what}. The "nr" value in the returned dictionary</pre>
<pre>		contains the quickfix stack size.</pre>
<pre>		When "lines" is specified, all the other items except "efm"</pre>
<pre>		are ignored.  The returned dictionary contains the entry</pre>
<pre>		"items" with the list of entries.<p></pre>

<pre>		The returned dictionary contains the following entries:</pre>
<pre>			changedtick	total number of changes made to the</pre>
<pre>					list |quickfix-changedtick|</pre>
<pre>			context	quickfix list context. See |quickfix-context|</pre>
<pre>				If not present, set to "".</pre>
<pre>			id	quickfix list ID |quickfix-ID|. If not</pre>
<pre>				present, set to 0.</pre>
<pre>			idx	index of the current entry in the list. If not</pre>
<pre>				present, set to 0.</pre>
<pre>			items	quickfix list entries. If not present, set to</pre>
<pre>				an empty list.</pre>
<pre>			nr	quickfix list number. If not present, set to 0</pre>
<pre>			qfbufnr	number of the buffer displayed in the quickfix</pre>
<pre>				window. If not present, set to 0.</pre>
<pre>			size	number of entries in the quickfix list. If not</pre>
<pre>				present, set to 0.</pre>
<pre>			title	quickfix list title text. If not present, set</pre>
<pre>				to "".</pre>
<pre>			winid	quickfix |window-ID|. If not present, set to 0<p></pre>

<pre>		Examples (See also |getqflist-examples|): ></pre>
<pre>			:echo getqflist({'all': 1})</pre>
<pre>			:echo getqflist({'nr': 2, 'title': 1})</pre>
<pre>			:echo getqflist({'lines' : ["F1:10:L10"]})</pre>
<
getreg([{regname} [, 1 [, {list}]]])			*getreg()*
<pre>		The result is a String, which is the contents of register</pre>
<pre>		{regname}.  Example: ></pre>
<pre>			:let cliptext = getreg('*')</pre>
<		When {regname} was not set the result is an empty string.<p>

<pre>		getreg('=') returns the last evaluated value of the expression</pre>
<pre>		register.  (For use in maps.)</pre>
<pre>		getreg('=', 1) returns the expression itself, so that it can</pre>
<pre>		be restored with |setreg()|.  For other registers the extra</pre>
<pre>		argument is ignored, thus you can always give it.<p></pre>

<pre>		If {list} is present and |TRUE|, the result type is changed</pre>
<pre>		to |List|. Each list item is one text line. Use it if you care</pre>
<pre>		about zero bytes possibly present inside register: without</pre>
<pre>		third argument both NLs and zero bytes are represented as NLs</pre>
<pre>		(see |NL-used-for-Nul|).</pre>
<pre>		When the register was not set an empty list is returned.<p></pre>

<pre>		If {regname} is not specified, |v:register| is used.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetRegname()->getreg()<p></pre>


getregtype([{regname}])					*getregtype()*
<pre>		The result is a String, which is type of register {regname}.</pre>
<pre>		The value will be one of:</pre>
<pre>		    "v"			for |characterwise| text</pre>
<pre>		    "V"			for |linewise| text</pre>
<pre>		    "<CTRL-V>{width}"	for |blockwise-visual| text</pre>
<pre>		    ""			for an empty or unknown register</pre>
<pre>		<CTRL-V> is one character with value 0x16.</pre>
<pre>		If {regname} is not specified, |v:register| is used.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetRegname()->getregtype()<p></pre>

gettabinfo([{arg}])					*gettabinfo()*
<pre>		If {arg} is not specified, then information about all the tab</pre>
<pre>		pages is returned as a List. Each List item is a Dictionary.</pre>
<pre>		Otherwise, {arg} specifies the tab page number and information</pre>
<pre>		about that one is returned.  If the tab page does not exist an</pre>
<pre>		empty List is returned.<p></pre>

<pre>		Each List item is a Dictionary with the following entries:</pre>
<pre>			tabnr		tab page number.</pre>
<pre>			variables	a reference to the dictionary with</pre>
<pre>					tabpage-local variables</pre>
<pre>			windows		List of |window-ID|s in the tab page.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetTabnr()->gettabinfo()<p></pre>

gettabvar({tabnr}, {varname} [, {def}])				*gettabvar()*
<pre>		Get the value of a tab-local variable {varname} in tab page</pre>
<pre>		{tabnr}. |t:var|</pre>
<pre>		Tabs are numbered starting with one.</pre>
<pre>		When {varname} is empty a dictionary with all tab-local</pre>
<pre>		variables is returned.</pre>
<pre>		Note that the name without "t:" must be used.</pre>
<pre>		When the tab or variable doesn't exist {def} or an empty</pre>
<pre>		string is returned, there is no error message.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetTabnr()->gettabvar(varname)<p></pre>

gettabwinvar({tabnr}, {winnr}, {varname} [, {def}])		*gettabwinvar()*
<pre>		Get the value of window-local variable {varname} in window</pre>
<pre>		{winnr} in tab page {tabnr}.</pre>
<pre>		When {varname} is empty a dictionary with all window-local</pre>
<pre>		variables is returned.</pre>
<pre>		When {varname} is equal to "&" get the values of all</pre>
<pre>		window-local options in a Dictionary.</pre>
<pre>		Otherwise, when {varname} starts with "&" get the value of a</pre>
<pre>		window-local option.</pre>
<pre>		Note that {varname} must be the name without "w:".</pre>
<pre>		Tabs are numbered starting with one.  For the current tabpage</pre>
<pre>		use |getwinvar()|.</pre>
<pre>		{winnr} can be the window number or the |window-ID|.</pre>
<pre>		When {winnr} is zero the current window is used.</pre>
<pre>		This also works for a global option, buffer-local option and</pre>
<pre>		window-local option, but it doesn't work for a global variable</pre>
<pre>		or buffer-local variable.</pre>
<pre>		When the tab, window or variable doesn't exist {def} or an</pre>
<pre>		empty string is returned, there is no error message.</pre>
<pre>		Examples: ></pre>
<pre>			:let list_is_on = gettabwinvar(1, 2, '&list')</pre>
<pre>			:echo "myvar = " . gettabwinvar(3, 1, 'myvar')</pre>
<
<pre>		To obtain all window-local variables use: ></pre>
<pre>			gettabwinvar({tabnr}, {winnr}, '&')<p></pre>

<		Can also be used as a |method|: >
<pre>			GetTabnr()->gettabwinvar(winnr, varname)<p></pre>

gettagstack([{nr}])					*gettagstack()*
<pre>		The result is a Dict, which is the tag stack of window {nr}.</pre>
<pre>		{nr} can be the window number or the |window-ID|.</pre>
<pre>		When {nr} is not specified, the current window is used.</pre>
<pre>		When window {nr} doesn't exist, an empty Dict is returned.<p></pre>

<pre>		The returned dictionary contains the following entries:</pre>
<pre>			curidx		Current index in the stack. When at</pre>
<pre>					top of the stack, set to (length + 1).</pre>
<pre>					Index of bottom of the stack is 1.</pre>
<pre>			items		List of items in the stack. Each item</pre>
<pre>					is a dictionary containing the</pre>
<pre>					entries described below.</pre>
<pre>			length		Number of entries in the stack.<p></pre>

<pre>		Each item in the stack is a dictionary with the following</pre>
<pre>		entries:</pre>
<pre>			bufnr		buffer number of the current jump</pre>
<pre>			from		cursor position before the tag jump.</pre>
<pre>					See |getpos()| for the format of the</pre>
<pre>					returned list.</pre>
<pre>			matchnr		current matching tag number. Used when</pre>
<pre>					multiple matching tags are found for a</pre>
<pre>					name.</pre>
<pre>			tagname		name of the tag<p></pre>

<pre>		See |tagstack| for more information about the tag stack.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetWinnr()->gettagstack()<p></pre>

getwininfo([{winid}])					*getwininfo()*
<pre>		Returns information about windows as a List with Dictionaries.<p></pre>

<pre>		If {winid} is given Information about the window with that ID</pre>
<pre>		is returned.  If the window does not exist the result is an</pre>
<pre>		empty list.<p></pre>

<pre>		Without {winid} information about all the windows in all the</pre>
<pre>		tab pages is returned.<p></pre>

<pre>		Each List item is a Dictionary with the following entries:</pre>
<pre>			botline		last displayed buffer line</pre>
<pre>			bufnr		number of buffer in the window</pre>
<pre>			height		window height (excluding winbar)</pre>
<pre>			loclist		1 if showing a location list</pre>
<pre>					{only with the +quickfix feature}</pre>
<pre>			quickfix	1 if quickfix or location list window</pre>
<pre>					{only with the +quickfix feature}</pre>
<pre>			terminal	1 if a terminal window</pre>
<pre>					{only with the +terminal feature}</pre>
<pre>			tabnr		tab page number</pre>
<pre>			topline		first displayed buffer line</pre>
<pre>			variables	a reference to the dictionary with</pre>
<pre>					window-local variables</pre>
<pre>			width		window width</pre>
<pre>			winbar		1 if the window has a toolbar, 0</pre>
<pre>					otherwise</pre>
<pre>			wincol		leftmost screen column of the window,</pre>
<pre>					col from |win_screenpos()|</pre>
<pre>			winid		|window-ID|</pre>
<pre>			winnr		window number</pre>
<pre>			winrow		topmost screen column of the window,</pre>
<pre>					row from |win_screenpos()|<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetWinnr()->getwininfo()<p></pre>

getwinpos([{timeout}])					*getwinpos()*
<pre>		The result is a list with two numbers, the result of</pre>
<pre>		|getwinposx()| and |getwinposy()| combined:</pre>
<pre>			[x-pos, y-pos]</pre>
<pre>		{timeout} can be used to specify how long to wait in msec for</pre>
<pre>		a response from the terminal.  When omitted 100 msec is used.</pre>
<pre>		Use a longer time for a remote terminal.</pre>
<pre>		When using a value less than 10 and no response is received</pre>
<pre>		within that time, a previously reported position is returned,</pre>
<pre>		if available.  This can be used to poll for the position and</pre>
<pre>		do some work in the meantime: ></pre>
<pre>			while 1</pre>
<pre>			  let res = getwinpos(1)</pre>
<pre>			  if res[0] >= 0</pre>
<pre>			    break</pre>
<pre>			  endif</pre>
<pre>			  " Do some work here</pre>
<pre>			endwhile</pre>
<<p>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetTimeout()->getwinpos()</pre>
<
<pre>							*getwinposx()*</pre>
getwinposx()	The result is a Number, which is the X coordinate in pixels of
<pre>		the left hand side of the GUI Vim window. Also works for an</pre>
<pre>		xterm (uses a timeout of 100 msec).</pre>
<pre>		The result will be -1 if the information is not available.</pre>
<pre>		The value can be used with `:winpos`.<p></pre>

<pre>							*getwinposy()*</pre>
getwinposy()	The result is a Number, which is the Y coordinate in pixels of
<pre>		the top of the GUI Vim window.  Also works for an xterm (uses</pre>
<pre>		a timeout of 100 msec).</pre>
<pre>		The result will be -1 if the information is not available.</pre>
<pre>		The value can be used with `:winpos`.<p></pre>

getwinvar({winnr}, {varname} [, {def}])				*getwinvar()*
<pre>		Like |gettabwinvar()| for the current tabpage.</pre>
<pre>		Examples: ></pre>
<pre>			:let list_is_on = getwinvar(2, '&list')</pre>
<pre>			:echo "myvar = " . getwinvar(1, 'myvar')<p></pre>

<		Can also be used as a |method|: >
<pre>			GetWinnr()->getwinvar(varname)</pre>
<
glob({expr} [, {nosuf} [, {list} [, {alllinks}]]])		*glob()*
<pre>		Expand the file wildcards in {expr}.  See |wildcards| for the</pre>
<pre>		use of special characters.<p></pre>

<pre>		Unless the optional {nosuf} argument is given and is |TRUE|,</pre>
<pre>		the 'suffixes' and 'wildignore' options apply: Names matching</pre>
<pre>		one of the patterns in 'wildignore' will be skipped and</pre>
<pre>		'suffixes' affect the ordering of matches.</pre>
<pre>		'wildignorecase' always applies.<p></pre>

<pre>		When {list} is present and it is |TRUE| the result is a List</pre>
<pre>		with all matching files. The advantage of using a List is,</pre>
<pre>		you also get filenames containing newlines correctly.</pre>
<pre>		Otherwise the result is a String and when there are several</pre>
<pre>		matches, they are separated by <NL> characters.<p></pre>

<pre>		If the expansion fails, the result is an empty String or List.<p></pre>

<pre>		You can also use |readdir()| if you need to do complicated</pre>
<pre>		things, such as limiting the number of matches.<p></pre>

<pre>		A name for a non-existing file is not included.  A symbolic</pre>
<pre>		link is only included if it points to an existing file.</pre>
<pre>		However, when the {alllinks} argument is present and it is</pre>
<pre>		|TRUE| then all symbolic links are included.<p></pre>

<pre>		For most systems backticks can be used to get files names from</pre>
<pre>		any external command.  Example: ></pre>
<pre>			:let tagfiles = glob("`find . -name tags -print`")</pre>
<pre>			:let &tags = substitute(tagfiles, "\n", ",", "g")</pre>
<		The result of the program inside the backticks should be one
<pre>		item per line.  Spaces inside an item are allowed.<p></pre>

<pre>		See |expand()| for expanding special Vim variables.  See</pre>
<pre>		|system()| for getting the raw output of an external command.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetExpr()->glob()<p></pre>

glob2regpat({expr})					 *glob2regpat()*
<pre>		Convert a file pattern, as used by glob(), into a search</pre>
<pre>		pattern.  The result can be used to match with a string that</pre>
<pre>		is a file name.  E.g. ></pre>
<pre>			if filename =~ glob2regpat('Make*.mak')</pre>
<		This is equivalent to: >
<pre>			if filename =~ '^Make.*\.mak$'</pre>
<		When {expr} is an empty string the result is "^$", match an
<pre>		empty string.</pre>
<pre>		Note that the result depends on the system.  On MS-Windows</pre>
<pre>		a backslash usually means a path separator.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetExpr()->glob2regpat()</pre>
<								*globpath()*
globpath({path}, {expr} [, {nosuf} [, {list} [, {alllinks}]]])
<pre>		Perform glob() for {expr} on all directories in {path} and</pre>
<pre>		concatenate the results.  Example: ></pre>
<pre>			:echo globpath(&rtp, "syntax/c.vim")</pre>
<
<pre>		{path} is a comma-separated list of directory names.  Each</pre>
<pre>		directory name is prepended to {expr} and expanded like with</pre>
<pre>		|glob()|.  A path separator is inserted when needed.</pre>
<pre>		To add a comma inside a directory name escape it with a</pre>
<pre>		backslash.  Note that on MS-Windows a directory may have a</pre>
<pre>		trailing backslash, remove it if you put a comma after it.</pre>
<pre>		If the expansion fails for one of the directories, there is no</pre>
<pre>		error message.<p></pre>

<pre>		Unless the optional {nosuf} argument is given and is |TRUE|,</pre>
<pre>		the 'suffixes' and 'wildignore' options apply: Names matching</pre>
<pre>		one of the patterns in 'wildignore' will be skipped and</pre>
<pre>		'suffixes' affect the ordering of matches.<p></pre>

<pre>		When {list} is present and it is |TRUE| the result is a List</pre>
<pre>		with all matching files. The advantage of using a List is, you</pre>
<pre>		also get filenames containing newlines correctly. Otherwise</pre>
<pre>		the result is a String and when there are several matches,</pre>
<pre>		they are separated by <NL> characters.  Example: ></pre>
<pre>			:echo globpath(&rtp, "syntax/c.vim", 0, 1)</pre>
<
<pre>		{alllinks} is used as with |glob()|.<p></pre>

<pre>		The "**" item can be used to search in a directory tree.</pre>
<pre>		For example, to find all "README.txt" files in the directories</pre>
<pre>		in 'runtimepath' and below: ></pre>
<pre>			:echo globpath(&rtp, "**/README.txt")</pre>
<		Upwards search and limiting the depth of "**" is not
<pre>		supported, thus using 'path' will not always work properly.<p></pre>

<pre>		Can also be used as a |method|, the base is passed as the</pre>
<pre>		second argument: ></pre>
<pre>			GetExpr()->globpath(&rtp)</pre>
<
<pre>							*has()*</pre>
has({feature})	The result is a Number, which is 1 if the feature {feature} is
<pre>		supported, zero otherwise.  The {feature} argument is a</pre>
<pre>		string.  See |feature-list| below.</pre>
<pre>		Also see |exists()|.<p></pre>


has_key({dict}, {key})					*has_key()*
<pre>		The result is a Number, which is 1 if |Dictionary| {dict} has</pre>
<pre>		an entry with key {key}.  Zero otherwise.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			mydict->has_key(key)<p></pre>

haslocaldir([{winnr} [, {tabnr}]])			*haslocaldir()*
<pre>		The result is a Number:</pre>
<pre>		    1   when the window has set a local directory via |:lcd|</pre>
<pre>		    2   when the tab-page has set a local directory via |:tcd|</pre>
<pre>		    0   otherwise.<p></pre>

<pre>		Without arguments use the current window.</pre>
<pre>		With {winnr} use this window in the current tab page.</pre>
<pre>		With {winnr} and {tabnr} use the window in the specified tab</pre>
<pre>		page.</pre>
<pre>		{winnr} can be the window number or the |window-ID|.</pre>
<pre>		If {winnr} is -1 it is ignored and only the tabpage is used.</pre>
<pre>		Return 0 if the arguments are invalid.</pre>
<pre>		Examples: ></pre>
<pre>			if haslocaldir() == 1</pre>
<pre>			  " window local directory case</pre>
<pre>			elseif haslocaldir() == 2</pre>
<pre>			  " tab-local directory case</pre>
<pre>			else</pre>
<pre>			  " global directory case</pre>
<pre>			endif<p></pre>

<pre>			" current window</pre>
<pre>			:echo haslocaldir()</pre>
<pre>			:echo haslocaldir(0)</pre>
<pre>			:echo haslocaldir(0, 0)</pre>
<pre>			" window n in current tab page</pre>
<pre>			:echo haslocaldir(n)</pre>
<pre>			:echo haslocaldir(n, 0)</pre>
<pre>			" window n in tab page m</pre>
<pre>			:echo haslocaldir(n, m)</pre>
<pre>			" tab page m</pre>
<pre>			:echo haslocaldir(-1, m)</pre>
<
<pre>		Can also be used as a |method|: ></pre>
<pre>			GetWinnr()->haslocaldir()<p></pre>

hasmapto({what} [, {mode} [, {abbr}]])			*hasmapto()*
<pre>		The result is a Number, which is 1 if there is a mapping that</pre>
<pre>		contains {what} in somewhere in the rhs (what it is mapped to)</pre>
<pre>		and this mapping exists in one of the modes indicated by</pre>
<pre>		{mode}.</pre>
<pre>		When {abbr} is there and it is |TRUE| use abbreviations</pre>
<pre>		instead of mappings.  Don't forget to specify Insert and/or</pre>
<pre>		Command-line mode.</pre>
<pre>		Both the global mappings and the mappings local to the current</pre>
<pre>		buffer are checked for a match.</pre>
<pre>		If no matching mapping is found 0 is returned.</pre>
<pre>		The following characters are recognized in {mode}:</pre>
<pre>			n	Normal mode</pre>
<pre>			v	Visual and Select mode</pre>
<pre>			x	Visual mode</pre>
<pre>			s	Select mode</pre>
<pre>			o	Operator-pending mode</pre>
<pre>			i	Insert mode</pre>
<pre>			l	Language-Argument ("r", "f", "t", etc.)</pre>
<pre>			c	Command-line mode</pre>
<pre>		When {mode} is omitted, "nvo" is used.<p></pre>

<pre>		This function is useful to check if a mapping already exists</pre>
<pre>		to a function in a Vim script.  Example: ></pre>
<pre>			:if !hasmapto('\ABCdoit')</pre>
<pre>			:   map <Leader>d \ABCdoit</pre>
<pre>			:endif</pre>
<		This installs the mapping to "\ABCdoit" only if there isn't
<pre>		already a mapping to "\ABCdoit".<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetRHS()->hasmapto()<p></pre>

histadd({history}, {item})				*histadd()*
<pre>		Add the String {item} to the history {history} which can be</pre>
<pre>		one of:					*hist-names*</pre>
<pre>			"cmd"	 or ":"	  command line history</pre>
<pre>			"search" or "/"   search pattern history</pre>
<pre>			"expr"	 or "="   typed expression history</pre>
<pre>			"input"  or "@"	  input line history</pre>
<pre>			"debug"  or ">"   debug command history</pre>
<pre>			empty		  the current or last used history</pre>
<pre>		The {history} string does not need to be the whole name, one</pre>
<pre>		character is sufficient.</pre>
<pre>		If {item} does already exist in the history, it will be</pre>
<pre>		shifted to become the newest entry.</pre>
<pre>		The result is a Number: 1 if the operation was successful,</pre>
<pre>		otherwise 0 is returned.<p></pre>

<pre>		Example: ></pre>
<pre>			:call histadd("input", strftime("%Y %b %d"))</pre>
<pre>			:let date=input("Enter date: ")</pre>
<		This function is not available in the |sandbox|.<p>

<pre>		Can also be used as a |method|, the base is passed as the</pre>
<pre>		second argument: ></pre>
<pre>			GetHistory()->histadd('search')<p></pre>

histdel({history} [, {item}])				*histdel()*
<pre>		Clear {history}, i.e. delete all its entries.  See |hist-names|</pre>
<pre>		for the possible values of {history}.<p></pre>

<pre>		If the parameter {item} evaluates to a String, it is used as a</pre>
<pre>		regular expression.  All entries matching that expression will</pre>
<pre>		be removed from the history (if there are any).</pre>
<pre>		Upper/lowercase must match, unless "\c" is used |/\c|.</pre>
<pre>		If {item} evaluates to a Number, it will be interpreted as</pre>
<pre>		an index, see |:history-indexing|.  The respective entry will</pre>
<pre>		be removed if it exists.<p></pre>

<pre>		The result is a Number: 1 for a successful operation,</pre>
<pre>		otherwise 0 is returned.<p></pre>

<pre>		Examples:</pre>
<pre>		Clear expression register history: ></pre>
<pre>			:call histdel("expr")</pre>
<
<pre>		Remove all entries starting with "*" from the search history: ></pre>
<pre>			:call histdel("/", '^\*')</pre>
<
<pre>		The following three are equivalent: ></pre>
<pre>			:call histdel("search", histnr("search"))</pre>
<pre>			:call histdel("search", -1)</pre>
<pre>			:call histdel("search", '^'.histget("search", -1).'$')</pre>
<
<pre>		To delete the last search pattern and use the last-but-one for</pre>
<pre>		the "n" command and 'hlsearch': ></pre>
<pre>			:call histdel("search", -1)</pre>
<pre>			:let @/ = histget("search", -1)</pre>
<
<pre>		Can also be used as a |method|: ></pre>
<pre>			GetHistory()->histdel()<p></pre>

histget({history} [, {index}])				*histget()*
<pre>		The result is a String, the entry with Number {index} from</pre>
<pre>		{history}.  See |hist-names| for the possible values of</pre>
<pre>		{history}, and |:history-indexing| for {index}.  If there is</pre>
<pre>		no such entry, an empty String is returned.  When {index} is</pre>
<pre>		omitted, the most recent item from the history is used.<p></pre>

<pre>		Examples:</pre>
<pre>		Redo the second last search from history. ></pre>
<pre>			:execute '/' . histget("search", -2)<p></pre>

<		Define an Ex command ":H {num}" that supports re-execution of
<pre>		the {num}th entry from the output of |:history|. ></pre>
<pre>			:command -nargs=1 H execute histget("cmd", 0+<args>)</pre>
<
<pre>		Can also be used as a |method|: ></pre>
<pre>			GetHistory()->histget()<p></pre>

histnr({history})					*histnr()*
<pre>		The result is the Number of the current entry in {history}.</pre>
<pre>		See |hist-names| for the possible values of {history}.</pre>
<pre>		If an error occurred, -1 is returned.<p></pre>

<pre>		Example: ></pre>
<pre>			:let inp_index = histnr("expr")<p></pre>

<		Can also be used as a |method|: >
<pre>			GetHistory()->histnr()</pre>
<
hlexists({name})					*hlexists()*
<pre>		The result is a Number, which is non-zero if a highlight group</pre>
<pre>		called {name} exists.  This is when the group has been</pre>
<pre>		defined in some way.  Not necessarily when highlighting has</pre>
<pre>		been defined for it, it may also have been used for a syntax</pre>
<pre>		item.</pre>
<pre>							*highlight_exists()*</pre>
<pre>		Obsolete name: highlight_exists().<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetName()->hlexists()</pre>
<
<pre>							*hlID()*</pre>
hlID({name})	The result is a Number, which is the ID of the highlight group
<pre>		with name {name}.  When the highlight group doesn't exist,</pre>
<pre>		zero is returned.</pre>
<pre>		This can be used to retrieve information about the highlight</pre>
<pre>		group.  For example, to get the background color of the</pre>
<pre>		"Comment" group: ></pre>
<pre>	:echo synIDattr(synIDtrans(hlID("Comment")), "bg")</pre>
<							*highlightID()*
<pre>		Obsolete name: highlightID().<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetName()->hlID()<p></pre>

hostname()						*hostname()*
<pre>		The result is a String, which is the name of the machine on</pre>
<pre>		which Vim is currently running.  Machine names greater than</pre>
<pre>		256 characters long are truncated.<p></pre>

iconv({expr}, {from}, {to})				*iconv()*
<pre>		The result is a String, which is the text {expr} converted</pre>
<pre>		from encoding {from} to encoding {to}.</pre>
<pre>		When the conversion completely fails an empty string is</pre>
<pre>		returned.  When some characters could not be converted they</pre>
<pre>		are replaced with "?".</pre>
<pre>		The encoding names are whatever the iconv() library function</pre>
<pre>		can accept, see ":!man 3 iconv".</pre>
<pre>		Most conversions require Vim to be compiled with the |+iconv|</pre>
<pre>		feature.  Otherwise only UTF-8 to latin1 conversion and back</pre>
<pre>		can be done.</pre>
<pre>		This can be used to display messages with special characters,</pre>
<pre>		no matter what 'encoding' is set to.  Write the message in</pre>
<pre>		UTF-8 and use: ></pre>
<pre>			echo iconv(utf8_str, "utf-8", &enc)</pre>
<		Note that Vim uses UTF-8 for all Unicode encodings, conversion
<pre>		from/to UCS-2 is automatically changed to use UTF-8.  You</pre>
<pre>		cannot use UCS-2 in a string anyway, because of the NUL bytes.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetText()->iconv('latin1', 'utf-8')</pre>
<
<pre>							*indent()*</pre>
indent({lnum})	The result is a Number, which is indent of line {lnum} in the
<pre>		current buffer.  The indent is counted in spaces, the value</pre>
<pre>		of 'tabstop' is relevant.  {lnum} is used just like in</pre>
<pre>		|getline()|.</pre>
<pre>		When {lnum} is invalid -1 is returned.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetLnum()->indent()<p></pre>

index({object}, {expr} [, {start} [, {ic}]])			*index()*
<pre>		If {object} is a |List| return the lowest index where the item</pre>
<pre>		has a value equal to {expr}.  There is no automatic</pre>
<pre>		conversion, so the String "4" is different from the Number 4.</pre>
<pre>		And the number 4 is different from the Float 4.0.  The value</pre>
<pre>		of 'ignorecase' is not used here, case always matters.<p></pre>

<pre>		If {object} is |Blob| return the lowest index where the byte</pre>
<pre>		value is equal to {expr}.<p></pre>

<pre>		If {start} is given then start looking at the item with index</pre>
<pre>		{start} (may be negative for an item relative to the end).</pre>
<pre>		When {ic} is given and it is |TRUE|, ignore case.  Otherwise</pre>
<pre>		case must match.</pre>
<pre>		-1 is returned when {expr} is not found in {object}.</pre>
<pre>		Example: ></pre>
<pre>			:let idx = index(words, "the")</pre>
<pre>			:if index(numbers, 123) >= 0<p></pre>

<		Can also be used as a |method|: >
<pre>			GetObject()->index(what)<p></pre>

input({prompt} [, {text} [, {completion}]])		*input()*
<pre>		The result is a String, which is whatever the user typed on</pre>
<pre>		the command-line.  The {prompt} argument is either a prompt</pre>
<pre>		string, or a blank string (for no prompt).  A '\n' can be used</pre>
<pre>		in the prompt to start a new line.</pre>
<pre>		The highlighting set with |:echohl| is used for the prompt.</pre>
<pre>		The input is entered just like a command-line, with the same</pre>
<pre>		editing commands and mappings.  There is a separate history</pre>
<pre>		for lines typed for input().</pre>
<pre>		Example: ></pre>
<pre>			:if input("Coffee or beer? ") == "beer"</pre>
<pre>			:  echo "Cheers!"</pre>
<pre>			:endif</pre>
<
<pre>		If the optional {text} argument is present and not empty, this</pre>
<pre>		is used for the default reply, as if the user typed this.</pre>
<pre>		Example: ></pre>
<pre>			:let color = input("Color? ", "white")<p></pre>

<		The optional {completion} argument specifies the type of
<pre>		completion supported for the input.  Without it completion is</pre>
<pre>		not performed.  The supported completion types are the same as</pre>
<pre>		that can be supplied to a user-defined command using the</pre>
<pre>		"-complete=" argument.  Refer to |:command-completion| for</pre>
<pre>		more information.  Example: ></pre>
<pre>			let fname = input("File: ", "", "file")</pre>
<
<pre>		NOTE: This function must not be used in a startup file, for</pre>
<pre>		the versions that only run in GUI mode (e.g., the Win32 GUI).</pre>
<pre>		Note: When input() is called from within a mapping it will</pre>
<pre>		consume remaining characters from that mapping, because a</pre>
<pre>		mapping is handled like the characters were typed.</pre>
<pre>		Use |inputsave()| before input() and |inputrestore()|</pre>
<pre>		after input() to avoid that.  Another solution is to avoid</pre>
<pre>		that further characters follow in the mapping, e.g., by using</pre>
<pre>		|:execute| or |:normal|.<p></pre>

<pre>		Example with a mapping: ></pre>
<pre>			:nmap \x :call GetFoo()<CR>:exe "/" . Foo<CR></pre>
<pre>			:function GetFoo()</pre>
<pre>			:  call inputsave()</pre>
<pre>			:  let g:Foo = input("enter search pattern: ")</pre>
<pre>			:  call inputrestore()</pre>
<pre>			:endfunction<p></pre>

<		Can also be used as a |method|: >
<pre>			GetPrompt()->input()<p></pre>

inputdialog({prompt} [, {text} [, {cancelreturn}]])		*inputdialog()*
<pre>		Like |input()|, but when the GUI is running and text dialogs</pre>
<pre>		are supported, a dialog window pops up to input the text.</pre>
<pre>		Example: ></pre>
<pre>		   :let n = inputdialog("value for shiftwidth", shiftwidth())</pre>
<pre>		   :if n != ""</pre>
<pre>		   :  let &sw = n</pre>
<pre>		   :endif</pre>
<		When the dialog is cancelled {cancelreturn} is returned.  When
<pre>		omitted an empty string is returned.</pre>
<pre>		Hitting <Enter> works like pressing the OK button.  Hitting</pre>
<pre>		<Esc> works like pressing the Cancel button.</pre>
<pre>		NOTE: Command-line completion is not supported.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetPrompt()->inputdialog()<p></pre>

inputlist({textlist})					*inputlist()*
<pre>		{textlist} must be a |List| of strings.  This |List| is</pre>
<pre>		displayed, one string per line.  The user will be prompted to</pre>
<pre>		enter a number, which is returned.</pre>
<pre>		The user can also select an item by clicking on it with the</pre>
<pre>		mouse.  For the first string 0 is returned.  When clicking</pre>
<pre>		above the first item a negative number is returned.  When</pre>
<pre>		clicking on the prompt one more than the length of {textlist}</pre>
<pre>		is returned.</pre>
<pre>		Make sure {textlist} has less than 'lines' entries, otherwise</pre>
<pre>		it won't work.  It's a good idea to put the entry number at</pre>
<pre>		the start of the string.  And put a prompt in the first item.</pre>
<pre>		Example: ></pre>
<pre>			let color = inputlist(['Select color:', '1. red',</pre>
<pre>				\ '2. green', '3. blue'])<p></pre>

<		Can also be used as a |method|: >
<pre>			GetChoices()->inputlist()<p></pre>

inputrestore()						*inputrestore()*
<pre>		Restore typeahead that was saved with a previous |inputsave()|.</pre>
<pre>		Should be called the same number of times inputsave() is</pre>
<pre>		called.  Calling it more often is harmless though.</pre>
<pre>		Returns 1 when there is nothing to restore, 0 otherwise.<p></pre>

inputsave()						*inputsave()*
<pre>		Preserve typeahead (also from mappings) and clear it, so that</pre>
<pre>		a following prompt gets input from the user.  Should be</pre>
<pre>		followed by a matching inputrestore() after the prompt.  Can</pre>
<pre>		be used several times, in which case there must be just as</pre>
<pre>		many inputrestore() calls.</pre>
<pre>		Returns 1 when out of memory, 0 otherwise.<p></pre>

inputsecret({prompt} [, {text}])			*inputsecret()*
<pre>		This function acts much like the |input()| function with but</pre>
<pre>		two exceptions:</pre>
<pre>		a) the user's response will be displayed as a sequence of</pre>
<pre>		asterisks ("*") thereby keeping the entry secret, and</pre>
<pre>		b) the user's response will not be recorded on the input</pre>
<pre>		|history| stack.</pre>
<pre>		The result is a String, which is whatever the user actually</pre>
<pre>		typed on the command-line in response to the issued prompt.</pre>
<pre>		NOTE: Command-line completion is not supported.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetPrompt()->inputsecret()<p></pre>

insert({object}, {item} [, {idx}])			*insert()*
<pre>		When {object} is a |List| or a |Blob| insert {item} at the start</pre>
<pre>		of it.<p></pre>

<pre>		If {idx} is specified insert {item} before the item with index</pre>
<pre>		{idx}.  If {idx} is zero it goes before the first item, just</pre>
<pre>		like omitting {idx}.  A negative {idx} is also possible, see</pre>
<pre>		|list-index|.  -1 inserts just before the last item.<p></pre>

<pre>		Returns the resulting |List| or |Blob|.  Examples: ></pre>
<pre>			:let mylist = insert([2, 3, 5], 1)</pre>
<pre>			:call insert(mylist, 4, -1)</pre>
<pre>			:call insert(mylist, 6, len(mylist))</pre>
<		The last example can be done simpler with |add()|.
<pre>		Note that when {item} is a |List| it is inserted as a single</pre>
<pre>		item.  Use |extend()| to concatenate |Lists|.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			mylist->insert(item)<p></pre>

interrupt()						*interrupt()*
<pre>		Interrupt script execution.  It works more or less like the</pre>
<pre>		user typing CTRL-C, most commands won't execute and control</pre>
<pre>		returns to the user.  This is useful to abort execution</pre>
<pre>		from lower down, e.g. in an autocommand.  Example: ></pre>
<pre>		:function s:check_typoname(file)</pre>
<pre>		:   if fnamemodify(a:file, ':t') == '['</pre>
<pre>		:       echomsg 'Maybe typo'</pre>
<pre>		:       call interrupt()</pre>
<pre>		:   endif</pre>
<pre>		:endfunction</pre>
<pre>		:au BufWritePre * call s:check_typoname(expand('<amatch>'))<p></pre>

invert({expr})						*invert()*
<pre>		Bitwise invert.  The argument is converted to a number.  A</pre>
<pre>		List, Dict or Float argument causes an error.  Example: ></pre>
<pre>			:let bits = invert(bits)</pre>
<		Can also be used as a |method|: >
<pre>			:let bits = bits->invert()<p></pre>

isdirectory({directory})				*isdirectory()*
<pre>		The result is a Number, which is |TRUE| when a directory</pre>
<pre>		with the name {directory} exists.  If {directory} doesn't</pre>
<pre>		exist, or isn't a directory, the result is |FALSE|.  {directory}</pre>
<pre>		is any expression, which is used as a String.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetName()->isdirectory()<p></pre>

isinf({expr})						*isinf()*
<pre>		Return 1 if {expr} is a positive infinity, or -1 a negative</pre>
<pre>		infinity, otherwise 0. ></pre>
<pre>			:echo isinf(1.0 / 0.0)</pre>
<			1 >
<pre>			:echo isinf(-1.0 / 0.0)</pre>
<			-1<p>

<pre>		Can also be used as a |method|: ></pre>
<pre>			Compute()->isinf()</pre>
<
<pre>		{only available when compiled with the |+float| feature}<p></pre>

islocked({expr})					*islocked()* *E786*
<pre>		The result is a Number, which is |TRUE| when {expr} is the</pre>
<pre>		name of a locked variable.</pre>
<pre>		{expr} must be the name of a variable, |List| item or</pre>
<pre>		|Dictionary| entry, not the variable itself!  Example: ></pre>
<pre>			:let alist = [0, ['a', 'b'], 2, 3]</pre>
<pre>			:lockvar 1 alist</pre>
<pre>			:echo islocked('alist')		" 1</pre>
<pre>			:echo islocked('alist[1]')	" 0<p></pre>

<		When {expr} is a variable that does not exist you get an error
<pre>		message.  Use |exists()| to check for existence.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetName()->islocked()<p></pre>

isnan({expr})						*isnan()*
<pre>		Return |TRUE| if {expr} is a float with value NaN. ></pre>
<pre>			echo isnan(0.0 / 0.0)</pre>
<			1<p>

<pre>		Can also be used as a |method|: ></pre>
<pre>			Compute()->isnan()</pre>
<
<pre>		{only available when compiled with the |+float| feature}<p></pre>

items({dict})						*items()*
<pre>		Return a |List| with all the key-value pairs of {dict}.  Each</pre>
<pre>		|List| item is a list with two items: the key of a {dict}</pre>
<pre>		entry and the value of this entry.  The |List| is in arbitrary</pre>
<pre>		order.  Also see |keys()| and |values()|.</pre>
<pre>		Example: ></pre>
<pre>			for [key, value] in items(mydict)</pre>
<pre>			   echo key . ': ' . value</pre>
<pre>			endfor<p></pre>

<		Can also be used as a |method|: >
<pre>			mydict->items()<p></pre>

job_ functions are documented here: |job-functions-details|<p>


join({list} [, {sep}])					*join()*
<pre>		Join the items in {list} together into one String.</pre>
<pre>		When {sep} is specified it is put in between the items.  If</pre>
<pre>		{sep} is omitted a single space is used.</pre>
<pre>		Note that {sep} is not added at the end.  You might want to</pre>
<pre>		add it there too: ></pre>
<pre>			let lines = join(mylist, "\n") . "\n"</pre>
<		String items are used as-is.  |Lists| and |Dictionaries| are
<pre>		converted into a string like with |string()|.</pre>
<pre>		The opposite function is |split()|.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			mylist->join()<p></pre>

js_decode({string})					*js_decode()*
<pre>		This is similar to |json_decode()| with these differences:</pre>
<pre>		- Object key names do not have to be in quotes.</pre>
<pre>		- Strings can be in single quotes.</pre>
<pre>		- Empty items in an array (between two commas) are allowed and</pre>
<pre>		  result in v:none items.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			ReadObject()->js_decode()<p></pre>

js_encode({expr})					*js_encode()*
<pre>		This is similar to |json_encode()| with these differences:</pre>
<pre>		- Object key names are not in quotes.</pre>
<pre>		- v:none items in an array result in an empty item between</pre>
<pre>		  commas.</pre>
<pre>		For example, the Vim object:</pre>
<pre>			[1,v:none,{"one":1},v:none] ~</pre>
<pre>		Will be encoded as:</pre>
<pre>			[1,,{one:1},,] ~</pre>
<pre>		While json_encode() would produce:</pre>
<pre>			[1,null,{"one":1},null] ~</pre>
<pre>		This encoding is valid for JavaScript. It is more efficient</pre>
<pre>		than JSON, especially when using an array with optional items.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetObject()->js_encode()<p></pre>

json_decode({string})					*json_decode()*
<pre>		This parses a JSON formatted string and returns the equivalent</pre>
<pre>		in Vim values.  See |json_encode()| for the relation between</pre>
<pre>		JSON and Vim values.</pre>
<pre>		The decoding is permissive:</pre>
<pre>		- A trailing comma in an array and object is ignored, e.g.</pre>
<pre>		  "[1, 2, ]" is the same as "[1, 2]".</pre>
<pre>		- Integer keys are accepted in objects, e.g. {1:2} is the</pre>
<pre>		  same as {"1":2}.</pre>
<pre>		- More floating point numbers are recognized, e.g. "1." for</pre>
<pre>		  "1.0", or "001.2" for "1.2". Special floating point values</pre>
<pre>		  "Infinity", "-Infinity" and "NaN" (capitalization ignored)</pre>
<pre>		  are accepted.</pre>
<pre>		- Leading zeroes in integer numbers are ignored, e.g. "012"</pre>
<pre>		  for "12" or "-012" for "-12".</pre>
<pre>		- Capitalization is ignored in literal names null, true or</pre>
<pre>		  false, e.g. "NULL" for "null", "True" for "true".</pre>
<pre>		- Control characters U+0000 through U+001F which are not</pre>
<pre>		  escaped in strings are accepted, e.g. "	" (tab</pre>
<pre>		  character in string) for "\t".</pre>
<pre>		- An empty JSON expression or made of only spaces is accepted</pre>
<pre>		  and results in v:none.</pre>
<pre>		- Backslash in an invalid 2-character sequence escape is</pre>
<pre>		  ignored, e.g. "\a" is decoded as "a".</pre>
<pre>		- A correct surrogate pair in JSON strings should normally be</pre>
<pre>		  a 12 character sequence such as "\uD834\uDD1E", but</pre>
<pre>		  json_decode() silently accepts truncated surrogate pairs</pre>
<pre>		  such as "\uD834" or "\uD834\u"</pre>
<pre>								*E938*</pre>
<pre>		A duplicate key in an object, valid in rfc7159, is not</pre>
<pre>		accepted by json_decode() as the result must be a valid Vim</pre>
<pre>		type, e.g. this fails: {"a":"b", "a":"c"}<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			ReadObject()->json_decode()<p></pre>

json_encode({expr})					*json_encode()*
<pre>		Encode {expr} as JSON and return this as a string.</pre>
<pre>		The encoding is specified in:</pre>
<pre>		https://tools.ietf.org/html/rfc7159.html</pre>
<pre>		Vim values are converted as follows:</pre>
<pre>		   |Number|		decimal number</pre>
<pre>		   |Float|		floating point number</pre>
<pre>		   Float nan		"NaN"</pre>
<pre>		   Float inf		"Infinity"</pre>
<pre>		   Float -inf		"-Infinity"</pre>
<pre>		   |String|		in double quotes (possibly null)</pre>
<pre>		   |Funcref|		not possible, error</pre>
<pre>		   |List|		as an array (possibly null); when</pre>
<pre>					used recursively: []</pre>
<pre>		   |Dict|		as an object (possibly null); when</pre>
<pre>					used recursively: {}</pre>
<pre>		   |Blob|		as an array of the individual bytes</pre>
<pre>		   v:false		"false"</pre>
<pre>		   v:true		"true"</pre>
<pre>		   v:none		"null"</pre>
<pre>		   v:null		"null"</pre>
<pre>		Note that NaN and Infinity are passed on as values.  This is</pre>
<pre>		missing in the JSON standard, but several implementations do</pre>
<pre>		allow it.  If not then you will get an error.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetObject()->json_encode()<p></pre>

keys({dict})						*keys()*
<pre>		Return a |List| with all the keys of {dict}.  The |List| is in</pre>
<pre>		arbitrary order.  Also see |items()| and |values()|.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			mydict->keys()<p></pre>

<							*len()* *E701*
len({expr})	The result is a Number, which is the length of the argument.
<pre>		When {expr} is a String or a Number the length in bytes is</pre>
<pre>		used, as with |strlen()|.</pre>
<pre>		When {expr} is a |List| the number of items in the |List| is</pre>
<pre>		returned.</pre>
<pre>		When {expr} is a |Blob| the number of bytes is returned.</pre>
<pre>		When {expr} is a |Dictionary| the number of entries in the</pre>
<pre>		|Dictionary| is returned.</pre>
<pre>		Otherwise an error is given.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			mylist->len()<p></pre>

<						*libcall()* *E364* *E368*
libcall({libname}, {funcname}, {argument})
<pre>		Call function {funcname} in the run-time library {libname}</pre>
<pre>		with single argument {argument}.</pre>
<pre>		This is useful to call functions in a library that you</pre>
<pre>		especially made to be used with Vim.  Since only one argument</pre>
<pre>		is possible, calling standard library functions is rather</pre>
<pre>		limited.</pre>
<pre>		The result is the String returned by the function.  If the</pre>
<pre>		function returns NULL, this will appear as an empty string ""</pre>
<pre>		to Vim.</pre>
<pre>		If the function returns a number, use libcallnr()!</pre>
<pre>		If {argument} is a number, it is passed to the function as an</pre>
<pre>		int; if {argument} is a string, it is passed as a</pre>
<pre>		null-terminated string.</pre>
<pre>		This function will fail in |restricted-mode|.<p></pre>

<pre>		libcall() allows you to write your own 'plug-in' extensions to</pre>
<pre>		Vim without having to recompile the program.  It is NOT a</pre>
<pre>		means to call system functions!  If you try to do so Vim will</pre>
<pre>		very probably crash.<p></pre>

<pre>		For Win32, the functions you write must be placed in a DLL</pre>
<pre>		and use the normal C calling convention (NOT Pascal which is</pre>
<pre>		used in Windows System DLLs).  The function must take exactly</pre>
<pre>		one parameter, either a character pointer or a long integer,</pre>
<pre>		and must return a character pointer or NULL.  The character</pre>
<pre>		pointer returned must point to memory that will remain valid</pre>
<pre>		after the function has returned (e.g. in static data in the</pre>
<pre>		DLL).  If it points to allocated memory, that memory will</pre>
<pre>		leak away.  Using a static buffer in the function should work,</pre>
<pre>		it's then freed when the DLL is unloaded.<p></pre>

<pre>		WARNING: If the function returns a non-valid pointer, Vim may</pre>
<pre>		crash!	This also happens if the function returns a number,</pre>
<pre>		because Vim thinks it's a pointer.</pre>
<pre>		For Win32 systems, {libname} should be the filename of the DLL</pre>
<pre>		without the ".DLL" suffix.  A full path is only required if</pre>
<pre>		the DLL is not in the usual places.</pre>
<pre>		For Unix: When compiling your own plugins, remember that the</pre>
<pre>		object code must be compiled as position-independent ('PIC').</pre>
<pre>		{only in Win32 and some Unix versions, when the |+libcall|</pre>
<pre>		feature is present}</pre>
<pre>		Examples: ></pre>
<pre>			:echo libcall("libc.so", "getenv", "HOME")<p></pre>

<		Can also be used as a |method|, the base is passed as the
<pre>		third argument: ></pre>
<pre>			GetValue()->libcall("libc.so", "getenv")</pre>
<
<pre>							*libcallnr()*</pre>
libcallnr({libname}, {funcname}, {argument})
<pre>		Just like |libcall()|, but used for a function that returns an</pre>
<pre>		int instead of a string.</pre>
<pre>		{only in Win32 on some Unix versions, when the |+libcall|</pre>
<pre>		feature is present}</pre>
<pre>		Examples: ></pre>
<pre>			:echo libcallnr("/usr/lib/libc.so", "getpid", "")</pre>
<pre>			:call libcallnr("libc.so", "printf", "Hello World!\n")</pre>
<pre>			:call libcallnr("libc.so", "sleep", 10)</pre>
<
<pre>		Can also be used as a |method|, the base is passed as the</pre>
<pre>		third argument: ></pre>
<pre>			GetValue()->libcallnr("libc.so", "printf")</pre>
<<p>

line({expr} [, {winid}])				*line()*
<pre>		The result is a Number, which is the line number of the file</pre>
<pre>		position given with {expr}.  The accepted positions are:</pre>
<pre>		    .	    the cursor position</pre>
<pre>		    $	    the last line in the current buffer</pre>
<pre>		    'x	    position of mark x (if the mark is not set, 0 is</pre>
<pre>			    returned)</pre>
<pre>		    w0	    first line visible in current window (one if the</pre>
<pre>			    display isn't updated, e.g. in silent Ex mode)</pre>
<pre>		    w$	    last line visible in current window (this is one</pre>
<pre>			    less than "w0" if no lines are visible)</pre>
<pre>		    v	    In Visual mode: the start of the Visual area (the</pre>
<pre>			    cursor is the end).  When not in Visual mode</pre>
<pre>			    returns the cursor position.  Differs from |'<| in</pre>
<pre>			    that it's updated right away.</pre>
<pre>		Note that a mark in another file can be used.  The line number</pre>
<pre>		then applies to another buffer.</pre>
<pre>		To get the column number use |col()|.  To get both use</pre>
<pre>		|getpos()|.</pre>
<pre>		With the optional {winid} argument the values are obtained for</pre>
<pre>		that window instead of the current window.</pre>
<pre>		Examples: ></pre>
<pre>			line(".")		line number of the cursor</pre>
<pre>			line(".", winid)	idem, in window "winid"</pre>
<pre>			line("'t")		line number of mark t</pre>
<pre>			line("'" . marker)	line number of mark marker</pre>
<
<pre>		To jump to the last known position when opening a file see</pre>
<pre>		|last-position-jump|.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetValue()->line()<p></pre>

line2byte({lnum})					*line2byte()*
<pre>		Return the byte count from the start of the buffer for line</pre>
<pre>		{lnum}.  This includes the end-of-line character, depending on</pre>
<pre>		the 'fileformat' option for the current buffer.  The first</pre>
<pre>		line returns 1. 'encoding' matters, 'fileencoding' is ignored.</pre>
<pre>		This can also be used to get the byte count for the line just</pre>
<pre>		below the last line: ></pre>
<pre>			line2byte(line("$") + 1)</pre>
<		This is the buffer size plus one.  If 'fileencoding' is empty
<pre>		it is the file size plus one.</pre>
<pre>		When {lnum} is invalid, or the |+byte_offset| feature has been</pre>
<pre>		disabled at compile time, -1 is returned.</pre>
<pre>		Also see |byte2line()|, |go| and |:goto|.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetLnum()->line2byte()<p></pre>

lispindent({lnum})					*lispindent()*
<pre>		Get the amount of indent for line {lnum} according the lisp</pre>
<pre>		indenting rules, as with 'lisp'.</pre>
<pre>		The indent is counted in spaces, the value of 'tabstop' is</pre>
<pre>		relevant.  {lnum} is used just like in |getline()|.</pre>
<pre>		When {lnum} is invalid or Vim was not compiled the</pre>
<pre>		|+lispindent| feature, -1 is returned.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetLnum()->lispindent()<p></pre>

list2str({list} [, {utf8}])				*list2str()*
<pre>		Convert each number in {list} to a character string can</pre>
<pre>		concatenate them all.  Examples: ></pre>
<pre>			list2str([32])		returns " "</pre>
<pre>			list2str([65, 66, 67])	returns "ABC"</pre>
<		The same can be done (slowly) with: >
<pre>			join(map(list, {nr, val -> nr2char(val)}), '')</pre>
<		|str2list()| does the opposite.<p>

<pre>		When {utf8} is omitted or zero, the current 'encoding' is used.</pre>
<pre>		With {utf8} is 1, always return utf-8 characters.</pre>
<pre>		With utf-8 composing characters work as expected: ></pre>
<pre>			list2str([97, 769])	returns "á"</pre>
<
<pre>		Can also be used as a |method|: ></pre>
<pre>			GetList()->list2str()<p></pre>

listener_add({callback} [, {buf}])			*listener_add()*
<pre>		Add a callback function that will be invoked when changes have</pre>
<pre>		been made to buffer {buf}.</pre>
<pre>		{buf} refers to a buffer name or number. For the accepted</pre>
<pre>		values, see |bufname()|.  When {buf} is omitted the current</pre>
<pre>		buffer is used.</pre>
<pre>		Returns a unique ID that can be passed to |listener_remove()|.<p></pre>

<pre>		The {callback} is invoked with five arguments:</pre>
<pre>		    a:bufnr	the buffer that was changed</pre>
<pre>		    a:start	first changed line number</pre>
<pre>		    a:end	first line number below the change</pre>
<pre>		    a:added	number of lines added, negative if lines were</pre>
<pre>				deleted</pre>
<pre>		    a:changes	a List of items with details about the changes<p></pre>

<pre>		Example: ></pre>
<pre>	    func Listener(bufnr, start, end, added, changes)</pre>
<pre>	      echo 'lines ' .. a:start .. ' until ' .. a:end .. ' changed'</pre>
<pre>	    endfunc</pre>
<pre>	    call listener_add('Listener', bufnr)<p></pre>

<		The List cannot be changed.  Each item in a:changes is a
<pre>		dictionary with these entries:</pre>
<pre>		    lnum	the first line number of the change</pre>
<pre>		    end		the first line below the change</pre>
<pre>		    added	number of lines added; negative if lines were</pre>
<pre>				deleted</pre>
<pre>		    col		first column in "lnum" that was affected by</pre>
<pre>				the change; one if unknown or the whole line</pre>
<pre>				was affected; this is a byte index, first</pre>
<pre>				character has a value of one.</pre>
<pre>		When lines are inserted the values are:</pre>
<pre>		    lnum	line above which the new line is added</pre>
<pre>		    end		equal to "lnum"</pre>
<pre>		    added	number of lines inserted</pre>
<pre>		    col		1</pre>
<pre>		When lines are deleted the values are:</pre>
<pre>		    lnum	the first deleted line</pre>
<pre>		    end		the line below the first deleted line, before</pre>
<pre>				the deletion was done</pre>
<pre>		    added	negative, number of lines deleted</pre>
<pre>		    col		1</pre>
<pre>		When lines are changed:</pre>
<pre>		    lnum	the first changed line</pre>
<pre>		    end		the line below the last changed line</pre>
<pre>		    added	0</pre>
<pre>		    col		first column with a change or 1<p></pre>

<pre>		The entries are in the order the changes were made, thus the</pre>
<pre>		most recent change is at the end.  The line numbers are valid</pre>
<pre>		when the callback is invoked, but later changes may make them</pre>
<pre>		invalid, thus keeping a copy for later might not work.<p></pre>

<pre>		The {callback} is invoked just before the screen is updated,</pre>
<pre>		when |listener_flush()| is called or when a change is being</pre>
<pre>		made that changes the line count in a way it causes a line</pre>
<pre>		number in the list of changes to become invalid.<p></pre>

<pre>		The {callback} is invoked with the text locked, see</pre>
<pre>		|textlock|.  If you do need to make changes to the buffer, use</pre>
<pre>		a timer to do this later |timer_start()|.<p></pre>

<pre>		The {callback} is not invoked when the buffer is first loaded.</pre>
<pre>		Use the |BufReadPost| autocmd event to handle the initial text</pre>
<pre>		of a buffer.</pre>
<pre>		The {callback} is also not invoked when the buffer is</pre>
<pre>		unloaded, use the |BufUnload| autocmd event for that.<p></pre>

<pre>		Can also be used as a |method|, the base is passed as the</pre>
<pre>		second argument: ></pre>
<pre>			GetBuffer()->listener_add(callback)<p></pre>

listener_flush([{buf}])					*listener_flush()*
<pre>		Invoke listener callbacks for buffer {buf}.  If there are no</pre>
<pre>		pending changes then no callbacks are invoked.<p></pre>

<pre>		{buf} refers to a buffer name or number. For the accepted</pre>
<pre>		values, see |bufname()|.  When {buf} is omitted the current</pre>
<pre>		buffer is used.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetBuffer()->listener_flush()<p></pre>

listener_remove({id})					*listener_remove()*
<pre>		Remove a listener previously added with listener_add().</pre>
<pre>		Returns zero when {id} could not be found, one when {id} was</pre>
<pre>		removed.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetListenerId()->listener_remove()<p></pre>

localtime()						*localtime()*
<pre>		Return the current time, measured as seconds since 1st Jan</pre>
<pre>		1970.  See also |strftime()|, |strptime()| and |getftime()|.<p></pre>


log({expr})						*log()*
<pre>		Return the natural logarithm (base e) of {expr} as a |Float|.</pre>
<pre>		{expr} must evaluate to a |Float| or a |Number| in the range</pre>
<pre>		(0, inf].</pre>
<pre>		Examples: ></pre>
<pre>			:echo log(10)</pre>
<			2.302585 >
<pre>			:echo log(exp(5))</pre>
<			5.0<p>

<pre>		Can also be used as a |method|: ></pre>
<pre>			Compute()->log()</pre>
<
<pre>		{only available when compiled with the |+float| feature}<p></pre>


log10({expr})						*log10()*
<pre>		Return the logarithm of Float {expr} to base 10 as a |Float|.</pre>
<pre>		{expr} must evaluate to a |Float| or a |Number|.</pre>
<pre>		Examples: ></pre>
<pre>			:echo log10(1000)</pre>
<			3.0 >
<pre>			:echo log10(0.01)</pre>
<			-2.0<p>

<pre>		Can also be used as a |method|: ></pre>
<pre>			Compute()->log10()</pre>
<
<pre>		{only available when compiled with the |+float| feature}<p></pre>

luaeval({expr} [, {expr}])					*luaeval()*
<pre>		Evaluate Lua expression {expr} and return its result converted</pre>
<pre>		to Vim data structures. Second {expr} may hold additional</pre>
<pre>		argument accessible as _A inside first {expr}.</pre>
<pre>		Strings are returned as they are.</pre>
<pre>		Boolean objects are converted to numbers.</pre>
<pre>		Numbers are converted to |Float| values if vim was compiled</pre>
<pre>		with |+float| and to numbers otherwise.</pre>
<pre>		Dictionaries and lists obtained by vim.eval() are returned</pre>
<pre>		as-is.</pre>
<pre>		Other objects are returned as zero without any errors.</pre>
<pre>		See |lua-luaeval| for more details.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetExpr()->luaeval()<p></pre>

<		{only available when compiled with the |+lua| feature}<p>

map({expr1}, {expr2})					*map()*
<pre>		{expr1} must be a |List| or a |Dictionary|.</pre>
<pre>		Replace each item in {expr1} with the result of evaluating</pre>
<pre>		{expr2}.  {expr2} must be a |string| or |Funcref|.<p></pre>

<pre>		If {expr2} is a |string|, inside {expr2} |v:val| has the value</pre>
<pre>		of the current item.  For a |Dictionary| |v:key| has the key</pre>
<pre>		of the current item and for a |List| |v:key| has the index of</pre>
<pre>		the current item.</pre>
<pre>		Example: ></pre>
<pre>			:call map(mylist, '"> " . v:val . " <"')</pre>
<		This puts "> " before and " <" after each item in "mylist".<p>

<pre>		Note that {expr2} is the result of an expression and is then</pre>
<pre>		used as an expression again.  Often it is good to use a</pre>
<pre>		|literal-string| to avoid having to double backslashes.  You</pre>
<pre>		still have to double ' quotes<p></pre>

<pre>		If {expr2} is a |Funcref| it is called with two arguments:</pre>
<pre>			1. The key or the index of the current item.</pre>
<pre>			2. the value of the current item.</pre>
<pre>		The function must return the new value of the item. Example</pre>
<pre>		that changes each value by "key-value": ></pre>
<pre>			func KeyValue(key, val)</pre>
<pre>			  return a:key . '-' . a:val</pre>
<pre>			endfunc</pre>
<pre>			call map(myDict, function('KeyValue'))</pre>
<		It is shorter when using a |lambda|: >
<pre>			call map(myDict, {key, val -> key . '-' . val})</pre>
<		If you do not use "val" you can leave it out: >
<pre>			call map(myDict, {key -> 'item: ' . key})</pre>
<		If you do not use "key" you can use a short name: >
<pre>			call map(myDict, {_, val -> 'item: ' . val})</pre>
<
<pre>		The operation is done in-place.  If you want a |List| or</pre>
<pre>		|Dictionary| to remain unmodified make a copy first: ></pre>
<pre>			:let tlist = map(copy(mylist), ' v:val . "\t"')<p></pre>

<		Returns {expr1}, the |List| or |Dictionary| that was filtered.
<pre>		When an error is encountered while evaluating {expr2} no</pre>
<pre>		further items in {expr1} are processed.  When {expr2} is a</pre>
<pre>		Funcref errors inside a function are ignored, unless it was</pre>
<pre>		defined with the "abort" flag.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			mylist->map(expr2)<p></pre>

maparg({name} [, {mode} [, {abbr} [, {dict}]]])			*maparg()*
<pre>		When {dict} is omitted or zero: Return the rhs of mapping</pre>
<pre>		{name} in mode {mode}.  The returned String has special</pre>
<pre>		characters translated like in the output of the ":map" command</pre>
<pre>		listing.<p></pre>

<pre>		When there is no mapping for {name}, an empty String is</pre>
<pre>		returned.  When the mapping for {name} is empty, then "<Nop>"</pre>
<pre>		is returned.<p></pre>

<pre>		The {name} can have special key names, like in the ":map"</pre>
<pre>		command.<p></pre>

<pre>		{mode} can be one of these strings:</pre>
<pre>			"n"	Normal</pre>
<pre>			"v"	Visual (including Select)</pre>
<pre>			"o"	Operator-pending</pre>
<pre>			"i"	Insert</pre>
<pre>			"c"	Cmd-line</pre>
<pre>			"s"	Select</pre>
<pre>			"x"	Visual</pre>
<pre>			"l"	langmap |language-mapping|</pre>
<pre>			"t"	Terminal-Job</pre>
<pre>			""	Normal, Visual and Operator-pending</pre>
<pre>		When {mode} is omitted, the modes for "" are used.<p></pre>

<pre>		When {abbr} is there and it is |TRUE| use abbreviations</pre>
<pre>		instead of mappings.<p></pre>

<pre>		When {dict} is there and it is |TRUE| return a dictionary</pre>
<pre>		containing all the information of the mapping with the</pre>
<pre>		following items:</pre>
<pre>		  "lhs"	     The {lhs} of the mapping.</pre>
<pre>		  "rhs"	     The {rhs} of the mapping as typed.</pre>
<pre>		  "silent"   1 for a |:map-silent| mapping, else 0.</pre>
<pre>		  "noremap"  1 if the {rhs} of the mapping is not remappable.</pre>
<pre>		  "expr"     1 for an expression mapping (|:map-<expr>|).</pre>
<pre>		  "buffer"   1 for a buffer local mapping (|:map-local|).</pre>
<pre>		  "mode"     Modes for which the mapping is defined. In</pre>
<pre>			     addition to the modes mentioned above, these</pre>
<pre>			     characters will be used:</pre>
<pre>			     " "     Normal, Visual and Operator-pending</pre>
<pre>			     "!"     Insert and Commandline mode</pre>
<pre>				     (|mapmode-ic|)</pre>
<pre>		  "sid"	     The script local ID, used for <sid> mappings</pre>
<pre>			     (|<SID>|).</pre>
<pre>		  "lnum"     The line number in "sid", zero if unknown.</pre>
<pre>		  "nowait"   Do not wait for other, longer mappings.</pre>
<pre>			     (|:map-<nowait>|).<p></pre>

<pre>		The mappings local to the current buffer are checked first,</pre>
<pre>		then the global mappings.</pre>
<pre>		This function can be used to map a key even when it's already</pre>
<pre>		mapped, and have it do the original mapping too.  Sketch: ></pre>
<pre>			exe 'nnoremap <Tab> ==' . maparg('<Tab>', 'n')<p></pre>

<		Can also be used as a |method|: >
<pre>			GetKey()->maparg('n')<p></pre>

mapcheck({name} [, {mode} [, {abbr}]])			*mapcheck()*
<pre>		Check if there is a mapping that matches with {name} in mode</pre>
<pre>		{mode}.  See |maparg()| for {mode} and special names in</pre>
<pre>		{name}.</pre>
<pre>		When {abbr} is there and it is |TRUE| use abbreviations</pre>
<pre>		instead of mappings.</pre>
<pre>		A match happens with a mapping that starts with {name} and</pre>
<pre>		with a mapping which is equal to the start of {name}.<p></pre>

<pre>			matches mapping "a"	"ab"	"abc" ~</pre>
<pre>		   mapcheck("a")	yes	yes	 yes</pre>
<pre>		   mapcheck("abc")	yes	yes	 yes</pre>
<pre>		   mapcheck("ax")	yes	no	 no</pre>
<pre>		   mapcheck("b")	no	no	 no<p></pre>

<pre>		The difference with maparg() is that mapcheck() finds a</pre>
<pre>		mapping that matches with {name}, while maparg() only finds a</pre>
<pre>		mapping for {name} exactly.</pre>
<pre>		When there is no mapping that starts with {name}, an empty</pre>
<pre>		String is returned.  If there is one, the RHS of that mapping</pre>
<pre>		is returned.  If there are several mappings that start with</pre>
<pre>		{name}, the RHS of one of them is returned.  This will be</pre>
<pre>		"<Nop>" if the RHS is empty.</pre>
<pre>		The mappings local to the current buffer are checked first,</pre>
<pre>		then the global mappings.</pre>
<pre>		This function can be used to check if a mapping can be added</pre>
<pre>		without being ambiguous.  Example: ></pre>
<pre>	:if mapcheck("_vv") == ""</pre>
<pre>	:   map _vv :set guifont=7x13<CR></pre>
<pre>	:endif</pre>
<		This avoids adding the "_vv" mapping when there already is a
<pre>		mapping for "_v" or for "_vvv".<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetKey()->mapcheck('n')<p></pre>

match({expr}, {pat} [, {start} [, {count}]])			*match()*
<pre>		When {expr} is a |List| then this returns the index of the</pre>
<pre>		first item where {pat} matches.  Each item is used as a</pre>
<pre>		String, |Lists| and |Dictionaries| are used as echoed.<p></pre>

<pre>		Otherwise, {expr} is used as a String.  The result is a</pre>
<pre>		Number, which gives the index (byte offset) in {expr} where</pre>
<pre>		{pat} matches.<p></pre>

<pre>		A match at the first character or |List| item returns zero.</pre>
<pre>		If there is no match -1 is returned.<p></pre>

<pre>		For getting submatches see |matchlist()|.</pre>
<pre>		Example: ></pre>
<pre>			:echo match("testing", "ing")	" results in 4</pre>
<pre>			:echo match([1, 'x'], '\a')	" results in 1</pre>
<		See |string-match| for how {pat} is used.
<pre>								*strpbrk()*</pre>
<pre>		Vim doesn't have a strpbrk() function.  But you can do: ></pre>
<pre>			:let sepidx = match(line, '[.,;: \t]')</pre>
<								*strcasestr()*
<pre>		Vim doesn't have a strcasestr() function.  But you can add</pre>
<pre>		"\c" to the pattern to ignore case: ></pre>
<pre>			:let idx = match(haystack, '\cneedle')</pre>
<
<pre>		If {start} is given, the search starts from byte index</pre>
<pre>		{start} in a String or item {start} in a |List|.</pre>
<pre>		The result, however, is still the index counted from the</pre>
<pre>		first character/item.  Example: ></pre>
<pre>			:echo match("testing", "ing", 2)</pre>
<		result is again "4". >
<pre>			:echo match("testing", "ing", 4)</pre>
<		result is again "4". >
<pre>			:echo match("testing", "t", 2)</pre>
<		result is "3".
<pre>		For a String, if {start} > 0 then it is like the string starts</pre>
<pre>		{start} bytes later, thus "^" will match at {start}.  Except</pre>
<pre>		when {count} is given, then it's like matches before the</pre>
<pre>		{start} byte are ignored (this is a bit complicated to keep it</pre>
<pre>		backwards compatible).</pre>
<pre>		For a String, if {start} < 0, it will be set to 0.  For a list</pre>
<pre>		the index is counted from the end.</pre>
<pre>		If {start} is out of range ({start} > strlen({expr}) for a</pre>
<pre>		String or {start} > len({expr}) for a |List|) -1 is returned.<p></pre>

<pre>		When {count} is given use the {count}'th match.  When a match</pre>
<pre>		is found in a String the search for the next one starts one</pre>
<pre>		character further.  Thus this example results in 1: ></pre>
<pre>			echo match("testing", "..", 0, 2)</pre>
<		In a |List| the search continues in the next item.
<pre>		Note that when {count} is added the way {start} works changes,</pre>
<pre>		see above.<p></pre>

<pre>		See |pattern| for the patterns that are accepted.</pre>
<pre>		The 'ignorecase' option is used to set the ignore-caseness of</pre>
<pre>		the pattern.  'smartcase' is NOT used.  The matching is always</pre>
<pre>		done like 'magic' is set and 'cpoptions' is empty.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetList()->match('word')</pre>
<
<pre>				*matchadd()* *E798* *E799* *E801* *E957*</pre>
matchadd({group}, {pattern} [, {priority} [, {id} [, {dict}]]])
<pre>		Defines a pattern to be highlighted in the current window (a</pre>
<pre>		"match").  It will be highlighted with {group}.  Returns an</pre>
<pre>		identification number (ID), which can be used to delete the</pre>
<pre>		match using |matchdelete()|.  The ID is bound to the window.</pre>
<pre>		Matching is case sensitive and magic, unless case sensitivity</pre>
<pre>		or magicness are explicitly overridden in {pattern}.  The</pre>
<pre>		'magic', 'smartcase' and 'ignorecase' options are not used.</pre>
<pre>		The "Conceal" value is special, it causes the match to be</pre>
<pre>		concealed.<p></pre>

<pre>		The optional {priority} argument assigns a priority to the</pre>
<pre>		match.  A match with a high priority will have its</pre>
<pre>		highlighting overrule that of a match with a lower priority.</pre>
<pre>		A priority is specified as an integer (negative numbers are no</pre>
<pre>		exception).  If the {priority} argument is not specified, the</pre>
<pre>		default priority is 10.  The priority of 'hlsearch' is zero,</pre>
<pre>		hence all matches with a priority greater than zero will</pre>
<pre>		overrule it.  Syntax highlighting (see 'syntax') is a separate</pre>
<pre>		mechanism, and regardless of the chosen priority a match will</pre>
<pre>		always overrule syntax highlighting.<p></pre>

<pre>		The optional {id} argument allows the request for a specific</pre>
<pre>		match ID.  If a specified ID is already taken, an error</pre>
<pre>		message will appear and the match will not be added.  An ID</pre>
<pre>		is specified as a positive integer (zero excluded).  IDs 1, 2</pre>
<pre>		and 3 are reserved for |:match|, |:2match| and |:3match|,</pre>
<pre>		respectively.  If the {id} argument is not specified or -1,</pre>
<pre>		|matchadd()| automatically chooses a free ID.<p></pre>

<pre>		The optional {dict} argument allows for further custom</pre>
<pre>		values. Currently this is used to specify a match specific</pre>
<pre>		conceal character that will be shown for |hl-Conceal|</pre>
<pre>		highlighted matches. The dict can have the following members:<p></pre>

<pre>			conceal	    Special character to show instead of the</pre>
<pre>				    match (only for |hl-Conceal| highlighted</pre>
<pre>				    matches, see |:syn-cchar|)</pre>
<pre>			window	    Instead of the current window use the</pre>
<pre>				    window with this number or window ID.<p></pre>

<pre>		The number of matches is not limited, as it is the case with</pre>
<pre>		the |:match| commands.<p></pre>

<pre>		Example: ></pre>
<pre>			:highlight MyGroup ctermbg=green guibg=green</pre>
<pre>			:let m = matchadd("MyGroup", "TODO")</pre>
<		Deletion of the pattern: >
<pre>			:call matchdelete(m)<p></pre>

<		A list of matches defined by |matchadd()| and |:match| are
<pre>		available from |getmatches()|.  All matches can be deleted in</pre>
<pre>		one operation by |clearmatches()|.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetGroup()->matchadd('TODO')</pre>
<
<pre>							*matchaddpos()*</pre>
matchaddpos({group}, {pos} [, {priority} [, {id} [, {dict}]]])
<pre>		Same as |matchadd()|, but requires a list of positions {pos}</pre>
<pre>		instead of a pattern. This command is faster than |matchadd()|</pre>
<pre>		because it does not require to handle regular expressions and</pre>
<pre>		sets buffer line boundaries to redraw screen. It is supposed</pre>
<pre>		to be used when fast match additions and deletions are</pre>
<pre>		required, for example to highlight matching parentheses.<p></pre>

<pre>		The list {pos} can contain one of these items:</pre>
<pre>		- A number.  This whole line will be highlighted.  The first</pre>
<pre>		  line has number 1.</pre>
<pre>		- A list with one number, e.g., [23]. The whole line with this</pre>
<pre>		  number will be highlighted.</pre>
<pre>		- A list with two numbers, e.g., [23, 11]. The first number is</pre>
<pre>		  the line number, the second one is the column number (first</pre>
<pre>		  column is 1, the value must correspond to the byte index as</pre>
<pre>		  |col()| would return).  The character at this position will</pre>
<pre>		  be highlighted.</pre>
<pre>		- A list with three numbers, e.g., [23, 11, 3]. As above, but</pre>
<pre>		  the third number gives the length of the highlight in bytes.<p></pre>

<pre>		The maximum number of positions is 8.<p></pre>

<pre>		Example: ></pre>
<pre>			:highlight MyGroup ctermbg=green guibg=green</pre>
<pre>			:let m = matchaddpos("MyGroup", [[23, 24], 34])</pre>
<		Deletion of the pattern: >
<pre>			:call matchdelete(m)<p></pre>

<		Matches added by |matchaddpos()| are returned by
<pre>		|getmatches()| with an entry "pos1", "pos2", etc., with the</pre>
<pre>		value a list like the {pos} item.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetGroup()->matchaddpos([23, 11])<p></pre>

matcharg({nr})							*matcharg()*
<pre>		Selects the {nr} match item, as set with a |:match|,</pre>
<pre>		|:2match| or |:3match| command.</pre>
<pre>		Return a |List| with two elements:</pre>
<pre>			The name of the highlight group used</pre>
<pre>			The pattern used.</pre>
<pre>		When {nr} is not 1, 2 or 3 returns an empty |List|.</pre>
<pre>		When there is no match item set returns ['', ''].</pre>
<pre>		This is useful to save and restore a |:match|.</pre>
<pre>		Highlighting matches using the |:match| commands are limited</pre>
<pre>		to three matches. |matchadd()| does not have this limitation.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetMatch()->matcharg()<p></pre>

matchdelete({id} [, {win})		       *matchdelete()* *E802* *E803*
<pre>		Deletes a match with ID {id} previously defined by |matchadd()|</pre>
<pre>		or one of the |:match| commands.  Returns 0 if successful,</pre>
<pre>		otherwise -1.  See example for |matchadd()|.  All matches can</pre>
<pre>		be deleted in one operation by |clearmatches()|.</pre>
<pre>		If {win} is specified, use the window with this number or</pre>
<pre>		window ID instead of the current window.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetMatch()->matchdelete()<p></pre>

matchend({expr}, {pat} [, {start} [, {count}]])			*matchend()*
<pre>		Same as |match()|, but return the index of first character</pre>
<pre>		after the match.  Example: ></pre>
<pre>			:echo matchend("testing", "ing")</pre>
<		results in "7".
<pre>							*strspn()* *strcspn()*</pre>
<pre>		Vim doesn't have a strspn() or strcspn() function, but you can</pre>
<pre>		do it with matchend(): ></pre>
<pre>			:let span = matchend(line, '[a-zA-Z]')</pre>
<pre>			:let span = matchend(line, '[^a-zA-Z]')</pre>
<		Except that -1 is returned when there are no matches.<p>

<pre>		The {start}, if given, has the same meaning as for |match()|. ></pre>
<pre>			:echo matchend("testing", "ing", 2)</pre>
<		results in "7". >
<pre>			:echo matchend("testing", "ing", 5)</pre>
<		result is "-1".
<pre>		When {expr} is a |List| the result is equal to |match()|.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetText()->matchend('word')<p></pre>

matchlist({expr}, {pat} [, {start} [, {count}]])		*matchlist()*
<pre>		Same as |match()|, but return a |List|.  The first item in the</pre>
<pre>		list is the matched string, same as what matchstr() would</pre>
<pre>		return.  Following items are submatches, like "\1", "\2", etc.</pre>
<pre>		in |:substitute|.  When an optional submatch didn't match an</pre>
<pre>		empty string is used.  Example: ></pre>
<pre>			echo matchlist('acd', '\(a\)\?\(b\)\?\(c\)\?\(.*\)')</pre>
<		Results in: ['acd', 'a', '', 'c', 'd', '', '', '', '', '']
<pre>		When there is no match an empty list is returned.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetList()->matchlist('word')<p></pre>

matchstr({expr}, {pat} [, {start} [, {count}]])			*matchstr()*
<pre>		Same as |match()|, but return the matched string.  Example: ></pre>
<pre>			:echo matchstr("testing", "ing")</pre>
<		results in "ing".
<pre>		When there is no match "" is returned.</pre>
<pre>		The {start}, if given, has the same meaning as for |match()|. ></pre>
<pre>			:echo matchstr("testing", "ing", 2)</pre>
<		results in "ing". >
<pre>			:echo matchstr("testing", "ing", 5)</pre>
<		result is "".
<pre>		When {expr} is a |List| then the matching item is returned.</pre>
<pre>		The type isn't changed, it's not necessarily a String.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetText()->matchstr('word')<p></pre>

matchstrpos({expr}, {pat} [, {start} [, {count}]])		*matchstrpos()*
<pre>		Same as |matchstr()|, but return the matched string, the start</pre>
<pre>		position and the end position of the match.  Example: ></pre>
<pre>			:echo matchstrpos("testing", "ing")</pre>
<		results in ["ing", 4, 7].
<pre>		When there is no match ["", -1, -1] is returned.</pre>
<pre>		The {start}, if given, has the same meaning as for |match()|. ></pre>
<pre>			:echo matchstrpos("testing", "ing", 2)</pre>
<		results in ["ing", 4, 7]. >
<pre>			:echo matchstrpos("testing", "ing", 5)</pre>
<		result is ["", -1, -1].
<pre>		When {expr} is a |List| then the matching item, the index</pre>
<pre>		of first item where {pat} matches, the start position and the</pre>
<pre>		end position of the match are returned. ></pre>
<pre>			:echo matchstrpos([1, '__x'], '\a')</pre>
<		result is ["x", 1, 2, 3].
<pre>		The type isn't changed, it's not necessarily a String.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetText()->matchstrpos('word')</pre>
<
<pre>							*max()*</pre>
max({expr})	Return the maximum value of all items in {expr}.
<pre>		{expr} can be a list or a dictionary.  For a dictionary,</pre>
<pre>		it returns the maximum of all values in the dictionary.</pre>
<pre>		If {expr} is neither a list nor a dictionary, or one of the</pre>
<pre>		items in {expr} cannot be used as a Number this results in</pre>
<pre>		an error.  An empty |List| or |Dictionary| results in zero.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			mylist->max()<p></pre>

<							*min()*
min({expr})	Return the minimum value of all items in {expr}.
<pre>		{expr} can be a list or a dictionary.  For a dictionary,</pre>
<pre>		it returns the minimum of all values in the dictionary.</pre>
<pre>		If {expr} is neither a list nor a dictionary, or one of the</pre>
<pre>		items in {expr} cannot be used as a Number this results in</pre>
<pre>		an error.  An empty |List| or |Dictionary| results in zero.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			mylist->min()<p></pre>

<							*mkdir()* *E739*
mkdir({name} [, {path} [, {prot}]])
<pre>		Create directory {name}.<p></pre>

<pre>		If {path} is "p" then intermediate directories are created as</pre>
<pre>		necessary.  Otherwise it must be "".<p></pre>

<pre>		If {prot} is given it is used to set the protection bits of</pre>
<pre>		the new directory.  The default is 0755 (rwxr-xr-x: r/w for</pre>
<pre>		the user readable for others).  Use 0700 to make it unreadable</pre>
<pre>		for others.  This is only used for the last part of {name}.</pre>
<pre>		Thus if you create /tmp/foo/bar then /tmp/foo will be created</pre>
<pre>		with 0755.</pre>
<pre>		Example: ></pre>
<pre>			:call mkdir($HOME . "/tmp/foo/bar", "p", 0700)<p></pre>

<		This function is not available in the |sandbox|.<p>

<pre>		There is no error if the directory already exists and the "p"</pre>
<pre>		flag is passed (since patch 8.0.1708).  However, without the</pre>
<pre>		"p" option the call will fail.<p></pre>

<pre>		The function result is a Number, which is 1 if the call was</pre>
<pre>		successful or 0 if the directory creation failed or partly</pre>
<pre>		failed.<p></pre>

<pre>		Not available on all systems.  To check use: ></pre>
<pre>			:if exists("*mkdir")<p></pre>

<		Can also be used as a |method|: >
<pre>			GetName()->mkdir()</pre>
<
<pre>							*mode()*</pre>
mode([expr])	Return a string that indicates the current mode.
<pre>		If [expr] is supplied and it evaluates to a non-zero Number or</pre>
<pre>		a non-empty String (|non-zero-arg|), then the full mode is</pre>
<pre>		returned, otherwise only the first letter is returned.</pre>
<pre>		Also see |state()|.<p></pre>

<pre>		   n	    Normal, Terminal-Normal</pre>
<pre>		   no	    Operator-pending</pre>
<pre>		   nov	    Operator-pending (forced characterwise |o_v|)</pre>
<pre>		   noV	    Operator-pending (forced linewise |o_V|)</pre>
<pre>		   noCTRL-V Operator-pending (forced blockwise |o_CTRL-V|);</pre>
<pre>				CTRL-V is one character</pre>
<pre>		   niI	    Normal using |i_CTRL-O| in |Insert-mode|</pre>
<pre>		   niR	    Normal using |i_CTRL-O| in |Replace-mode|</pre>
<pre>		   niV	    Normal using |i_CTRL-O| in |Virtual-Replace-mode|</pre>
<pre>		   v	    Visual by character</pre>
<pre>		   V	    Visual by line</pre>
<pre>		   CTRL-V   Visual blockwise</pre>
<pre>		   s	    Select by character</pre>
<pre>		   S	    Select by line</pre>
<pre>		   CTRL-S   Select blockwise</pre>
<pre>		   i	    Insert</pre>
<pre>		   ic	    Insert mode completion |compl-generic|</pre>
<pre>		   ix	    Insert mode |i_CTRL-X| completion</pre>
<pre>		   R	    Replace |R|</pre>
<pre>		   Rc	    Replace mode completion |compl-generic|</pre>
<pre>		   Rv	    Virtual Replace |gR|</pre>
<pre>		   Rx	    Replace mode |i_CTRL-X| completion</pre>
<pre>		   c	    Command-line editing</pre>
<pre>		   cv	    Vim Ex mode |gQ|</pre>
<pre>		   ce	    Normal Ex mode |Q|</pre>
<pre>		   r	    Hit-enter prompt</pre>
<pre>		   rm	    The -- more -- prompt</pre>
<pre>		   r?	    A |:confirm| query of some sort</pre>
<pre>		   !	    Shell or external command is executing</pre>
<pre>		   t	    Terminal-Job mode: keys go to the job</pre>
<pre>		This is useful in the 'statusline' option or when used</pre>
<pre>		with |remote_expr()| In most other places it always returns</pre>
<pre>		"c" or "n".</pre>
<pre>		Note that in the future more modes and more specific modes may</pre>
<pre>		be added. It's better not to compare the whole string but only</pre>
<pre>		the leading character(s).</pre>
<pre>		Also see |visualmode()|.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			DoFull()->mode()<p></pre>

mzeval({expr})							*mzeval()*
<pre>		Evaluate MzScheme expression {expr} and return its result</pre>
<pre>		converted to Vim data structures.</pre>
<pre>		Numbers and strings are returned as they are.</pre>
<pre>		Pairs (including lists and improper lists) and vectors are</pre>
<pre>		returned as Vim |Lists|.</pre>
<pre>		Hash tables are represented as Vim |Dictionary| type with keys</pre>
<pre>		converted to strings.</pre>
<pre>		All other types are converted to string with display function.</pre>
<pre>		Examples: ></pre>
<pre>		    :mz (define l (list 1 2 3))</pre>
<pre>		    :mz (define h (make-hash)) (hash-set! h "list" l)</pre>
<pre>		    :echo mzeval("l")</pre>
<pre>		    :echo mzeval("h")</pre>
<
<pre>		Can also be used as a |method|: ></pre>
<pre>			GetExpr()->mzeval()</pre>
<
<pre>		{only available when compiled with the |+mzscheme| feature}<p></pre>

nextnonblank({lnum})					*nextnonblank()*
<pre>		Return the line number of the first line at or below {lnum}</pre>
<pre>		that is not blank.  Example: ></pre>
<pre>			if getline(nextnonblank(1)) =~ "Java"</pre>
<		When {lnum} is invalid or there is no non-blank line at or
<pre>		below it, zero is returned.</pre>
<pre>		See also |prevnonblank()|.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetLnum()->nextnonblank()<p></pre>

nr2char({expr} [, {utf8}])				*nr2char()*
<pre>		Return a string with a single character, which has the number</pre>
<pre>		value {expr}.  Examples: ></pre>
<pre>			nr2char(64)		returns "@"</pre>
<pre>			nr2char(32)		returns " "</pre>
<		When {utf8} is omitted or zero, the current 'encoding' is used.
<pre>		Example for "utf-8": ></pre>
<pre>			nr2char(300)		returns I with bow character</pre>
<		With {utf8} set to 1, always return utf-8 characters.
<pre>		Note that a NUL character in the file is specified with</pre>
<pre>		nr2char(10), because NULs are represented with newline</pre>
<pre>		characters.  nr2char(0) is a real NUL and terminates the</pre>
<pre>		string, thus results in an empty string.</pre>
<pre>		To turn a list of character numbers into a string: ></pre>
<pre>		    let list = [65, 66, 67]</pre>
<pre>		    let str = join(map(list, {_, val -> nr2char(val)}), '')</pre>
<		Result: "ABC"<p>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetNumber()->nr2char()<p></pre>

or({expr}, {expr})					*or()*
<pre>		Bitwise OR on the two arguments.  The arguments are converted</pre>
<pre>		to a number.  A List, Dict or Float argument causes an error.</pre>
<pre>		Example: ></pre>
<pre>			:let bits = or(bits, 0x80)</pre>
<		Can also be used as a |method|: >
<pre>			:let bits = bits->or(0x80)<p></pre>


pathshorten({expr})					*pathshorten()*
<pre>		Shorten directory names in the path {expr} and return the</pre>
<pre>		result.  The tail, the file name, is kept as-is.  The other</pre>
<pre>		components in the path are reduced to single letters.  Leading</pre>
<pre>		'~' and '.' characters are kept.  Example: ></pre>
<pre>			:echo pathshorten('~/.vim/autoload/myfile.vim')</pre>
<			~/.v/a/myfile.vim ~
<pre>		It doesn't matter if the path exists or not.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetDirectories()->pathshorten()<p></pre>

perleval({expr})					*perleval()*
<pre>		Evaluate Perl expression {expr} in scalar context and return</pre>
<pre>		its result converted to Vim data structures. If value can't be</pre>
<pre>		converted, it is returned as a string Perl representation.</pre>
<pre>		Note: If you want an array or hash, {expr} must return a</pre>
<pre>		reference to it.</pre>
<pre>		Example: ></pre>
<pre>			:echo perleval('[1 .. 4]')</pre>
<			[1, 2, 3, 4]<p>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetExpr()->perleval()<p></pre>

<		{only available when compiled with the |+perl| feature}<p>


popup_ functions are documented here: |popup-functions|.<p>


pow({x}, {y})						*pow()*
<pre>		Return the power of {x} to the exponent {y} as a |Float|.</pre>
<pre>		{x} and {y} must evaluate to a |Float| or a |Number|.</pre>
<pre>		Examples: ></pre>
<pre>			:echo pow(3, 3)</pre>
<			27.0 >
<pre>			:echo pow(2, 16)</pre>
<			65536.0 >
<pre>			:echo pow(32, 0.20)</pre>
<			2.0<p>

<pre>		Can also be used as a |method|: ></pre>
<pre>			Compute()->pow(3)</pre>
<
<pre>		{only available when compiled with the |+float| feature}<p></pre>

prevnonblank({lnum})					*prevnonblank()*
<pre>		Return the line number of the first line at or above {lnum}</pre>
<pre>		that is not blank.  Example: ></pre>
<pre>			let ind = indent(prevnonblank(v:lnum - 1))</pre>
<		When {lnum} is invalid or there is no non-blank line at or
<pre>		above it, zero is returned.</pre>
<pre>		Also see |nextnonblank()|.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetLnum()->prevnonblank()<p></pre>

printf({fmt}, {expr1} ...)				*printf()*
<pre>		Return a String with {fmt}, where "%" items are replaced by</pre>
<pre>		the formatted form of their respective arguments.  Example: ></pre>
<pre>			printf("%4d: E%d %.30s", lnum, errno, msg)</pre>
<		May result in:
<pre>			"  99: E42 asdfasdfasdfasdfasdfasdfasdfas" ~<p></pre>

<pre>		When used as a |method| the base is passed as the second</pre>
<pre>		argument: ></pre>
<pre>			Compute()->printf("result: %d")<p></pre>

<		Often used items are:
<pre>		  %s	string</pre>
<pre>		  %6S	string right-aligned in 6 display cells</pre>
<pre>		  %6s	string right-aligned in 6 bytes</pre>
<pre>		  %.9s	string truncated to 9 bytes</pre>
<pre>		  %c	single byte</pre>
<pre>		  %d	decimal number</pre>
<pre>		  %5d	decimal number padded with spaces to 5 characters</pre>
<pre>		  %x	hex number</pre>
<pre>		  %04x	hex number padded with zeros to at least 4 characters</pre>
<pre>		  %X	hex number using upper case letters</pre>
<pre>		  %o	octal number</pre>
<pre>		  %08b	binary number padded with zeros to at least 8 chars</pre>
<pre>		  %f	floating point number as 12.23, inf, -inf or nan</pre>
<pre>		  %F	floating point number as 12.23, INF, -INF or NAN</pre>
<pre>		  %e	floating point number as 1.23e3, inf, -inf or nan</pre>
<pre>		  %E	floating point number as 1.23E3, INF, -INF or NAN</pre>
<pre>		  %g	floating point number, as %f or %e depending on value</pre>
<pre>		  %G	floating point number, as %F or %E depending on value</pre>
<pre>		  %%	the % character itself<p></pre>

<pre>		Conversion specifications start with '%' and end with the</pre>
<pre>		conversion type.  All other characters are copied unchanged to</pre>
<pre>		the result.<p></pre>

<pre>		The "%" starts a conversion specification.  The following</pre>
<pre>		arguments appear in sequence:<p></pre>

<pre>			%  [flags]  [field-width]  [.precision]  type<p></pre>

<pre>		flags</pre>
<pre>			Zero or more of the following flags:<p></pre>

<pre>		    #	      The value should be converted to an "alternate</pre>
<pre>			      form".  For c, d, and s conversions, this option</pre>
<pre>			      has no effect.  For o conversions, the precision</pre>
<pre>			      of the number is increased to force the first</pre>
<pre>			      character of the output string to a zero (except</pre>
<pre>			      if a zero value is printed with an explicit</pre>
<pre>			      precision of zero).</pre>
<pre>			      For b and B conversions, a non-zero result has</pre>
<pre>			      the string "0b" (or "0B" for B conversions)</pre>
<pre>			      prepended to it.</pre>
<pre>			      For x and X conversions, a non-zero result has</pre>
<pre>			      the string "0x" (or "0X" for X conversions)</pre>
<pre>			      prepended to it.<p></pre>

<pre>		    0 (zero)  Zero padding.  For all conversions the converted</pre>
<pre>			      value is padded on the left with zeros rather</pre>
<pre>			      than blanks.  If a precision is given with a</pre>
<pre>			      numeric conversion (d, b, B, o, x, and X), the 0</pre>
<pre>			      flag is ignored.<p></pre>

<pre>		    -	      A negative field width flag; the converted value</pre>
<pre>			      is to be left adjusted on the field boundary.</pre>
<pre>			      The converted value is padded on the right with</pre>
<pre>			      blanks, rather than on the left with blanks or</pre>
<pre>			      zeros.  A - overrides a 0 if both are given.<p></pre>

<pre>		    ' ' (space)  A blank should be left before a positive</pre>
<pre>			      number produced by a signed conversion (d).<p></pre>

<pre>		    +	      A sign must always be placed before a number</pre>
<pre>			      produced by a signed conversion.  A + overrides</pre>
<pre>			      a space if both are used.<p></pre>

<pre>		field-width</pre>
<pre>			An optional decimal digit string specifying a minimum</pre>
<pre>			field width.  If the converted value has fewer bytes</pre>
<pre>			than the field width, it will be padded with spaces on</pre>
<pre>			the left (or right, if the left-adjustment flag has</pre>
<pre>			been given) to fill out the field width.<p></pre>

<pre>		.precision</pre>
<pre>			An optional precision, in the form of a period '.'</pre>
<pre>			followed by an optional digit string.  If the digit</pre>
<pre>			string is omitted, the precision is taken as zero.</pre>
<pre>			This gives the minimum number of digits to appear for</pre>
<pre>			d, o, x, and X conversions, or the maximum number of</pre>
<pre>			bytes to be printed from a string for s conversions.</pre>
<pre>			For floating point it is the number of digits after</pre>
<pre>			the decimal point.<p></pre>

<pre>		type</pre>
<pre>			A character that specifies the type of conversion to</pre>
<pre>			be applied, see below.<p></pre>

<pre>		A field width or precision, or both, may be indicated by an</pre>
<pre>		asterisk '*' instead of a digit string.  In this case, a</pre>
<pre>		Number argument supplies the field width or precision.  A</pre>
<pre>		negative field width is treated as a left adjustment flag</pre>
<pre>		followed by a positive field width; a negative precision is</pre>
<pre>		treated as though it were missing.  Example: ></pre>
<pre>			:echo printf("%d: %.*s", nr, width, line)</pre>
<		This limits the length of the text used from "line" to
<pre>		"width" bytes.<p></pre>

<pre>		The conversion specifiers and their meanings are:<p></pre>

<pre>				*printf-d* *printf-b* *printf-B* *printf-o*</pre>
<pre>				*printf-x* *printf-X*</pre>
<pre>		dbBoxX	The Number argument is converted to signed decimal</pre>
<pre>			(d), unsigned binary (b and B), unsigned octal (o), or</pre>
<pre>			unsigned hexadecimal (x and X) notation.  The letters</pre>
<pre>			"abcdef" are used for x conversions; the letters</pre>
<pre>			"ABCDEF" are used for X conversions.</pre>
<pre>			The precision, if any, gives the minimum number of</pre>
<pre>			digits that must appear; if the converted value</pre>
<pre>			requires fewer digits, it is padded on the left with</pre>
<pre>			zeros.</pre>
<pre>			In no case does a non-existent or small field width</pre>
<pre>			cause truncation of a numeric field; if the result of</pre>
<pre>			a conversion is wider than the field width, the field</pre>
<pre>			is expanded to contain the conversion result.</pre>
<pre>			The 'h' modifier indicates the argument is 16 bits.</pre>
<pre>			The 'l' modifier indicates the argument is 32 bits.</pre>
<pre>			The 'L' modifier indicates the argument is 64 bits.</pre>
<pre>			Generally, these modifiers are not useful. They are</pre>
<pre>			ignored when type is known from the argument.<p></pre>

<pre>		i	alias for d</pre>
<pre>		D	alias for ld</pre>
<pre>		U	alias for lu</pre>
<pre>		O	alias for lo<p></pre>

<pre>							*printf-c*</pre>
<pre>		c	The Number argument is converted to a byte, and the</pre>
<pre>			resulting character is written.<p></pre>

<pre>							*printf-s*</pre>
<pre>		s	The text of the String argument is used.  If a</pre>
<pre>			precision is specified, no more bytes than the number</pre>
<pre>			specified are used.</pre>
<pre>			If the argument is not a String type, it is</pre>
<pre>			automatically converted to text with the same format</pre>
<pre>			as ":echo".</pre>
<pre>							*printf-S*</pre>
<pre>		S	The text of the String argument is used.  If a</pre>
<pre>			precision is specified, no more display cells than the</pre>
<pre>			number specified are used.<p></pre>

<pre>							*printf-f* *E807*</pre>
<pre>		f F	The Float argument is converted into a string of the</pre>
<pre>			form 123.456.  The precision specifies the number of</pre>
<pre>			digits after the decimal point.  When the precision is</pre>
<pre>			zero the decimal point is omitted.  When the precision</pre>
<pre>			is not specified 6 is used.  A really big number</pre>
<pre>			(out of range or dividing by zero) results in "inf"</pre>
<pre>			or "-inf" with %f (INF or -INF with %F).</pre>
<pre>			"0.0 / 0.0" results in "nan" with %f (NAN with %F).</pre>
<pre>			Example: ></pre>
<pre>				echo printf("%.2f", 12.115)</pre>
<				12.12
<pre>			Note that roundoff depends on the system libraries.</pre>
<pre>			Use |round()| when in doubt.<p></pre>

<pre>							*printf-e* *printf-E*</pre>
<pre>		e E	The Float argument is converted into a string of the</pre>
<pre>			form 1.234e+03 or 1.234E+03 when using 'E'.  The</pre>
<pre>			precision specifies the number of digits after the</pre>
<pre>			decimal point, like with 'f'.<p></pre>

<pre>							*printf-g* *printf-G*</pre>
<pre>		g G	The Float argument is converted like with 'f' if the</pre>
<pre>			value is between 0.001 (inclusive) and 10000000.0</pre>
<pre>			(exclusive).  Otherwise 'e' is used for 'g' and 'E'</pre>
<pre>			for 'G'.  When no precision is specified superfluous</pre>
<pre>			zeroes and '+' signs are removed, except for the zero</pre>
<pre>			immediately after the decimal point.  Thus 10000000.0</pre>
<pre>			results in 1.0e7.<p></pre>

<pre>							*printf-%*</pre>
<pre>		%	A '%' is written.  No argument is converted.  The</pre>
<pre>			complete conversion specification is "%%".<p></pre>

<pre>		When a Number argument is expected a String argument is also</pre>
<pre>		accepted and automatically converted.</pre>
<pre>		When a Float or String argument is expected a Number argument</pre>
<pre>		is also accepted and automatically converted.</pre>
<pre>		Any other argument type results in an error message.<p></pre>

<pre>							*E766* *E767*</pre>
<pre>		The number of {exprN} arguments must exactly match the number</pre>
<pre>		of "%" items.  If there are not sufficient or too many</pre>
<pre>		arguments an error is given.  Up to 18 arguments can be used.<p></pre>


prompt_setcallback({buf}, {expr})			*prompt_setcallback()*
<pre>		Set prompt callback for buffer {buf} to {expr}.  When {expr}</pre>
<pre>		is an empty string the callback is removed.  This has only</pre>
<pre>		effect if {buf} has 'buftype' set to "prompt".<p></pre>

<pre>		The callback is invoked when pressing Enter.  The current</pre>
<pre>		buffer will always be the prompt buffer.  A new line for a</pre>
<pre>		prompt is added before invoking the callback, thus the prompt</pre>
<pre>		for which the callback was invoked will be in the last but one</pre>
<pre>		line.</pre>
<pre>		If the callback wants to add text to the buffer, it must</pre>
<pre>		insert it above the last line, since that is where the current</pre>
<pre>		prompt is.  This can also be done asynchronously.</pre>
<pre>		The callback is invoked with one argument, which is the text</pre>
<pre>		that was entered at the prompt.  This can be an empty string</pre>
<pre>		if the user only typed Enter.</pre>
<pre>		Example: ></pre>
<pre>		   call prompt_setcallback(bufnr(), function('s:TextEntered'))</pre>
<pre>		   func s:TextEntered(text)</pre>
<pre>		     if a:text == 'exit' || a:text == 'quit'</pre>
<pre>		       stopinsert</pre>
<pre>		       close</pre>
<pre>		     else</pre>
<pre>		       call append(line('$') - 1, 'Entered: "' . a:text . '"')</pre>
<pre>		       " Reset 'modified' to allow the buffer to be closed.</pre>
<pre>		       set nomodified</pre>
<pre>		     endif</pre>
<pre>		   endfunc<p></pre>

<		Can also be used as a |method|: >
<pre>			GetBuffer()->prompt_setcallback(callback)<p></pre>


prompt_setinterrupt({buf}, {expr})			*prompt_setinterrupt()*
<pre>		Set a callback for buffer {buf} to {expr}.  When {expr} is an</pre>
<pre>		empty string the callback is removed.  This has only effect if</pre>
<pre>		{buf} has 'buftype' set to "prompt".<p></pre>

<pre>		This callback will be invoked when pressing CTRL-C in Insert</pre>
<pre>		mode.  Without setting a callback Vim will exit Insert mode,</pre>
<pre>		as in any buffer.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetBuffer()->prompt_setinterrupt(callback)<p></pre>

prompt_setprompt({buf}, {text})				*prompt_setprompt()*
<pre>		Set prompt for buffer {buf} to {text}.  You most likely want</pre>
<pre>		{text} to end in a space.</pre>
<pre>		The result is only visible if {buf} has 'buftype' set to</pre>
<pre>		"prompt".  Example: ></pre>
<pre>			call prompt_setprompt(bufnr(), 'command: ')</pre>
<
<pre>		Can also be used as a |method|: ></pre>
<pre>			GetBuffer()->prompt_setprompt('command: ')<p></pre>

prop_ functions are documented here: |text-prop-functions|.<p>

pum_getpos()						*pum_getpos()*
<pre>		If the popup menu (see |ins-completion-menu|) is not visible,</pre>
<pre>		returns an empty |Dictionary|, otherwise, returns a</pre>
<pre>		|Dictionary| with the following keys:</pre>
<pre>			height		nr of items visible</pre>
<pre>			width		screen cells</pre>
<pre>			row		top screen row (0 first row)</pre>
<pre>			col		leftmost screen column (0 first col)</pre>
<pre>			size		total nr of items</pre>
<pre>			scrollbar	|TRUE| if scrollbar is visible<p></pre>

<pre>		The values are the same as in |v:event| during</pre>
<pre>		|CompleteChanged|.<p></pre>

pumvisible()						*pumvisible()*
<pre>		Returns non-zero when the popup menu is visible, zero</pre>
<pre>		otherwise.  See |ins-completion-menu|.</pre>
<pre>		This can be used to avoid some things that would remove the</pre>
<pre>		popup menu.<p></pre>

py3eval({expr})						*py3eval()*
<pre>		Evaluate Python expression {expr} and return its result</pre>
<pre>		converted to Vim data structures.</pre>
<pre>		Numbers and strings are returned as they are (strings are</pre>
<pre>		copied though, Unicode strings are additionally converted to</pre>
<pre>		'encoding').</pre>
<pre>		Lists are represented as Vim |List| type.</pre>
<pre>		Dictionaries are represented as Vim |Dictionary| type with</pre>
<pre>		keys converted to strings.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetExpr()->py3eval()<p></pre>

<		{only available when compiled with the |+python3| feature}<p>

<pre>							*E858* *E859*</pre>
pyeval({expr})						*pyeval()*
<pre>		Evaluate Python expression {expr} and return its result</pre>
<pre>		converted to Vim data structures.</pre>
<pre>		Numbers and strings are returned as they are (strings are</pre>
<pre>		copied though).</pre>
<pre>		Lists are represented as Vim |List| type.</pre>
<pre>		Dictionaries are represented as Vim |Dictionary| type,</pre>
<pre>		non-string keys result in error.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetExpr()->pyeval()<p></pre>

<		{only available when compiled with the |+python| feature}<p>

pyxeval({expr})						*pyxeval()*
<pre>		Evaluate Python expression {expr} and return its result</pre>
<pre>		converted to Vim data structures.</pre>
<pre>		Uses Python 2 or 3, see |python_x| and 'pyxversion'.</pre>
<pre>		See also: |pyeval()|, |py3eval()|<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetExpr()->pyxeval()<p></pre>

<		{only available when compiled with the |+python| or the
<pre>		|+python3| feature}<p></pre>

<pre>							*E726* *E727*</pre>
range({expr} [, {max} [, {stride}]])				*range()*
<pre>		Returns a |List| with Numbers:</pre>
<pre>		- If only {expr} is specified: [0, 1, ..., {expr} - 1]</pre>
<pre>		- If {max} is specified: [{expr}, {expr} + 1, ..., {max}]</pre>
<pre>		- If {stride} is specified: [{expr}, {expr} + {stride}, ...,</pre>
<pre>		  {max}] (increasing {expr} with {stride} each time, not</pre>
<pre>		  producing a value past {max}).</pre>
<pre>		When the maximum is one before the start the result is an</pre>
<pre>		empty list.  When the maximum is more than one before the</pre>
<pre>		start this is an error.</pre>
<pre>		Examples: ></pre>
<pre>			range(4)		" [0, 1, 2, 3]</pre>
<pre>			range(2, 4)		" [2, 3, 4]</pre>
<pre>			range(2, 9, 3)		" [2, 5, 8]</pre>
<pre>			range(2, -2, -1)	" [2, 1, 0, -1, -2]</pre>
<pre>			range(0)		" []</pre>
<pre>			range(2, 0)		" error!</pre>
<
<pre>		Can also be used as a |method|: ></pre>
<pre>			GetExpr()->range()</pre>
<<p>

rand([{expr}])						*rand()*
<pre>		Return a pseudo-random Number generated with an xorshift</pre>
<pre>		algorithm using seed {expr}.  The returned number is 32 bits,</pre>
<pre>		also on 64 bits systems, for consistency.</pre>
<pre>		{expr} can be initialized by |srand()| and will be updated by</pre>
<pre>		rand().  If {expr} is omitted, an internal seed value is used</pre>
<pre>		and updated.<p></pre>

<pre>		Examples: ></pre>
<pre>			:echo rand()</pre>
<pre>			:let seed = srand()</pre>
<pre>			:echo rand(seed)</pre>
<pre>			:echo rand(seed) % 16  " random number 0 - 15</pre>
<
<pre>							*readdir()*</pre>
readdir({directory} [, {expr}])
<pre>		Return a list with file and directory names in {directory}.</pre>
<pre>		You can also use |glob()| if you don't need to do complicated</pre>
<pre>		things, such as limiting the number of matches.<p></pre>

<pre>		When {expr} is omitted all entries are included.</pre>
<pre>		When {expr} is given, it is evaluated to check what to do:</pre>
<pre>			If {expr} results in -1 then no further entries will</pre>
<pre>			be handled.</pre>
<pre>			If {expr} results in 0 then this entry will not be</pre>
<pre>			added to the list.</pre>
<pre>			If {expr} results in 1 then this entry will be added</pre>
<pre>			to the list.</pre>
<pre>		Each time {expr} is evaluated |v:val| is set to the entry name.</pre>
<pre>		When {expr} is a function the name is passed as the argument.</pre>
<pre>		For example, to get a list of files ending in ".txt": ></pre>
<pre>		  readdir(dirname, {n -> n =~ '.txt$'})</pre>
<		To skip hidden and backup files: >
<pre>		  readdir(dirname, {n -> n !~ '^\.\|\~$'})<p></pre>

<		If you want to get a directory tree: >
<pre>                  function! s:tree(dir)</pre>
<pre>                      return {a:dir : map(readdir(a:dir),</pre>
<pre>		      \ {_, x -> isdirectory(x) ?</pre>
<pre>		      \          {x : s:tree(a:dir . '/' . x)} : x})}</pre>
<pre>                  endfunction</pre>
<pre>                  echo s:tree(".")</pre>
<
<pre>		Can also be used as a |method|: ></pre>
<pre>			GetDirName()->readdir()</pre>
<
<pre>							*readfile()*</pre>
readfile({fname} [, {type} [, {max}]])
<pre>		Read file {fname} and return a |List|, each line of the file</pre>
<pre>		as an item.  Lines are broken at NL characters.  Macintosh</pre>
<pre>		files separated with CR will result in a single long line</pre>
<pre>		(unless a NL appears somewhere).</pre>
<pre>		All NUL characters are replaced with a NL character.</pre>
<pre>		When {type} contains "b" binary mode is used:</pre>
<pre>		- When the last line ends in a NL an extra empty list item is</pre>
<pre>		  added.</pre>
<pre>		- No CR characters are removed.</pre>
<pre>		When {type} contains "B" a |Blob| is returned with the binary</pre>
<pre>		data of the file unmodified.</pre>
<pre>		Otherwise:</pre>
<pre>		- CR characters that appear before a NL are removed.</pre>
<pre>		- Whether the last line ends in a NL or not does not matter.</pre>
<pre>		- When 'encoding' is Unicode any UTF-8 byte order mark is</pre>
<pre>		  removed from the text.</pre>
<pre>		When {max} is given this specifies the maximum number of lines</pre>
<pre>		to be read.  Useful if you only want to check the first ten</pre>
<pre>		lines of a file: ></pre>
<pre>			:for line in readfile(fname, '', 10)</pre>
<pre>			:  if line =~ 'Date' | echo line | endif</pre>
<pre>			:endfor</pre>
<		When {max} is negative -{max} lines from the end of the file
<pre>		are returned, or as many as there are.</pre>
<pre>		When {max} is zero the result is an empty list.</pre>
<pre>		Note that without {max} the whole file is read into memory.</pre>
<pre>		Also note that there is no recognition of encoding.  Read a</pre>
<pre>		file into a buffer if you need to.</pre>
<pre>		When the file can't be opened an error message is given and</pre>
<pre>		the result is an empty list.</pre>
<pre>		Also see |writefile()|.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetFileName()->readfile()<p></pre>

reg_executing()						*reg_executing()*
<pre>		Returns the single letter name of the register being executed.</pre>
<pre>		Returns an empty string when no register is being executed.</pre>
<pre>		See |@|.<p></pre>

reg_recording()						*reg_recording()*
<pre>		Returns the single letter name of the register being recorded.</pre>
<pre>		Returns an empty string when not recording.  See |q|.<p></pre>

reltime([{start} [, {end}]])				*reltime()*
<pre>		Return an item that represents a time value.  The format of</pre>
<pre>		the item depends on the system.  It can be passed to</pre>
<pre>		|reltimestr()| to convert it to a string  or |reltimefloat()|</pre>
<pre>		to convert to a Float.</pre>
<pre>		Without an argument it returns the current time.</pre>
<pre>		With one argument is returns the time passed since the time</pre>
<pre>		specified in the argument.</pre>
<pre>		With two arguments it returns the time passed between {start}</pre>
<pre>		and {end}.</pre>
<pre>		The {start} and {end} arguments must be values returned by</pre>
<pre>		reltime().<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetStart()->reltime()</pre>
<
<pre>		{only available when compiled with the |+reltime| feature}<p></pre>

reltimefloat({time})				*reltimefloat()*
<pre>		Return a Float that represents the time value of {time}.</pre>
<pre>		Example: ></pre>
<pre>			let start = reltime()</pre>
<pre>			call MyFunction()</pre>
<pre>			let seconds = reltimefloat(reltime(start))</pre>
<		See the note of reltimestr() about overhead.
<pre>		Also see |profiling|.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			reltime(start)->reltimefloat()<p></pre>

<		{only available when compiled with the |+reltime| feature}<p>

reltimestr({time})				*reltimestr()*
<pre>		Return a String that represents the time value of {time}.</pre>
<pre>		This is the number of seconds, a dot and the number of</pre>
<pre>		microseconds.  Example: ></pre>
<pre>			let start = reltime()</pre>
<pre>			call MyFunction()</pre>
<pre>			echo reltimestr(reltime(start))</pre>
<		Note that overhead for the commands will be added to the time.
<pre>		The accuracy depends on the system.</pre>
<pre>		Leading spaces are used to make the string align nicely.  You</pre>
<pre>		can use split() to remove it. ></pre>
<pre>			echo split(reltimestr(reltime(start)))[0]</pre>
<		Also see |profiling|.<p>

<pre>		Can also be used as a |method|: ></pre>
<pre>			reltime(start)->reltimestr()<p></pre>

<		{only available when compiled with the |+reltime| feature}<p>

<pre>							*remote_expr()* *E449*</pre>
remote_expr({server}, {string} [, {idvar} [, {timeout}]])
<pre>		Send the {string} to {server}.  The string is sent as an</pre>
<pre>		expression and the result is returned after evaluation.</pre>
<pre>		The result must be a String or a |List|.  A |List| is turned</pre>
<pre>		into a String by joining the items with a line break in</pre>
<pre>		between (not at the end), like with join(expr, "\n").</pre>
<pre>		If {idvar} is present and not empty, it is taken as the name</pre>
<pre>		of a variable and a {serverid} for later use with</pre>
<pre>		|remote_read()| is stored there.</pre>
<pre>		If {timeout} is given the read times out after this many</pre>
<pre>		seconds.  Otherwise a timeout of 600 seconds is used.</pre>
<pre>		See also |clientserver| |RemoteReply|.</pre>
<pre>		This function is not available in the |sandbox|.</pre>
<pre>		{only available when compiled with the |+clientserver| feature}</pre>
<pre>		Note: Any errors will cause a local error message to be issued</pre>
<pre>		and the result will be the empty string.<p></pre>

<pre>		Variables will be evaluated in the global namespace,</pre>
<pre>		independent of a function currently being active.  Except</pre>
<pre>		when in debug mode, then local function variables and</pre>
<pre>		arguments can be evaluated.<p></pre>

<pre>		Examples: ></pre>
<pre>			:echo remote_expr("gvim", "2+2")</pre>
<pre>			:echo remote_expr("gvim1", "b:current_syntax")</pre>
<
<pre>		Can also be used as a |method|: ></pre>
<pre>			ServerName()->remote_expr(expr)<p></pre>

remote_foreground({server})				*remote_foreground()*
<pre>		Move the Vim server with the name {server} to the foreground.</pre>
<pre>		This works like: ></pre>
<pre>			remote_expr({server}, "foreground()")</pre>
<		Except that on Win32 systems the client does the work, to work
<pre>		around the problem that the OS doesn't always allow the server</pre>
<pre>		to bring itself to the foreground.</pre>
<pre>		Note: This does not restore the window if it was minimized,</pre>
<pre>		like foreground() does.</pre>
<pre>		This function is not available in the |sandbox|.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			ServerName()->remote_foreground()<p></pre>

<		{only in the Win32, Athena, Motif and GTK GUI versions and the
<pre>		Win32 console version}<p></pre>


remote_peek({serverid} [, {retvar}])		*remote_peek()*
<pre>		Returns a positive number if there are available strings</pre>
<pre>		from {serverid}.  Copies any reply string into the variable</pre>
<pre>		{retvar} if specified.  {retvar} must be a string with the</pre>
<pre>		name of a variable.</pre>
<pre>		Returns zero if none are available.</pre>
<pre>		Returns -1 if something is wrong.</pre>
<pre>		See also |clientserver|.</pre>
<pre>		This function is not available in the |sandbox|.</pre>
<pre>		{only available when compiled with the |+clientserver| feature}</pre>
<pre>		Examples: ></pre>
<pre>			:let repl = ""</pre>
<pre>			:echo "PEEK: ".remote_peek(id, "repl").": ".repl<p></pre>

<		Can also be used as a |method|: >
<pre>			ServerId()->remote_peek()<p></pre>

remote_read({serverid}, [{timeout}])			*remote_read()*
<pre>		Return the oldest available reply from {serverid} and consume</pre>
<pre>		it.  Unless a {timeout} in seconds is given, it blocks until a</pre>
<pre>		reply is available.</pre>
<pre>		See also |clientserver|.</pre>
<pre>		This function is not available in the |sandbox|.</pre>
<pre>		{only available when compiled with the |+clientserver| feature}</pre>
<pre>		Example: ></pre>
<pre>			:echo remote_read(id)<p></pre>

<		Can also be used as a |method|: >
<pre>			ServerId()->remote_read()</pre>
<
<pre>							*remote_send()* *E241*</pre>
remote_send({server}, {string} [, {idvar}])
<pre>		Send the {string} to {server}.  The string is sent as input</pre>
<pre>		keys and the function returns immediately.  At the Vim server</pre>
<pre>		the keys are not mapped |:map|.</pre>
<pre>		If {idvar} is present, it is taken as the name of a variable</pre>
<pre>		and a {serverid} for later use with remote_read() is stored</pre>
<pre>		there.</pre>
<pre>		See also |clientserver| |RemoteReply|.</pre>
<pre>		This function is not available in the |sandbox|.</pre>
<pre>		{only available when compiled with the |+clientserver| feature}<p></pre>

<pre>		Note: Any errors will be reported in the server and may mess</pre>
<pre>		up the display.</pre>
<pre>		Examples: ></pre>
<pre>		:echo remote_send("gvim", ":DropAndReply ".file, "serverid").</pre>
<pre>		 \ remote_read(serverid)<p></pre>

<pre>		:autocmd NONE RemoteReply *</pre>
<pre>		 \ echo remote_read(expand("<amatch>"))</pre>
<pre>		:echo remote_send("gvim", ":sleep 10 | echo ".</pre>
<pre>		 \ 'server2client(expand("<client>"), "HELLO")<CR>')</pre>
<
<pre>		Can also be used as a |method|: ></pre>
<pre>			ServerName()->remote_send(keys)</pre>
<
<pre>					*remote_startserver()* *E941* *E942*</pre>
remote_startserver({name})
<pre>		Become the server {name}.  This fails if already running as a</pre>
<pre>		server, when |v:servername| is not empty.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			ServerName()->remote_startserver()<p></pre>

<		{only available when compiled with the |+clientserver| feature}<p>

remove({list}, {idx} [, {end}])				*remove()*
<pre>		Without {end}: Remove the item at {idx} from |List| {list} and</pre>
<pre>		return the item.</pre>
<pre>		With {end}: Remove items from {idx} to {end} (inclusive) and</pre>
<pre>		return a List with these items.  When {idx} points to the same</pre>
<pre>		item as {end} a list with one item is returned.  When {end}</pre>
<pre>		points to an item before {idx} this is an error.</pre>
<pre>		See |list-index| for possible values of {idx} and {end}.</pre>
<pre>		Example: ></pre>
<pre>			:echo "last item: " . remove(mylist, -1)</pre>
<pre>			:call remove(mylist, 0, 9)</pre>
<
<pre>		Use |delete()| to remove a file.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			mylist->remove(idx)<p></pre>

remove({blob}, {idx} [, {end}])
<pre>		Without {end}: Remove the byte at {idx} from |Blob| {blob} and</pre>
<pre>		return the byte.</pre>
<pre>		With {end}: Remove bytes from {idx} to {end} (inclusive) and</pre>
<pre>		return a |Blob| with these bytes.  When {idx} points to the same</pre>
<pre>		byte as {end} a |Blob| with one byte is returned.  When {end}</pre>
<pre>		points to a byte before {idx} this is an error.</pre>
<pre>		Example: ></pre>
<pre>			:echo "last byte: " . remove(myblob, -1)</pre>
<pre>			:call remove(mylist, 0, 9)<p></pre>

remove({dict}, {key})
<pre>		Remove the entry from {dict} with key {key} and return it.</pre>
<pre>		Example: ></pre>
<pre>			:echo "removed " . remove(dict, "one")</pre>
<		If there is no {key} in {dict} this is an error.<p>

rename({from}, {to})					*rename()*
<pre>		Rename the file by the name {from} to the name {to}.  This</pre>
<pre>		should also work to move files across file systems.  The</pre>
<pre>		result is a Number, which is 0 if the file was renamed</pre>
<pre>		successfully, and non-zero when the renaming failed.</pre>
<pre>		NOTE: If {to} exists it is overwritten without warning.</pre>
<pre>		This function is not available in the |sandbox|.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetOldName()->rename(newname)<p></pre>

repeat({expr}, {count})					*repeat()*
<pre>		Repeat {expr} {count} times and return the concatenated</pre>
<pre>		result.  Example: ></pre>
<pre>			:let separator = repeat('-', 80)</pre>
<		When {count} is zero or negative the result is empty.
<pre>		When {expr} is a |List| the result is {expr} concatenated</pre>
<pre>		{count} times.  Example: ></pre>
<pre>			:let longlist = repeat(['a', 'b'], 3)</pre>
<		Results in ['a', 'b', 'a', 'b', 'a', 'b'].<p>

<pre>		Can also be used as a |method|: ></pre>
<pre>			mylist->repeat(count)<p></pre>

resolve({filename})					*resolve()* *E655*
<pre>		On MS-Windows, when {filename} is a shortcut (a .lnk file),</pre>
<pre>		returns the path the shortcut points to in a simplified form.</pre>
<pre>		When {filename} is a symbolic link or junction point, return</pre>
<pre>		the full path to the target. If the target of junction is</pre>
<pre>		removed, return {filename}.</pre>
<pre>		On Unix, repeat resolving symbolic links in all path</pre>
<pre>		components of {filename} and return the simplified result.</pre>
<pre>		To cope with link cycles, resolving of symbolic links is</pre>
<pre>		stopped after 100 iterations.</pre>
<pre>		On other systems, return the simplified {filename}.</pre>
<pre>		The simplification step is done as by |simplify()|.</pre>
<pre>		resolve() keeps a leading path component specifying the</pre>
<pre>		current directory (provided the result is still a relative</pre>
<pre>		path name) and also keeps a trailing path separator.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetName()->resolve()<p></pre>

reverse({object})					*reverse()*
<pre>		Reverse the order of items in {object} in-place.</pre>
<pre>		{object} can be a |List| or a |Blob|.</pre>
<pre>		Returns {object}.</pre>
<pre>		If you want an object to remain unmodified make a copy first: ></pre>
<pre>			:let revlist = reverse(copy(mylist))</pre>
<		Can also be used as a |method|: >
<pre>			mylist->reverse()<p></pre>

round({expr})							*round()*
<pre>		Round off {expr} to the nearest integral value and return it</pre>
<pre>		as a |Float|.  If {expr} lies halfway between two integral</pre>
<pre>		values, then use the larger one (away from zero).</pre>
<pre>		{expr} must evaluate to a |Float| or a |Number|.</pre>
<pre>		Examples: ></pre>
<pre>			echo round(0.456)</pre>
<			0.0  >
<pre>			echo round(4.5)</pre>
<			5.0 >
<pre>			echo round(-4.5)</pre>
<			-5.0<p>

<pre>		Can also be used as a |method|: ></pre>
<pre>			Compute()->round()</pre>
<
<pre>		{only available when compiled with the |+float| feature}<p></pre>

rubyeval({expr})					*rubyeval()*
<pre>		Evaluate Ruby expression {expr} and return its result</pre>
<pre>		converted to Vim data structures.</pre>
<pre>		Numbers, floats and strings are returned as they are (strings</pre>
<pre>		are copied though).</pre>
<pre>		Arrays are represented as Vim |List| type.</pre>
<pre>		Hashes are represented as Vim |Dictionary| type.</pre>
<pre>		Other objects are represented as strings resulted from their</pre>
<pre>		"Object#to_s" method.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetRubyExpr()->rubyeval()<p></pre>

<		{only available when compiled with the |+ruby| feature}<p>

screenattr({row}, {col})					*screenattr()*
<pre>		Like |screenchar()|, but return the attribute.  This is a rather</pre>
<pre>		arbitrary number that can only be used to compare to the</pre>
<pre>		attribute at other positions.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetRow()->screenattr(col)<p></pre>

screenchar({row}, {col})					*screenchar()*
<pre>		The result is a Number, which is the character at position</pre>
<pre>		[row, col] on the screen.  This works for every possible</pre>
<pre>		screen position, also status lines, window separators and the</pre>
<pre>		command line.  The top left position is row one, column one</pre>
<pre>		The character excludes composing characters.  For double-byte</pre>
<pre>		encodings it may only be the first byte.</pre>
<pre>		This is mainly to be used for testing.</pre>
<pre>		Returns -1 when row or col is out of range.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetRow()->screenchar(col)<p></pre>

screenchars({row}, {col})					*screenchars()*
<pre>		The result is a List of Numbers.  The first number is the same</pre>
<pre>		as what |screenchar()| returns.  Further numbers are</pre>
<pre>		composing characters on top of the base character.</pre>
<pre>		This is mainly to be used for testing.</pre>
<pre>		Returns an empty List when row or col is out of range.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetRow()->screenchars(col)<p></pre>

screencol()							*screencol()*
<pre>		The result is a Number, which is the current screen column of</pre>
<pre>		the cursor. The leftmost column has number 1.</pre>
<pre>		This function is mainly used for testing.<p></pre>

<pre>		Note: Always returns the current screen column, thus if used</pre>
<pre>		in a command (e.g. ":echo screencol()") it will return the</pre>
<pre>		column inside the command line, which is 1 when the command is</pre>
<pre>		executed. To get the cursor position in the file use one of</pre>
<pre>		the following mappings: ></pre>
<pre>			nnoremap <expr> GG ":echom ".screencol()."\n"</pre>
<pre>			nnoremap <silent> GG :echom screencol()<CR></pre>
<
screenpos({winid}, {lnum}, {col})				*screenpos()*
<pre>		The result is a Dict with the screen position of the text</pre>
<pre>		character in window {winid} at buffer line {lnum} and column</pre>
<pre>		{col}.  {col} is a one-based byte index.</pre>
<pre>		The Dict has these members:</pre>
<pre>			row	screen row</pre>
<pre>			col	first screen column</pre>
<pre>			endcol	last screen column</pre>
<pre>			curscol	cursor screen column</pre>
<pre>		If the specified position is not visible, all values are zero.</pre>
<pre>		The "endcol" value differs from "col" when the character</pre>
<pre>		occupies more than one screen cell.  E.g. for a Tab "col" can</pre>
<pre>		be 1 and "endcol" can be 8.</pre>
<pre>		The "curscol" value is where the cursor would be placed.  For</pre>
<pre>		a Tab it would be the same as "endcol", while for a double</pre>
<pre>		width character it would be the same as "col".<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetWinid()->screenpos(lnum, col)<p></pre>

screenrow()							*screenrow()*
<pre>		The result is a Number, which is the current screen row of the</pre>
<pre>		cursor.  The top line has number one.</pre>
<pre>		This function is mainly used for testing.</pre>
<pre>		Alternatively you can use |winline()|.<p></pre>

<pre>		Note: Same restrictions as with |screencol()|.<p></pre>

screenstring({row}, {col})					*screenstring()*
<pre>		The result is a String that contains the base character and</pre>
<pre>		any composing characters at position [row, col] on the screen.</pre>
<pre>		This is like |screenchars()| but returning a String with the</pre>
<pre>		characters.</pre>
<pre>		This is mainly to be used for testing.</pre>
<pre>		Returns an empty String when row or col is out of range.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetRow()->screenstring(col)<p></pre>

search({pattern} [, {flags} [, {stopline} [, {timeout}]]])	*search()*
<pre>		Search for regexp pattern {pattern}.  The search starts at the</pre>
<pre>		cursor position (you can use |cursor()| to set it).<p></pre>

<pre>		When a match has been found its line number is returned.</pre>
<pre>		If there is no match a 0 is returned and the cursor doesn't</pre>
<pre>		move.  No error message is given.<p></pre>

<pre>		{flags} is a String, which can contain these character flags:</pre>
<pre>		'b'	search Backward instead of forward</pre>
<pre>		'c'	accept a match at the Cursor position</pre>
<pre>		'e'	move to the End of the match</pre>
<pre>		'n'	do Not move the cursor</pre>
<pre>		'p'	return number of matching sub-Pattern (see below)</pre>
<pre>		's'	Set the ' mark at the previous location of the cursor</pre>
<pre>		'w'	Wrap around the end of the file</pre>
<pre>		'W'	don't Wrap around the end of the file</pre>
<pre>		'z'	start searching at the cursor column instead of zero</pre>
<pre>		If neither 'w' or 'W' is given, the 'wrapscan' option applies.<p></pre>

<pre>		If the 's' flag is supplied, the ' mark is set, only if the</pre>
<pre>		cursor is moved. The 's' flag cannot be combined with the 'n'</pre>
<pre>		flag.<p></pre>

<pre>		'ignorecase', 'smartcase' and 'magic' are used.<p></pre>

<pre>		When the 'z' flag is not given, searching always starts in</pre>
<pre>		column zero and then matches before the cursor are skipped.</pre>
<pre>		When the 'c' flag is present in 'cpo' the next search starts</pre>
<pre>		after the match.  Without the 'c' flag the next search starts</pre>
<pre>		one column further.<p></pre>

<pre>		When the {stopline} argument is given then the search stops</pre>
<pre>		after searching this line.  This is useful to restrict the</pre>
<pre>		search to a range of lines.  Examples: ></pre>
<pre>			let match = search('(', 'b', line("w0"))</pre>
<pre>			let end = search('END', '', line("w$"))</pre>
<		When {stopline} is used and it is not zero this also implies
<pre>		that the search does not wrap around the end of the file.</pre>
<pre>		A zero value is equal to not giving the argument.<p></pre>

<pre>		When the {timeout} argument is given the search stops when</pre>
<pre>		more than this many milliseconds have passed.  Thus when</pre>
<pre>		{timeout} is 500 the search stops after half a second.</pre>
<pre>		The value must not be negative.  A zero value is like not</pre>
<pre>		giving the argument.</pre>
<pre>		{only available when compiled with the |+reltime| feature}<p></pre>

<pre>							*search()-sub-match*</pre>
<pre>		With the 'p' flag the returned value is one more than the</pre>
<pre>		first sub-match in \(\).  One if none of them matched but the</pre>
<pre>		whole pattern did match.</pre>
<pre>		To get the column number too use |searchpos()|.<p></pre>

<pre>		The cursor will be positioned at the match, unless the 'n'</pre>
<pre>		flag is used.<p></pre>

<pre>		Example (goes over all files in the argument list): ></pre>
<pre>		    :let n = 1</pre>
<pre>		    :while n <= argc()	    " loop over all files in arglist</pre>
<pre>		    :  exe "argument " . n</pre>
<pre>		    :  " start at the last char in the file and wrap for the</pre>
<pre>		    :  " first search to find match at start of file</pre>
<pre>		    :  normal G$</pre>
<pre>		    :  let flags = "w"</pre>
<pre>		    :  while search("foo", flags) > 0</pre>
<pre>		    :	 s/foo/bar/g</pre>
<pre>		    :	 let flags = "W"</pre>
<pre>		    :  endwhile</pre>
<pre>		    :  update		    " write the file if modified</pre>
<pre>		    :  let n = n + 1</pre>
<pre>		    :endwhile</pre>
<
<pre>		Example for using some flags: ></pre>
<pre>		    :echo search('\<if\|\(else\)\|\(endif\)', 'ncpe')</pre>
<		This will search for the keywords "if", "else", and "endif"
<pre>		under or after the cursor.  Because of the 'p' flag, it</pre>
<pre>		returns 1, 2, or 3 depending on which keyword is found, or 0</pre>
<pre>		if the search fails.  With the cursor on the first word of the</pre>
<pre>		line:</pre>
<pre>		    if (foo == 0) | let foo = foo + 1 | endif ~</pre>
<pre>		the function returns 1.  Without the 'c' flag, the function</pre>
<pre>		finds the "endif" and returns 3.  The same thing happens</pre>
<pre>		without the 'e' flag if the cursor is on the "f" of "if".</pre>
<pre>		The 'n' flag tells the function not to move the cursor.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetPattern()->search()<p></pre>

searchdecl({name} [, {global} [, {thisblock}]])			*searchdecl()*
<pre>		Search for the declaration of {name}.<p></pre>

<pre>		With a non-zero {global} argument it works like |gD|, find</pre>
<pre>		first match in the file.  Otherwise it works like |gd|, find</pre>
<pre>		first match in the function.<p></pre>

<pre>		With a non-zero {thisblock} argument matches in a {} block</pre>
<pre>		that ends before the cursor position are ignored.  Avoids</pre>
<pre>		finding variable declarations only valid in another scope.<p></pre>

<pre>		Moves the cursor to the found match.</pre>
<pre>		Returns zero for success, non-zero for failure.</pre>
<pre>		Example: ></pre>
<pre>			if searchdecl('myvar') == 0</pre>
<pre>			   echo getline('.')</pre>
<pre>			endif</pre>
<
<pre>		Can also be used as a |method|: ></pre>
<pre>			GetName()->searchdecl()</pre>
<
<pre>							*searchpair()*</pre>
searchpair({start}, {middle}, {end} [, {flags} [, {skip}
<pre>				[, {stopline} [, {timeout}]]]])</pre>
<pre>		Search for the match of a nested start-end pair.  This can be</pre>
<pre>		used to find the "endif" that matches an "if", while other</pre>
<pre>		if/endif pairs in between are ignored.</pre>
<pre>		The search starts at the cursor.  The default is to search</pre>
<pre>		forward, include 'b' in {flags} to search backward.</pre>
<pre>		If a match is found, the cursor is positioned at it and the</pre>
<pre>		line number is returned.  If no match is found 0 or -1 is</pre>
<pre>		returned and the cursor doesn't move.  No error message is</pre>
<pre>		given.<p></pre>

<pre>		{start}, {middle} and {end} are patterns, see |pattern|.  They</pre>
<pre>		must not contain \( \) pairs.  Use of \%( \) is allowed.  When</pre>
<pre>		{middle} is not empty, it is found when searching from either</pre>
<pre>		direction, but only when not in a nested start-end pair.  A</pre>
<pre>		typical use is: ></pre>
<pre>			searchpair('\<if\>', '\<else\>', '\<endif\>')</pre>
<		By leaving {middle} empty the "else" is skipped.<p>

<pre>		{flags} 'b', 'c', 'n', 's', 'w' and 'W' are used like with</pre>
<pre>		|search()|.  Additionally:</pre>
<pre>		'r'	Repeat until no more matches found; will find the</pre>
<pre>			outer pair.  Implies the 'W' flag.</pre>
<pre>		'm'	Return number of matches instead of line number with</pre>
<pre>			the match; will be > 1 when 'r' is used.</pre>
<pre>		Note: it's nearly always a good idea to use the 'W' flag, to</pre>
<pre>		avoid wrapping around the end of the file.<p></pre>

<pre>		When a match for {start}, {middle} or {end} is found, the</pre>
<pre>		{skip} expression is evaluated with the cursor positioned on</pre>
<pre>		the start of the match.  It should return non-zero if this</pre>
<pre>		match is to be skipped.  E.g., because it is inside a comment</pre>
<pre>		or a string.</pre>
<pre>		When {skip} is omitted or empty, every match is accepted.</pre>
<pre>		When evaluating {skip} causes an error the search is aborted</pre>
<pre>		and -1 returned.</pre>
<pre>		{skip} can be a string, a lambda, a funcref or a partial.</pre>
<pre>		Anything else makes the function fail.<p></pre>

<pre>		For {stopline} and {timeout} see |search()|.<p></pre>

<pre>		The value of 'ignorecase' is used.  'magic' is ignored, the</pre>
<pre>		patterns are used like it's on.<p></pre>

<pre>		The search starts exactly at the cursor.  A match with</pre>
<pre>		{start}, {middle} or {end} at the next character, in the</pre>
<pre>		direction of searching, is the first one found.  Example: ></pre>
<pre>			if 1</pre>
<pre>			  if 2</pre>
<pre>			  endif 2</pre>
<pre>			endif 1</pre>
<		When starting at the "if 2", with the cursor on the "i", and
<pre>		searching forwards, the "endif 2" is found.  When starting on</pre>
<pre>		the character just before the "if 2", the "endif 1" will be</pre>
<pre>		found.  That's because the "if 2" will be found first, and</pre>
<pre>		then this is considered to be a nested if/endif from "if 2" to</pre>
<pre>		"endif 2".</pre>
<pre>		When searching backwards and {end} is more than one character,</pre>
<pre>		it may be useful to put "\zs" at the end of the pattern, so</pre>
<pre>		that when the cursor is inside a match with the end it finds</pre>
<pre>		the matching start.<p></pre>

<pre>		Example, to find the "endif" command in a Vim script: ><p></pre>

<pre>	:echo searchpair('\<if\>', '\<el\%[seif]\>', '\<en\%[dif]\>', 'W',</pre>
<pre>			\ 'getline(".") =~ "^\\s*\""')<p></pre>

<		The cursor must be at or after the "if" for which a match is
<pre>		to be found.  Note that single-quote strings are used to avoid</pre>
<pre>		having to double the backslashes.  The skip expression only</pre>
<pre>		catches comments at the start of a line, not after a command.</pre>
<pre>		Also, a word "en" or "if" halfway a line is considered a</pre>
<pre>		match.</pre>
<pre>		Another example, to search for the matching "{" of a "}": ><p></pre>

<pre>	:echo searchpair('{', '', '}', 'bW')<p></pre>

<		This works when the cursor is at or before the "}" for which a
<pre>		match is to be found.  To reject matches that syntax</pre>
<pre>		highlighting recognized as strings: ><p></pre>

<pre>	:echo searchpair('{', '', '}', 'bW',</pre>
<pre>	     \ 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string"')</pre>
<
<pre>							*searchpairpos()*</pre>
searchpairpos({start}, {middle}, {end} [, {flags} [, {skip}
<pre>				[, {stopline} [, {timeout}]]]])</pre>
<pre>		Same as |searchpair()|, but returns a |List| with the line and</pre>
<pre>		column position of the match. The first element of the |List|</pre>
<pre>		is the line number and the second element is the byte index of</pre>
<pre>		the column position of the match.  If no match is found,</pre>
<pre>		returns [0, 0]. ><p></pre>

<pre>			:let [lnum,col] = searchpairpos('{', '', '}', 'n')</pre>
<
<pre>		See |match-parens| for a bigger and more useful example.<p></pre>

searchpos({pattern} [, {flags} [, {stopline} [, {timeout}]]])	*searchpos()*
<pre>		Same as |search()|, but returns a |List| with the line and</pre>
<pre>		column position of the match. The first element of the |List|</pre>
<pre>		is the line number and the second element is the byte index of</pre>
<pre>		the column position of the match. If no match is found,</pre>
<pre>		returns [0, 0].</pre>
<pre>		Example: ></pre>
<pre>	:let [lnum, col] = searchpos('mypattern', 'n')<p></pre>

<		When the 'p' flag is given then there is an extra item with
<pre>		the sub-pattern match number |search()-sub-match|.  Example: ></pre>
<pre>	:let [lnum, col, submatch] = searchpos('\(\l\)\|\(\u\)', 'np')</pre>
<		In this example "submatch" is 2 when a lowercase letter is
<pre>		found |/\l|, 3 when an uppercase letter is found |/\u|.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetPattern()->searchpos()<p></pre>

server2client({clientid}, {string})			*server2client()*
<pre>		Send a reply string to {clientid}.  The most recent {clientid}</pre>
<pre>		that sent a string can be retrieved with expand("<client>").</pre>
<pre>		{only available when compiled with the |+clientserver| feature}</pre>
<pre>		Note:</pre>
<pre>		This id has to be stored before the next command can be</pre>
<pre>		received.  I.e. before returning from the received command and</pre>
<pre>		before calling any commands that waits for input.</pre>
<pre>		See also |clientserver|.</pre>
<pre>		Example: ></pre>
<pre>			:echo server2client(expand("<client>"), "HELLO")<p></pre>

<		Can also be used as a |method|: >
<pre>			GetClientId()->server2client(string)</pre>
<
serverlist()					*serverlist()*
<pre>		Return a list of available server names, one per line.</pre>
<pre>		When there are no servers or the information is not available</pre>
<pre>		an empty string is returned.  See also |clientserver|.</pre>
<pre>		{only available when compiled with the |+clientserver| feature}</pre>
<pre>		Example: ></pre>
<pre>			:echo serverlist()</pre>
<
setbufline({expr}, {lnum}, {text})			*setbufline()*
<pre>		Set line {lnum} to {text} in buffer {expr}.  This works like</pre>
<pre>		|setline()| for the specified buffer.<p></pre>

<pre>		This function works only for loaded buffers. First call</pre>
<pre>		|bufload()| if needed.<p></pre>

<pre>		To insert lines use |appendbufline()|.</pre>
<pre>		Any text properties in {lnum} are cleared.<p></pre>

<pre>		{text} can be a string to set one line, or a list of strings</pre>
<pre>		to set multiple lines.  If the list extends below the last</pre>
<pre>		line then those lines are added.<p></pre>

<pre>		For the use of {expr}, see |bufname()| above.<p></pre>

<pre>		{lnum} is used like with |setline()|.</pre>
<pre>		When {lnum} is just below the last line the {text} will be</pre>
<pre>		added below the last line.<p></pre>

<pre>		When {expr} is not a valid buffer, the buffer is not loaded or</pre>
<pre>		{lnum} is not valid then 1 is returned.  On success 0 is</pre>
<pre>		returned.<p></pre>

<pre>		Can also be used as a |method|, the base is passed as the</pre>
<pre>		third argument: ></pre>
<pre>			GetText()->setbufline(buf, lnum)<p></pre>

setbufvar({expr}, {varname}, {val})			*setbufvar()*
<pre>		Set option or local variable {varname} in buffer {expr} to</pre>
<pre>		{val}.</pre>
<pre>		This also works for a global or local window option, but it</pre>
<pre>		doesn't work for a global or local window variable.</pre>
<pre>		For a local window option the global value is unchanged.</pre>
<pre>		For the use of {expr}, see |bufname()| above.</pre>
<pre>		Note that the variable name without "b:" must be used.</pre>
<pre>		Examples: ></pre>
<pre>			:call setbufvar(1, "&mod", 1)</pre>
<pre>			:call setbufvar("todo", "myvar", "foobar")</pre>
<		This function is not available in the |sandbox|.<p>

<pre>		Can also be used as a |method|, the base is passed as the</pre>
<pre>		third argument: ></pre>
<pre>			GetValue()->setbufvar(buf, varname)<p></pre>

setcharsearch({dict})					*setcharsearch()*
<pre>		Set the current character search information to {dict},</pre>
<pre>		which contains one or more of the following entries:<p></pre>

<pre>		    char	character which will be used for a subsequent</pre>
<pre>				|,| or |;| command; an empty string clears the</pre>
<pre>				character search</pre>
<pre>		    forward	direction of character search; 1 for forward,</pre>
<pre>				0 for backward</pre>
<pre>		    until	type of character search; 1 for a |t| or |T|</pre>
<pre>				character search, 0 for an |f| or |F|</pre>
<pre>				character search<p></pre>

<pre>		This can be useful to save/restore a user's character search</pre>
<pre>		from a script: ></pre>
<pre>			:let prevsearch = getcharsearch()</pre>
<pre>			:" Perform a command which clobbers user's search</pre>
<pre>			:call setcharsearch(prevsearch)</pre>
<		Also see |getcharsearch()|.<p>

<pre>		Can also be used as a |method|: ></pre>
<pre>			SavedSearch()->setcharsearch()<p></pre>

setcmdpos({pos})					*setcmdpos()*
<pre>		Set the cursor position in the command line to byte position</pre>
<pre>		{pos}.  The first position is 1.</pre>
<pre>		Use |getcmdpos()| to obtain the current position.</pre>
<pre>		Only works while editing the command line, thus you must use</pre>
<pre>		|c_CTRL-\_e|, |c_CTRL-R_=| or |c_CTRL-R_CTRL-R| with '='.  For</pre>
<pre>		|c_CTRL-\_e| and |c_CTRL-R_CTRL-R| with '=' the position is</pre>
<pre>		set after the command line is set to the expression.  For</pre>
<pre>		|c_CTRL-R_=| it is set after evaluating the expression but</pre>
<pre>		before inserting the resulting text.</pre>
<pre>		When the number is too big the cursor is put at the end of the</pre>
<pre>		line.  A number smaller than one has undefined results.</pre>
<pre>		Returns 0 when successful, 1 when not editing the command</pre>
<pre>		line.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetPos()->setcmdpos()<p></pre>

setenv({name}, {val})						*setenv()*
<pre>		Set environment variable {name} to {val}.</pre>
<pre>		When {val} is |v:null| the environment variable is deleted.</pre>
<pre>		See also |expr-env|.<p></pre>

<pre>		Can also be used as a |method|, the base is passed as the</pre>
<pre>		second argument: ></pre>
<pre>			GetPath()->setenv('PATH')<p></pre>

setfperm({fname}, {mode})				*setfperm()* *chmod*
<pre>		Set the file permissions for {fname} to {mode}.</pre>
<pre>		{mode} must be a string with 9 characters.  It is of the form</pre>
<pre>		"rwxrwxrwx", where each group of "rwx" flags represent, in</pre>
<pre>		turn, the permissions of the owner of the file, the group the</pre>
<pre>		file belongs to, and other users.  A '-' character means the</pre>
<pre>		permission is off, any other character means on.  Multi-byte</pre>
<pre>		characters are not supported.<p></pre>

<pre>		For example "rw-r-----" means read-write for the user,</pre>
<pre>		readable by the group, not accessible by others.  "xx-x-----"</pre>
<pre>		would do the same thing.<p></pre>

<pre>		Returns non-zero for success, zero for failure.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetFilename()->setfperm(mode)</pre>
<
<pre>		To read permissions see |getfperm()|.<p></pre>


setline({lnum}, {text})					*setline()*
<pre>		Set line {lnum} of the current buffer to {text}.  To insert</pre>
<pre>		lines use |append()|. To set lines in another buffer use</pre>
<pre>		|setbufline()|.  Any text properties in {lnum} are cleared.<p></pre>

<pre>		{lnum} is used like with |getline()|.</pre>
<pre>		When {lnum} is just below the last line the {text} will be</pre>
<pre>		added below the last line.<p></pre>

<pre>		If this succeeds, 0 is returned.  If this fails (most likely</pre>
<pre>		because {lnum} is invalid) 1 is returned.<p></pre>

<pre>		Example: ></pre>
<pre>			:call setline(5, strftime("%c"))<p></pre>

<		When {text} is a |List| then line {lnum} and following lines
<pre>		will be set to the items in the list.  Example: ></pre>
<pre>			:call setline(5, ['aaa', 'bbb', 'ccc'])</pre>
<		This is equivalent to: >
<pre>			:for [n, l] in [[5, 'aaa'], [6, 'bbb'], [7, 'ccc']]</pre>
<pre>			:  call setline(n, l)</pre>
<pre>			:endfor<p></pre>

<		Note: The '[ and '] marks are not set.<p>

<pre>		Can also be used as a |method|, the base is passed as the</pre>
<pre>		second argument: ></pre>
<pre>			GetText()->setline(lnum)<p></pre>

setloclist({nr}, {list} [, {action} [, {what}]])		*setloclist()*
<pre>		Create or replace or add to the location list for window {nr}.</pre>
<pre>		{nr} can be the window number or the |window-ID|.</pre>
<pre>		When {nr} is zero the current window is used.<p></pre>

<pre>		For a location list window, the displayed location list is</pre>
<pre>		modified.  For an invalid window number {nr}, -1 is returned.</pre>
<pre>		Otherwise, same as |setqflist()|.</pre>
<pre>		Also see |location-list|.<p></pre>

<pre>		If the optional {what} dictionary argument is supplied, then</pre>
<pre>		only the items listed in {what} are set. Refer to |setqflist()|</pre>
<pre>		for the list of supported keys in {what}.<p></pre>

<pre>		Can also be used as a |method|, the base is passed as the</pre>
<pre>		second argument: ></pre>
<pre>			GetLoclist()->setloclist(winnr)<p></pre>

setmatches({list} [, {win}])				*setmatches()*
<pre>		Restores a list of matches saved by |getmatches() for the</pre>
<pre>		current window|.  Returns 0 if successful, otherwise -1.  All</pre>
<pre>		current matches are cleared before the list is restored.  See</pre>
<pre>		example for |getmatches()|.</pre>
<pre>		If {win} is specified, use the window with this number or</pre>
<pre>		window ID instead of the current window.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetMatches()->setmatches()</pre>
<
<pre>							*setpos()*</pre>
setpos({expr}, {list})
<pre>		Set the position for {expr}.  Possible values:</pre>
<pre>			.	the cursor</pre>
<pre>			'x	mark x<p></pre>

<pre>		{list} must be a |List| with four or five numbers:</pre>
<pre>		    [bufnum, lnum, col, off]</pre>
<pre>		    [bufnum, lnum, col, off, curswant]<p></pre>

<pre>		"bufnum" is the buffer number.  Zero can be used for the</pre>
<pre>		current buffer.  When setting an uppercase mark "bufnum" is</pre>
<pre>		used for the mark position.  For other marks it specifies the</pre>
<pre>		buffer to set the mark in.  You can use the |bufnr()| function</pre>
<pre>		to turn a file name into a buffer number.</pre>
<pre>		For setting the cursor and the ' mark "bufnum" is ignored,</pre>
<pre>		since these are associated with a window, not a buffer.</pre>
<pre>		Does not change the jumplist.<p></pre>

<pre>		"lnum" and "col" are the position in the buffer.  The first</pre>
<pre>		column is 1.  Use a zero "lnum" to delete a mark.  If "col" is</pre>
<pre>		smaller than 1 then 1 is used.<p></pre>

<pre>		The "off" number is only used when 'virtualedit' is set. Then</pre>
<pre>		it is the offset in screen columns from the start of the</pre>
<pre>		character.  E.g., a position within a <Tab> or after the last</pre>
<pre>		character.<p></pre>

<pre>		The "curswant" number is only used when setting the cursor</pre>
<pre>		position.  It sets the preferred column for when moving the</pre>
<pre>		cursor vertically.  When the "curswant" number is missing the</pre>
<pre>		preferred column is not set.  When it is present and setting a</pre>
<pre>		mark position it is not used.<p></pre>

<pre>		Note that for '< and '> changing the line number may result in</pre>
<pre>		the marks to be effectively be swapped, so that '< is always</pre>
<pre>		before '>.<p></pre>

<pre>		Returns 0 when the position could be set, -1 otherwise.</pre>
<pre>		An error message is given if {expr} is invalid.<p></pre>

<pre>		Also see |getpos()| and |getcurpos()|.<p></pre>

<pre>		This does not restore the preferred column for moving</pre>
<pre>		vertically; if you set the cursor position with this, |j| and</pre>
<pre>		|k| motions will jump to previous columns!  Use |cursor()| to</pre>
<pre>		also set the preferred column.  Also see the "curswant" key in</pre>
<pre>		|winrestview()|.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetPosition()->setpos('.')<p></pre>

setqflist({list} [, {action} [, {what}]])		*setqflist()*
<pre>		Create or replace or add to the quickfix list.<p></pre>

<pre>		When {what} is not present, use the items in {list}.  Each</pre>
<pre>		item must be a dictionary.  Non-dictionary items in {list} are</pre>
<pre>		ignored.  Each dictionary item can contain the following</pre>
<pre>		entries:<p></pre>

<pre>		    bufnr	buffer number; must be the number of a valid</pre>
<pre>				buffer</pre>
<pre>		    filename	name of a file; only used when "bufnr" is not</pre>
<pre>				present or it is invalid.</pre>
<pre>		    module	name of a module; if given it will be used in</pre>
<pre>				quickfix error window instead of the filename.</pre>
<pre>		    lnum	line number in the file</pre>
<pre>		    pattern	search pattern used to locate the error</pre>
<pre>		    col		column number</pre>
<pre>		    vcol	when non-zero: "col" is visual column</pre>
<pre>				when zero: "col" is byte index</pre>
<pre>		    nr		error number</pre>
<pre>		    text	description of the error</pre>
<pre>		    type	single-character error type, 'E', 'W', etc.</pre>
<pre>		    valid	recognized error message<p></pre>

<pre>		The "col", "vcol", "nr", "type" and "text" entries are</pre>
<pre>		optional.  Either "lnum" or "pattern" entry can be used to</pre>
<pre>		locate a matching error line.</pre>
<pre>		If the "filename" and "bufnr" entries are not present or</pre>
<pre>		neither the "lnum" or "pattern" entries are present, then the</pre>
<pre>		item will not be handled as an error line.</pre>
<pre>		If both "pattern" and "lnum" are present then "pattern" will</pre>
<pre>		be used.</pre>
<pre>		If the "valid" entry is not supplied, then the valid flag is</pre>
<pre>		set when "bufnr" is a valid buffer or "filename" exists.</pre>
<pre>		If you supply an empty {list}, the quickfix list will be</pre>
<pre>		cleared.</pre>
<pre>		Note that the list is not exactly the same as what</pre>
<pre>		|getqflist()| returns.<p></pre>

<pre>		{action} values:				*E927*</pre>
<pre>		'a'	The items from {list} are added to the existing</pre>
<pre>			quickfix list. If there is no existing list, then a</pre>
<pre>			new list is created.<p></pre>

<pre>		'r'	The items from the current quickfix list are replaced</pre>
<pre>			with the items from {list}.  This can also be used to</pre>
<pre>			clear the list: ></pre>
<pre>				:call setqflist([], 'r')</pre>
<
<pre>		'f'	All the quickfix lists in the quickfix stack are</pre>
<pre>			freed.<p></pre>

<pre>		If {action} is not present or is set to ' ', then a new list</pre>
<pre>		is created. The new quickfix list is added after the current</pre>
<pre>		quickfix list in the stack and all the following lists are</pre>
<pre>		freed. To add a new quickfix list at the end of the stack,</pre>
<pre>		set "nr" in {what} to "$".<p></pre>

<pre>		If the optional {what} dictionary argument is supplied, then</pre>
<pre>		only the items listed in {what} are set. The first {list}</pre>
<pre>		argument is ignored.  The following items can be specified in</pre>
<pre>		{what}:</pre>
<pre>		    context	quickfix list context. See |quickfix-context|</pre>
<pre>		    efm		errorformat to use when parsing text from</pre>
<pre>				"lines". If this is not present, then the</pre>
<pre>				'errorformat' option value is used.</pre>
<pre>				See |quickfix-parse|</pre>
<pre>		    id		quickfix list identifier |quickfix-ID|</pre>
<pre>		    idx		index of the current entry in the quickfix</pre>
<pre>				list specified by 'id' or 'nr'. If set to '$',</pre>
<pre>				then the last entry in the list is set as the</pre>
<pre>				current entry.  See |quickfix-index|</pre>
<pre>		    items	list of quickfix entries. Same as the {list}</pre>
<pre>				argument.</pre>
<pre>		    lines	use 'errorformat' to parse a list of lines and</pre>
<pre>				add the resulting entries to the quickfix list</pre>
<pre>				{nr} or {id}.  Only a |List| value is supported.</pre>
<pre>				See |quickfix-parse|</pre>
<pre>		    nr		list number in the quickfix stack; zero</pre>
<pre>				means the current quickfix list and "$" means</pre>
<pre>				the last quickfix list.</pre>
<pre>		    title	quickfix list title text. See |quickfix-title|</pre>
<pre>		Unsupported keys in {what} are ignored.</pre>
<pre>		If the "nr" item is not present, then the current quickfix list</pre>
<pre>		is modified. When creating a new quickfix list, "nr" can be</pre>
<pre>		set to a value one greater than the quickfix stack size.</pre>
<pre>		When modifying a quickfix list, to guarantee that the correct</pre>
<pre>		list is modified, "id" should be used instead of "nr" to</pre>
<pre>		specify the list.<p></pre>

<pre>		Examples (See also |setqflist-examples|): ></pre>
<pre>		   :call setqflist([], 'r', {'title': 'My search'})</pre>
<pre>		   :call setqflist([], 'r', {'nr': 2, 'title': 'Errors'})</pre>
<pre>		   :call setqflist([], 'a', {'id':qfid, 'lines':["F1:10:L10"]})</pre>
<
<pre>		Returns zero for success, -1 for failure.<p></pre>

<pre>		This function can be used to create a quickfix list</pre>
<pre>		independent of the 'errorformat' setting.  Use a command like</pre>
<pre>		`:cc 1` to jump to the first position.<p></pre>

<pre>		Can also be used as a |method|, the base is passed as the</pre>
<pre>		second argument: ></pre>
<pre>			GetErrorlist()->setqflist()</pre>
<
<pre>							*setreg()*</pre>
setreg({regname}, {value} [, {options}])
<pre>		Set the register {regname} to {value}.</pre>
<pre>		{value} may be any value returned by |getreg()|, including</pre>
<pre>		a |List|.</pre>
<pre>		If {options} contains "a" or {regname} is upper case,</pre>
<pre>		then the value is appended.</pre>
<pre>		{options} can also contain a register type specification:</pre>
<pre>		    "c" or "v"	      |characterwise| mode</pre>
<pre>		    "l" or "V"	      |linewise| mode</pre>
<pre>		    "b" or "<CTRL-V>" |blockwise-visual| mode</pre>
<pre>		If a number immediately follows "b" or "<CTRL-V>" then this is</pre>
<pre>		used as the width of the selection - if it is not specified</pre>
<pre>		then the width of the block is set to the number of characters</pre>
<pre>		in the longest line (counting a <Tab> as 1 character).<p></pre>

<pre>		If {options} contains no register settings, then the default</pre>
<pre>		is to use character mode unless {value} ends in a <NL> for</pre>
<pre>		string {value} and linewise mode for list {value}. Blockwise</pre>
<pre>		mode is never selected automatically.</pre>
<pre>		Returns zero for success, non-zero for failure.<p></pre>

<pre>							*E883*</pre>
<pre>		Note: you may not use |List| containing more than one item to</pre>
<pre>		      set search and expression registers. Lists containing no</pre>
<pre>		      items act like empty strings.<p></pre>

<pre>		Examples: ></pre>
<pre>			:call setreg(v:register, @*)</pre>
<pre>			:call setreg('*', @%, 'ac')</pre>
<pre>			:call setreg('a', "1\n2\n3", 'b5')<p></pre>

<		This example shows using the functions to save and restore a
<pre>		register: ></pre>
<pre>			:let var_a = getreg('a', 1, 1)</pre>
<pre>			:let var_amode = getregtype('a')</pre>
<pre>			    ....</pre>
<pre>			:call setreg('a', var_a, var_amode)</pre>
<		Note: you may not reliably restore register value
<pre>		without using the third argument to |getreg()| as without it</pre>
<pre>		newlines are represented as newlines AND Nul bytes are</pre>
<pre>		represented as newlines as well, see |NL-used-for-Nul|.<p></pre>

<pre>		You can also change the type of a register by appending</pre>
<pre>		nothing: ></pre>
<pre>			:call setreg('a', '', 'al')<p></pre>

<		Can also be used as a |method|, the base is passed as the
<pre>		second argument: ></pre>
<pre>			GetText()->setreg('a')<p></pre>

settabvar({tabnr}, {varname}, {val})			*settabvar()*
<pre>		Set tab-local variable {varname} to {val} in tab page {tabnr}.</pre>
<pre>		|t:var|</pre>
<pre>		Note that autocommands are blocked, side effects may not be</pre>
<pre>		triggered, e.g. when setting 'filetype'.</pre>
<pre>		Note that the variable name without "t:" must be used.</pre>
<pre>		Tabs are numbered starting with one.</pre>
<pre>		This function is not available in the |sandbox|.<p></pre>

<pre>		Can also be used as a |method|, the base is passed as the</pre>
<pre>		third argument: ></pre>
<pre>			GetValue()->settabvar(tab, name)<p></pre>

settabwinvar({tabnr}, {winnr}, {varname}, {val})	*settabwinvar()*
<pre>		Set option or local variable {varname} in window {winnr} to</pre>
<pre>		{val}.</pre>
<pre>		Tabs are numbered starting with one.  For the current tabpage</pre>
<pre>		use |setwinvar()|.</pre>
<pre>		{winnr} can be the window number or the |window-ID|.</pre>
<pre>		When {winnr} is zero the current window is used.</pre>
<pre>		Note that autocommands are blocked, side effects may not be</pre>
<pre>		triggered, e.g. when setting 'filetype' or 'syntax'.</pre>
<pre>		This also works for a global or local buffer option, but it</pre>
<pre>		doesn't work for a global or local buffer variable.</pre>
<pre>		For a local buffer option the global value is unchanged.</pre>
<pre>		Note that the variable name without "w:" must be used.</pre>
<pre>		Examples: ></pre>
<pre>			:call settabwinvar(1, 1, "&list", 0)</pre>
<pre>			:call settabwinvar(3, 2, "myvar", "foobar")</pre>
<		This function is not available in the |sandbox|.<p>

<pre>		Can also be used as a |method|, the base is passed as the</pre>
<pre>		fourth argument: ></pre>
<pre>			GetValue()->settabvar(tab, winnr, name)<p></pre>

settagstack({nr}, {dict} [, {action}])			*settagstack()*
<pre>		Modify the tag stack of the window {nr} using {dict}.</pre>
<pre>		{nr} can be the window number or the |window-ID|.<p></pre>

<pre>		For a list of supported items in {dict}, refer to</pre>
<pre>		|gettagstack()|</pre>
<pre>							*E962*</pre>
<pre>		If {action} is not present or is set to 'r', then the tag</pre>
<pre>		stack is replaced. If {action} is set to 'a', then new entries</pre>
<pre>		from {dict} are pushed onto the tag stack.<p></pre>

<pre>		Returns zero for success, -1 for failure.<p></pre>

<pre>		Examples:</pre>
<pre>		    Set current index of the tag stack to 4: ></pre>
<pre>			call settagstack(1005, {'curidx' : 4})<p></pre>

<		    Empty the tag stack of window 3: >
<pre>			call settagstack(3, {'items' : []})<p></pre>

<		    Push a new item onto the tag stack: >
<pre>			let pos = [bufnr('myfile.txt'), 10, 1, 0]</pre>
<pre>			let newtag = [{'tagname' : 'mytag', 'from' : pos}]</pre>
<pre>			call settagstack(2, {'items' : newtag}, 'a')<p></pre>

<		    Save and restore the tag stack: >
<pre>			let stack = gettagstack(1003)</pre>
<pre>			" do something else</pre>
<pre>			call settagstack(1003, stack)</pre>
<pre>			unlet stack</pre>
<
<pre>		Can also be used as a |method|, the base is passed as the</pre>
<pre>		second argument: ></pre>
<pre>			GetStack()->settagstack(winnr)<p></pre>

setwinvar({winnr}, {varname}, {val})			*setwinvar()*
<pre>		Like |settabwinvar()| for the current tab page.</pre>
<pre>		Examples: ></pre>
<pre>			:call setwinvar(1, "&list", 0)</pre>
<pre>			:call setwinvar(2, "myvar", "foobar")<p></pre>

<		Can also be used as a |method|, the base is passed as the
<pre>		third argument: ></pre>
<pre>			GetValue()->setwinvar(winnr, name)<p></pre>

sha256({string})						*sha256()*
<pre>		Returns a String with 64 hex characters, which is the SHA256</pre>
<pre>		checksum of {string}.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetText()->sha256()<p></pre>

<		{only available when compiled with the |+cryptv| feature}<p>

shellescape({string} [, {special}])			*shellescape()*
<pre>		Escape {string} for use as a shell command argument.</pre>
<pre>		On MS-Windows, when 'shellslash' is not set, it will enclose</pre>
<pre>		{string} in double quotes and double all double quotes within</pre>
<pre>		{string}.</pre>
<pre>		Otherwise it will enclose {string} in single quotes and</pre>
<pre>		replace all "'" with "'\''".<p></pre>

<pre>		When the {special} argument is present and it's a non-zero</pre>
<pre>		Number or a non-empty String (|non-zero-arg|), then special</pre>
<pre>		items such as "!", "%", "#" and "<cword>" will be preceded by</pre>
<pre>		a backslash.  This backslash will be removed again by the |:!|</pre>
<pre>		command.<p></pre>

<pre>		The "!" character will be escaped (again with a |non-zero-arg|</pre>
<pre>		{special}) when 'shell' contains "csh" in the tail.  That is</pre>
<pre>		because for csh and tcsh "!" is used for history replacement</pre>
<pre>		even when inside single quotes.<p></pre>

<pre>		With a |non-zero-arg| {special} the <NL> character is also</pre>
<pre>		escaped.  When 'shell' containing "csh" in the tail it's</pre>
<pre>		escaped a second time.<p></pre>

<pre>		Example of use with a |:!| command: ></pre>
<pre>		    :exe '!dir ' . shellescape(expand('<cfile>'), 1)</pre>
<		This results in a directory listing for the file under the
<pre>		cursor.  Example of use with |system()|: ></pre>
<pre>		    :call system("chmod +w -- " . shellescape(expand("%")))</pre>
<		See also |::S|.<p>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetCommand()->shellescape()<p></pre>

shiftwidth([{col}])						*shiftwidth()*
<pre>		Returns the effective value of 'shiftwidth'. This is the</pre>
<pre>		'shiftwidth' value unless it is zero, in which case it is the</pre>
<pre>		'tabstop' value.  This function was introduced with patch</pre>
<pre>		7.3.694 in 2012, everybody should have it by now (however it</pre>
<pre>		did not allow for the optional {col} argument until 8.1.542).<p></pre>

<pre>		When there is one argument {col} this is used as column number</pre>
<pre>		for which to return the 'shiftwidth' value. This matters for the</pre>
<pre>		'vartabstop' feature. If the 'vartabstop' setting is enabled and</pre>
<pre>		no {col} argument is given, column 1 will be assumed.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetColumn()->shiftwidth()<p></pre>

sign_ functions are documented here: |sign-functions-details|<p>


simplify({filename})					*simplify()*
<pre>		Simplify the file name as much as possible without changing</pre>
<pre>		the meaning.  Shortcuts (on MS-Windows) or symbolic links (on</pre>
<pre>		Unix) are not resolved.  If the first path component in</pre>
<pre>		{filename} designates the current directory, this will be</pre>
<pre>		valid for the result as well.  A trailing path separator is</pre>
<pre>		not removed either.</pre>
<pre>		Example: ></pre>
<pre>			simplify("./dir/.././/file/") == "./file/"</pre>
<		Note: The combination "dir/.." is only removed if "dir" is
<pre>		a searchable directory or does not exist.  On Unix, it is also</pre>
<pre>		removed when "dir" is a symbolic link within the same</pre>
<pre>		directory.  In order to resolve all the involved symbolic</pre>
<pre>		links before simplifying the path name, use |resolve()|.<p></pre>


sin({expr})						*sin()*
<pre>		Return the sine of {expr}, measured in radians, as a |Float|.</pre>
<pre>		{expr} must evaluate to a |Float| or a |Number|.</pre>
<pre>		Examples: ></pre>
<pre>			:echo sin(100)</pre>
<			-0.506366 >
<pre>			:echo sin(-4.01)</pre>
<			0.763301<p>

<pre>		Can also be used as a |method|: ></pre>
<pre>			Compute()->sin()</pre>
<
<pre>		{only available when compiled with the |+float| feature}<p></pre>


sinh({expr})						*sinh()*
<pre>		Return the hyperbolic sine of {expr} as a |Float| in the range</pre>
<pre>		[-inf, inf].</pre>
<pre>		{expr} must evaluate to a |Float| or a |Number|.</pre>
<pre>		Examples: ></pre>
<pre>			:echo sinh(0.5)</pre>
<			0.521095 >
<pre>			:echo sinh(-0.9)</pre>
<			-1.026517<p>

<pre>		Can also be used as a |method|: ></pre>
<pre>			Compute()->sinh()</pre>
<
<pre>		{only available when compiled with the |+float| feature}<p></pre>


sort({list} [, {func} [, {dict}]])			*sort()* *E702*
<pre>		Sort the items in {list} in-place.  Returns {list}.<p></pre>

<pre>		If you want a list to remain unmodified make a copy first: ></pre>
<pre>			:let sortedlist = sort(copy(mylist))<p></pre>

<		When {func} is omitted, is empty or zero, then sort() uses the
<pre>		string representation of each item to sort on.  Numbers sort</pre>
<pre>		after Strings, |Lists| after Numbers.  For sorting text in the</pre>
<pre>		current buffer use |:sort|.<p></pre>

<pre>		When {func} is given and it is '1' or 'i' then case is</pre>
<pre>		ignored.<p></pre>

<pre>		When {func} is given and it is 'n' then all items will be</pre>
<pre>		sorted numerical (Implementation detail: This uses the</pre>
<pre>		strtod() function to parse numbers, Strings, Lists, Dicts and</pre>
<pre>		Funcrefs will be considered as being 0).<p></pre>

<pre>		When {func} is given and it is 'N' then all items will be</pre>
<pre>		sorted numerical. This is like 'n' but a string containing</pre>
<pre>		digits will be used as the number they represent.<p></pre>

<pre>		When {func} is given and it is 'f' then all items will be</pre>
<pre>		sorted numerical. All values must be a Number or a Float.<p></pre>

<pre>		When {func} is a |Funcref| or a function name, this function</pre>
<pre>		is called to compare items.  The function is invoked with two</pre>
<pre>		items as argument and must return zero if they are equal, 1 or</pre>
<pre>		bigger if the first one sorts after the second one, -1 or</pre>
<pre>		smaller if the first one sorts before the second one.<p></pre>

<pre>		{dict} is for functions with the "dict" attribute.  It will be</pre>
<pre>		used to set the local variable "self". |Dictionary-function|<p></pre>

<pre>		The sort is stable, items which compare equal (as number or as</pre>
<pre>		string) will keep their relative position. E.g., when sorting</pre>
<pre>		on numbers, text strings will sort next to each other, in the</pre>
<pre>		same order as they were originally.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			mylist->sort()<p></pre>

<		Also see |uniq()|.<p>

<pre>		Example: ></pre>
<pre>			func MyCompare(i1, i2)</pre>
<pre>			   return a:i1 == a:i2 ? 0 : a:i1 > a:i2 ? 1 : -1</pre>
<pre>			endfunc</pre>
<pre>			let sortedlist = sort(mylist, "MyCompare")</pre>
<		A shorter compare version for this specific simple case, which
<pre>		ignores overflow: ></pre>
<pre>			func MyCompare(i1, i2)</pre>
<pre>			   return a:i1 - a:i2</pre>
<pre>			endfunc</pre>
<
sound_clear()						*sound_clear()*
<pre>		Stop playing all sounds.</pre>
<pre>		{only available when compiled with the |+sound| feature}<p></pre>

<pre>							*sound_playevent()*</pre>
sound_playevent({name} [, {callback}])
<pre>		Play a sound identified by {name}.  Which event names are</pre>
<pre>		supported depends on the system.  Often the XDG sound names</pre>
<pre>		are used.  On Ubuntu they may be found in</pre>
<pre>		/usr/share/sounds/freedesktop/stereo.  Example: ></pre>
<pre>			call sound_playevent('bell')</pre>
<		On MS-Windows, {name} can be SystemAsterisk, SystemDefault,
<pre>		SystemExclamation, SystemExit, SystemHand, SystemQuestion,</pre>
<pre>		SystemStart, SystemWelcome, etc.<p></pre>

<pre>		When {callback} is specified it is invoked when the sound is</pre>
<pre>		finished.  The first argument is the sound ID, the second</pre>
<pre>		argument is the status:</pre>
<pre>			0	sound was played to the end</pre>
<pre>			1	sound was interrupted</pre>
<pre>			2	error occurred after sound started</pre>
<pre>		Example: ></pre>
<pre>		   func Callback(id, status)</pre>
<pre>		     echomsg "sound " .. a:id .. " finished with " .. a:status</pre>
<pre>		   endfunc</pre>
<pre>		   call sound_playevent('bell', 'Callback')<p></pre>

<		MS-Windows: {callback} doesn't work for this function.<p>

<pre>		Returns the sound ID, which can be passed to `sound_stop()`.</pre>
<pre>		Returns zero if the sound could not be played.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetSoundName()->sound_playevent()<p></pre>

<		{only available when compiled with the |+sound| feature}<p>

<pre>							*sound_playfile()*</pre>
sound_playfile({path} [, {callback}])
<pre>		Like `sound_playevent()` but play sound file {path}.  {path}</pre>
<pre>		must be a full path.  On Ubuntu you may find files to play</pre>
<pre>		with this command: ></pre>
<pre>		    :!find /usr/share/sounds -type f | grep -v index.theme<p></pre>

<		Can also be used as a |method|: >
<pre>			GetSoundPath()->sound_playfile()<p></pre>

<		{only available when compiled with the |+sound| feature}<p>


sound_stop({id})					*sound_stop()*
<pre>		Stop playing sound {id}.  {id} must be previously returned by</pre>
<pre>		`sound_playevent()` or `sound_playfile()`.<p></pre>

<pre>		On MS-Windows, this does not work for event sound started by</pre>
<pre>		`sound_playevent()`. To stop event sounds, use `sound_clear()`.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			soundid->sound_stop()<p></pre>

<		{only available when compiled with the |+sound| feature}<p>

<pre>							*soundfold()*</pre>
soundfold({word})
<pre>		Return the sound-folded equivalent of {word}.  Uses the first</pre>
<pre>		language in 'spelllang' for the current window that supports</pre>
<pre>		soundfolding.  'spell' must be set.  When no sound folding is</pre>
<pre>		possible the {word} is returned unmodified.</pre>
<pre>		This can be used for making spelling suggestions.  Note that</pre>
<pre>		the method can be quite slow.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetWord()->soundfold()</pre>
<
<pre>							*spellbadword()*</pre>
spellbadword([{sentence}])
<pre>		Without argument: The result is the badly spelled word under</pre>
<pre>		or after the cursor.  The cursor is moved to the start of the</pre>
<pre>		bad word.  When no bad word is found in the cursor line the</pre>
<pre>		result is an empty string and the cursor doesn't move.<p></pre>

<pre>		With argument: The result is the first word in {sentence} that</pre>
<pre>		is badly spelled.  If there are no spelling mistakes the</pre>
<pre>		result is an empty string.<p></pre>

<pre>		The return value is a list with two items:</pre>
<pre>		- The badly spelled word or an empty string.</pre>
<pre>		- The type of the spelling error:</pre>
<pre>			"bad"		spelling mistake</pre>
<pre>			"rare"		rare word</pre>
<pre>			"local"		word only valid in another region</pre>
<pre>			"caps"		word should start with Capital</pre>
<pre>		Example: ></pre>
<pre>			echo spellbadword("the quik brown fox")</pre>
<			['quik', 'bad'] ~<p>

<pre>		The spelling information for the current window is used.  The</pre>
<pre>		'spell' option must be set and the value of 'spelllang' is</pre>
<pre>		used.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetText()->spellbadword()</pre>
<
<pre>							*spellsuggest()*</pre>
spellsuggest({word} [, {max} [, {capital}]])
<pre>		Return a |List| with spelling suggestions to replace {word}.</pre>
<pre>		When {max} is given up to this number of suggestions are</pre>
<pre>		returned.  Otherwise up to 25 suggestions are returned.<p></pre>

<pre>		When the {capital} argument is given and it's non-zero only</pre>
<pre>		suggestions with a leading capital will be given.  Use this</pre>
<pre>		after a match with 'spellcapcheck'.<p></pre>

<pre>		{word} can be a badly spelled word followed by other text.</pre>
<pre>		This allows for joining two words that were split.  The</pre>
<pre>		suggestions also include the following text, thus you can</pre>
<pre>		replace a line.<p></pre>

<pre>		{word} may also be a good word.  Similar words will then be</pre>
<pre>		returned.  {word} itself is not included in the suggestions,</pre>
<pre>		although it may appear capitalized.<p></pre>

<pre>		The spelling information for the current window is used.  The</pre>
<pre>		'spell' option must be set and the values of 'spelllang' and</pre>
<pre>		'spellsuggest' are used.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetWord()->spellsuggest()<p></pre>

split({expr} [, {pattern} [, {keepempty}]])			*split()*
<pre>		Make a |List| out of {expr}.  When {pattern} is omitted or</pre>
<pre>		empty each white-separated sequence of characters becomes an</pre>
<pre>		item.</pre>
<pre>		Otherwise the string is split where {pattern} matches,</pre>
<pre>		removing the matched characters. 'ignorecase' is not used</pre>
<pre>		here, add \c to ignore case. |/\c|</pre>
<pre>		When the first or last item is empty it is omitted, unless the</pre>
<pre>		{keepempty} argument is given and it's non-zero.</pre>
<pre>		Other empty items are kept when {pattern} matches at least one</pre>
<pre>		character or when {keepempty} is non-zero.</pre>
<pre>		Example: ></pre>
<pre>			:let words = split(getline('.'), '\W\+')</pre>
<		To split a string in individual characters: >
<pre>			:for c in split(mystring, '\zs')</pre>
<		If you want to keep the separator you can also use '\zs' at
<pre>		the end of the pattern: ></pre>
<pre>			:echo split('abc:def:ghi', ':\zs')</pre>
<			['abc:', 'def:', 'ghi'] ~
<pre>		Splitting a table where the first element can be empty: ></pre>
<pre>			:let items = split(line, ':', 1)</pre>
<		The opposite function is |join()|.<p>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetString()->split()<p></pre>

sqrt({expr})						*sqrt()*
<pre>		Return the non-negative square root of Float {expr} as a</pre>
<pre>		|Float|.</pre>
<pre>		{expr} must evaluate to a |Float| or a |Number|.  When {expr}</pre>
<pre>		is negative the result is NaN (Not a Number).</pre>
<pre>		Examples: ></pre>
<pre>			:echo sqrt(100)</pre>
<			10.0 >
<pre>			:echo sqrt(-4.01)</pre>
<			nan
<pre>		"nan" may be different, it depends on system libraries.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			Compute()->sqrt()</pre>
<
<pre>		{only available when compiled with the |+float| feature}<p></pre>


srand([{expr}])						*srand()*
<pre>		Initialize seed used by |rand()|:</pre>
<pre>		- If {expr} is not given, seed values are initialized by</pre>
<pre>		  time(NULL) a.k.a. epoch time.  This only has second</pre>
<pre>		  accuracy.</pre>
<pre>		- If {expr} is given, return seed values which x element is</pre>
<pre>		  {expr}.  This is useful for testing or when a predictable</pre>
<pre>		  sequence is expected.<p></pre>

<pre>		Examples: ></pre>
<pre>			:let seed = srand()</pre>
<pre>			:let seed = srand(userinput)</pre>
<pre>			:echo rand(seed)<p></pre>

state([{what}])						*state()*
<pre>		Return a string which contains characters indicating the</pre>
<pre>		current state.  Mostly useful in callbacks that want to do</pre>
<pre>		work that may not always be safe.  Roughly this works like:</pre>
<pre>		- callback uses state() to check if work is safe to do.</pre>
<pre>		  Yes: then do it right away.</pre>
<pre>		  No:  add to work queue and add a |SafeState| and/or</pre>
<pre>		       |SafeStateAgain| autocommand (|SafeState| triggers at</pre>
<pre>		       toplevel, |SafeStateAgain| triggers after handling</pre>
<pre>		       messages and callbacks).</pre>
<pre>		- When SafeState or SafeStateAgain is triggered and executes</pre>
<pre>		  your autocommand, check with `state()` if the work can be</pre>
<pre>		  done now, and if yes remove it from the queue and execute.</pre>
<pre>		  Remove the autocommand if the queue is now empty.</pre>
<pre>		Also see |mode()|.<p></pre>

<pre>		When {what} is given only characters in this string will be</pre>
<pre>		added.  E.g, this checks if the screen has scrolled: ></pre>
<pre>			if state('s') == ''</pre>
<pre>			   " screen has not scrolled</pre>
<
<pre>		These characters indicate the state, generally indicating that</pre>
<pre>		something is busy:</pre>
<pre>		    m	halfway a mapping, :normal command, feedkeys() or</pre>
<pre>			stuffed command</pre>
<pre>		    o	operator pending or waiting for a command argument,</pre>
<pre>		        e.g. after |f|</pre>
<pre>		    a	Insert mode autocomplete active</pre>
<pre>		    x	executing an autocommand</pre>
<pre>		    w	blocked on waiting, e.g. ch_evalexpr(), ch_read() and</pre>
<pre>			ch_readraw() when reading json.</pre>
<pre>		    S	not triggering SafeState or SafeStateAgain</pre>
<pre>		    c	callback invoked, including timer (repeats for</pre>
<pre>			recursiveness up to "ccc")</pre>
<pre>		    s	screen has scrolled for messages<p></pre>

str2float({expr})					*str2float()*
<pre>		Convert String {expr} to a Float.  This mostly works the same</pre>
<pre>		as when using a floating point number in an expression, see</pre>
<pre>		|floating-point-format|.  But it's a bit more permissive.</pre>
<pre>		E.g., "1e40" is accepted, while in an expression you need to</pre>
<pre>		write "1.0e40".  The hexadecimal form "0x123" is also</pre>
<pre>		accepted, but not others, like binary or octal.</pre>
<pre>		Text after the number is silently ignored.</pre>
<pre>		The decimal point is always '.', no matter what the locale is</pre>
<pre>		set to.  A comma ends the number: "12,345.67" is converted to</pre>
<pre>		12.0.  You can strip out thousands separators with</pre>
<pre>		|substitute()|: ></pre>
<pre>			let f = str2float(substitute(text, ',', '', 'g'))</pre>
<
<pre>		Can also be used as a |method|: ></pre>
<pre>			let f = text->substitute(',', '', 'g')->str2float()</pre>
<
<pre>		{only available when compiled with the |+float| feature}<p></pre>

str2list({expr} [, {utf8}])				*str2list()*
<pre>		Return a list containing the number values which represent</pre>
<pre>		each character in String {expr}.  Examples: ></pre>
<pre>			str2list(" ")		returns [32]</pre>
<pre>			str2list("ABC")		returns [65, 66, 67]</pre>
<		|list2str()| does the opposite.<p>

<pre>		When {utf8} is omitted or zero, the current 'encoding' is used.</pre>
<pre>		With {utf8} set to 1, always treat the String as utf-8</pre>
<pre>		characters.  With utf-8 composing characters are handled</pre>
<pre>		properly: ></pre>
<pre>			str2list("á")		returns [97, 769]<p></pre>

<		Can also be used as a |method|: >
<pre>			GetString()->str2list()<p></pre>


str2nr({expr} [, {base} [, {quoted}]])				*str2nr()*
<pre>		Convert string {expr} to a number.</pre>
<pre>		{base} is the conversion base, it can be 2, 8, 10 or 16.</pre>
<pre>		When {quoted} is present and non-zero then embedded single</pre>
<pre>		quotes are ignored, thus "1'000'000" is a million.<p></pre>

<pre>		When {base} is omitted base 10 is used.  This also means that</pre>
<pre>		a leading zero doesn't cause octal conversion to be used, as</pre>
<pre>		with the default String to Number conversion.  Example: ></pre>
<pre>			let nr = str2nr('0123')</pre>
<
<pre>		When {base} is 16 a leading "0x" or "0X" is ignored.  With a</pre>
<pre>		different base the result will be zero.  Similarly, when</pre>
<pre>		{base} is 8 a leading "0" is ignored, and when {base} is 2 a</pre>
<pre>		leading "0b" or "0B" is ignored.</pre>
<pre>		Text after the number is silently ignored.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetText()->str2nr()<p></pre>

strcharpart({src}, {start} [, {len}])			*strcharpart()*
<pre>		Like |strpart()| but using character index and length instead</pre>
<pre>		of byte index and length.</pre>
<pre>		When a character index is used where a character does not</pre>
<pre>		exist it is assumed to be one character.  For example: ></pre>
<pre>			strcharpart('abc', -1, 2)</pre>
<		results in 'a'.<p>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetText()->strcharpart(5)<p></pre>

strchars({expr} [, {skipcc}])					*strchars()*
<pre>		The result is a Number, which is the number of characters</pre>
<pre>		in String {expr}.</pre>
<pre>		When {skipcc} is omitted or zero, composing characters are</pre>
<pre>		counted separately.</pre>
<pre>		When {skipcc} set to 1, Composing characters are ignored.</pre>
<pre>		Also see |strlen()|, |strdisplaywidth()| and |strwidth()|.<p></pre>

<pre>		{skipcc} is only available after 7.4.755.  For backward</pre>
<pre>		compatibility, you can define a wrapper function: ></pre>
<pre>		    if has("patch-7.4.755")</pre>
<pre>		      function s:strchars(str, skipcc)</pre>
<pre>			return strchars(a:str, a:skipcc)</pre>
<pre>		      endfunction</pre>
<pre>		    else</pre>
<pre>		      function s:strchars(str, skipcc)</pre>
<pre>			if a:skipcc</pre>
<pre>			  return strlen(substitute(a:str, ".", "x", "g"))</pre>
<pre>			else</pre>
<pre>			  return strchars(a:str)</pre>
<pre>			endif</pre>
<pre>		      endfunction</pre>
<pre>		    endif</pre>
<
<pre>		Can also be used as a |method|: ></pre>
<pre>			GetText()->strchars()<p></pre>

strdisplaywidth({expr} [, {col}])			*strdisplaywidth()*
<pre>		The result is a Number, which is the number of display cells</pre>
<pre>		String {expr} occupies on the screen when it starts at {col}</pre>
<pre>		(first column is zero).  When {col} is omitted zero is used.</pre>
<pre>		Otherwise it is the screen column where to start.  This</pre>
<pre>		matters for Tab characters.</pre>
<pre>		The option settings of the current window are used.  This</pre>
<pre>		matters for anything that's displayed differently, such as</pre>
<pre>		'tabstop' and 'display'.</pre>
<pre>		When {expr} contains characters with East Asian Width Class</pre>
<pre>		Ambiguous, this function's return value depends on 'ambiwidth'.</pre>
<pre>		Also see |strlen()|, |strwidth()| and |strchars()|.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetText()->strdisplaywidth()<p></pre>

strftime({format} [, {time}])				*strftime()*
<pre>		The result is a String, which is a formatted date and time, as</pre>
<pre>		specified by the {format} string.  The given {time} is used,</pre>
<pre>		or the current time if no time is given.  The accepted</pre>
<pre>		{format} depends on your system, thus this is not portable!</pre>
<pre>		See the manual page of the C function strftime() for the</pre>
<pre>		format.  The maximum length of the result is 80 characters.</pre>
<pre>		See also |localtime()|, |getftime()| and |strptime()|.</pre>
<pre>		The language can be changed with the |:language| command.</pre>
<pre>		Examples: ></pre>
<pre>		  :echo strftime("%c")		   Sun Apr 27 11:49:23 1997</pre>
<pre>		  :echo strftime("%Y %b %d %X")	   1997 Apr 27 11:53:25</pre>
<pre>		  :echo strftime("%y%m%d %T")	   970427 11:53:55</pre>
<pre>		  :echo strftime("%H:%M")	   11:55</pre>
<pre>		  :echo strftime("%c", getftime("file.c"))</pre>
<pre>						   Show mod time of file.c.</pre>
<		Not available on all systems.  To check use: >
<pre>			:if exists("*strftime")<p></pre>

<		Can also be used as a |method|: >
<pre>			GetFormat()->strftime()<p></pre>

strgetchar({str}, {index})				*strgetchar()*
<pre>		Get character {index} from {str}.  This uses a character</pre>
<pre>		index, not a byte index.  Composing characters are considered</pre>
<pre>		separate characters here.</pre>
<pre>		Also see |strcharpart()| and |strchars()|.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetText()->strgetchar(5)<p></pre>

stridx({haystack}, {needle} [, {start}])		*stridx()*
<pre>		The result is a Number, which gives the byte index in</pre>
<pre>		{haystack} of the first occurrence of the String {needle}.</pre>
<pre>		If {start} is specified, the search starts at index {start}.</pre>
<pre>		This can be used to find a second match: ></pre>
<pre>			:let colon1 = stridx(line, ":")</pre>
<pre>			:let colon2 = stridx(line, ":", colon1 + 1)</pre>
<		The search is done case-sensitive.
<pre>		For pattern searches use |match()|.</pre>
<pre>		-1 is returned if the {needle} does not occur in {haystack}.</pre>
<pre>		See also |strridx()|.</pre>
<pre>		Examples: ></pre>
<pre>		  :echo stridx("An Example", "Example")	     3</pre>
<pre>		  :echo stridx("Starting point", "Start")    0</pre>
<pre>		  :echo stridx("Starting point", "start")   -1</pre>
<						*strstr()* *strchr()*
<pre>		stridx() works similar to the C function strstr().  When used</pre>
<pre>		with a single character it works similar to strchr().<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetHaystack()->stridx(needle)</pre>
<
<pre>							*string()*</pre>
string({expr})	Return {expr} converted to a String.  If {expr} is a Number,
<pre>		Float, String, Blob or a composition of them, then the result</pre>
<pre>		can be parsed back with |eval()|.</pre>
<pre>			{expr} type	result ~</pre>
<pre>			String		'string' (single quotes are doubled)</pre>
<pre>			Number		123</pre>
<pre>			Float		123.123456 or 1.123456e8</pre>
<pre>			Funcref		function('name')</pre>
<pre>			Blob		0z00112233.44556677.8899</pre>
<pre>			List		[item, item]</pre>
<pre>			Dictionary	{key: value, key: value}<p></pre>

<pre>		When a List or Dictionary has a recursive reference it is</pre>
<pre>		replaced by "[...]" or "{...}".  Using eval() on the result</pre>
<pre>		will then fail.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			mylist->string()<p></pre>

<		Also see |strtrans()|.<p>

<pre>							*strlen()*</pre>
strlen({expr})	The result is a Number, which is the length of the String
<pre>		{expr} in bytes.</pre>
<pre>		If the argument is a Number it is first converted to a String.</pre>
<pre>		For other types an error is given.</pre>
<pre>		If you want to count the number of multi-byte characters use</pre>
<pre>		|strchars()|.</pre>
<pre>		Also see |len()|, |strdisplaywidth()| and |strwidth()|.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetString()->strlen()<p></pre>

strpart({src}, {start} [, {len}])			*strpart()*
<pre>		The result is a String, which is part of {src}, starting from</pre>
<pre>		byte {start}, with the byte length {len}.</pre>
<pre>		To count characters instead of bytes use |strcharpart()|.<p></pre>

<pre>		When bytes are selected which do not exist, this doesn't</pre>
<pre>		result in an error, the bytes are simply omitted.</pre>
<pre>		If {len} is missing, the copy continues from {start} till the</pre>
<pre>		end of the {src}. ></pre>
<pre>			strpart("abcdefg", 3, 2)    == "de"</pre>
<pre>			strpart("abcdefg", -2, 4)   == "ab"</pre>
<pre>			strpart("abcdefg", 5, 4)    == "fg"</pre>
<pre>			strpart("abcdefg", 3)	    == "defg"<p></pre>

<		Note: To get the first character, {start} must be 0.  For
<pre>		example, to get three bytes under and after the cursor: ></pre>
<pre>			strpart(getline("."), col(".") - 1, 3)</pre>
<
<pre>		Can also be used as a |method|: ></pre>
<pre>			GetText()->strpart(5)<p></pre>

strptime({format}, {timestring})				*strptime()*
<pre>		The result is a Number, which is a unix timestamp representing</pre>
<pre>		the date and time in {timestring}, which is expected to match</pre>
<pre>		the format specified in {format}.<p></pre>

<pre>		The accepted {format} depends on your system, thus this is not</pre>
<pre>		portable!  See the manual page of the C function strptime()</pre>
<pre>		for the format.  Especially avoid "%c".  The value of $TZ also</pre>
<pre>		matters.<p></pre>

<pre>		If the {timestring} cannot be parsed with {format} zero is</pre>
<pre>		returned.  If you do not know the format of {timestring} you</pre>
<pre>		can try different {format} values until you get a non-zero</pre>
<pre>		result.<p></pre>

<pre>		See also |strftime()|.</pre>
<pre>		Examples: ></pre>
<pre>		  :echo strptime("%Y %b %d %X", "1997 Apr 27 11:49:23")</pre>
<		  862156163 >
<pre>		  :echo strftime("%c", strptime("%y%m%d %T", "970427 11:53:55"))</pre>
<		  Sun Apr 27 11:53:55 1997 >
<pre>		  :echo strftime("%c", strptime("%Y%m%d%H%M%S", "19970427115355") + 3600)</pre>
<		  Sun Apr 27 12:53:55 1997<p>

<pre>		Not available on all systems.  To check use: ></pre>
<pre>			:if exists("*strptime")<p></pre>


strridx({haystack}, {needle} [, {start}])			*strridx()*
<pre>		The result is a Number, which gives the byte index in</pre>
<pre>		{haystack} of the last occurrence of the String {needle}.</pre>
<pre>		When {start} is specified, matches beyond this index are</pre>
<pre>		ignored.  This can be used to find a match before a previous</pre>
<pre>		match: ></pre>
<pre>			:let lastcomma = strridx(line, ",")</pre>
<pre>			:let comma2 = strridx(line, ",", lastcomma - 1)</pre>
<		The search is done case-sensitive.
<pre>		For pattern searches use |match()|.</pre>
<pre>		-1 is returned if the {needle} does not occur in {haystack}.</pre>
<pre>		If the {needle} is empty the length of {haystack} is returned.</pre>
<pre>		See also |stridx()|.  Examples: ></pre>
<pre>		  :echo strridx("an angry armadillo", "an")	     3</pre>
<							*strrchr()*
<pre>		When used with a single character it works similar to the C</pre>
<pre>		function strrchr().<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetHaystack()->strridx(needle)<p></pre>

strtrans({expr})					*strtrans()*
<pre>		The result is a String, which is {expr} with all unprintable</pre>
<pre>		characters translated into printable characters |'isprint'|.</pre>
<pre>		Like they are shown in a window.  Example: ></pre>
<pre>			echo strtrans(@a)</pre>
<		This displays a newline in register a as "^@" instead of
<pre>		starting a new line.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetString()->strtrans()<p></pre>

strwidth({expr})					*strwidth()*
<pre>		The result is a Number, which is the number of display cells</pre>
<pre>		String {expr} occupies.  A Tab character is counted as one</pre>
<pre>		cell, alternatively use |strdisplaywidth()|.</pre>
<pre>		When {expr} contains characters with East Asian Width Class</pre>
<pre>		Ambiguous, this function's return value depends on 'ambiwidth'.</pre>
<pre>		Also see |strlen()|, |strdisplaywidth()| and |strchars()|.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetString()->strwidth()<p></pre>

submatch({nr} [, {list}])			*submatch()* *E935*
<pre>		Only for an expression in a |:substitute| command or</pre>
<pre>		substitute() function.</pre>
<pre>		Returns the {nr}'th submatch of the matched text.  When {nr}</pre>
<pre>		is 0 the whole matched text is returned.</pre>
<pre>		Note that a NL in the string can stand for a line break of a</pre>
<pre>		multi-line match or a NUL character in the text.</pre>
<pre>		Also see |sub-replace-expression|.<p></pre>

<pre>		If {list} is present and non-zero then submatch() returns</pre>
<pre>		a list of strings, similar to |getline()| with two arguments.</pre>
<pre>		NL characters in the text represent NUL characters in the</pre>
<pre>		text.</pre>
<pre>		Only returns more than one item for |:substitute|, inside</pre>
<pre>		|substitute()| this list will always contain one or zero</pre>
<pre>		items, since there are no real line breaks.<p></pre>

<pre>		When substitute() is used recursively only the submatches in</pre>
<pre>		the current (deepest) call can be obtained.<p></pre>

<pre>		Examples: ></pre>
<pre>			:s/\d\+/\=submatch(0) + 1/</pre>
<pre>			:echo substitute(text, '\d\+', '\=submatch(0) + 1', '')</pre>
<		This finds the first number in the line and adds one to it.
<pre>		A line break is included as a newline character.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetNr()->submatch()<p></pre>

substitute({expr}, {pat}, {sub}, {flags})		*substitute()*
<pre>		The result is a String, which is a copy of {expr}, in which</pre>
<pre>		the first match of {pat} is replaced with {sub}.</pre>
<pre>		When {flags} is "g", all matches of {pat} in {expr} are</pre>
<pre>		replaced.  Otherwise {flags} should be "".<p></pre>

<pre>		This works like the ":substitute" command (without any flags).</pre>
<pre>		But the matching with {pat} is always done like the 'magic'</pre>
<pre>		option is set and 'cpoptions' is empty (to make scripts</pre>
<pre>		portable).  'ignorecase' is still relevant, use |/\c| or |/\C|</pre>
<pre>		if you want to ignore or match case and ignore 'ignorecase'.</pre>
<pre>		'smartcase' is not used.  See |string-match| for how {pat} is</pre>
<pre>		used.<p></pre>

<pre>		A "~" in {sub} is not replaced with the previous {sub}.</pre>
<pre>		Note that some codes in {sub} have a special meaning</pre>
<pre>		|sub-replace-special|.  For example, to replace something with</pre>
<pre>		"\n" (two characters), use "\\\\n" or '\\n'.<p></pre>

<pre>		When {pat} does not match in {expr}, {expr} is returned</pre>
<pre>		unmodified.<p></pre>

<pre>		Example: ></pre>
<pre>		   :let &path = substitute(&path, ",\\=[^,]*$", "", "")</pre>
<		This removes the last component of the 'path' option. >
<pre>		   :echo substitute("testing", ".*", "\\U\\0", "")</pre>
<		results in "TESTING".<p>

<pre>		When {sub} starts with "\=", the remainder is interpreted as</pre>
<pre>		an expression. See |sub-replace-expression|.  Example: ></pre>
<pre>		   :echo substitute(s, '%\(\x\x\)',</pre>
<pre>			   \ '\=nr2char("0x" . submatch(1))', 'g')<p></pre>

<		When {sub} is a Funcref that function is called, with one
<pre>		optional argument.  Example: ></pre>
<pre>		   :echo substitute(s, '%\(\x\x\)', SubNr, 'g')</pre>
<		The optional argument is a list which contains the whole
<pre>		matched string and up to nine submatches, like what</pre>
<pre>		|submatch()| returns.  Example: ></pre>
<pre>		   :echo substitute(s, '%\(\x\x\)', {m -> '0x' . m[1]}, 'g')<p></pre>

<		Can also be used as a |method|: >
<pre>			GetString()->substitute(pat, sub, flags)<p></pre>

swapinfo({fname})					*swapinfo()*
<pre>		The result is a dictionary, which holds information about the</pre>
<pre>		swapfile {fname}. The available fields are:</pre>
<pre>			version Vim version</pre>
<pre>			user	user name</pre>
<pre>			host	host name</pre>
<pre>			fname	original file name</pre>
<pre>			pid	PID of the Vim process that created the swap</pre>
<pre>				file</pre>
<pre>			mtime	last modification time in seconds</pre>
<pre>			inode	Optional: INODE number of the file</pre>
<pre>			dirty	1 if file was modified, 0 if not</pre>
<pre>		Note that "user" and "host" are truncated to at most 39 bytes.</pre>
<pre>		In case of failure an "error" item is added with the reason:</pre>
<pre>			Cannot open file: file not found or in accessible</pre>
<pre>			Cannot read file: cannot read first block</pre>
<pre>			Not a swap file: does not contain correct block ID</pre>
<pre>			Magic number mismatch: Info in first block is invalid<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetFilename()->swapinfo()<p></pre>

swapname({expr})					*swapname()*
<pre>		The result is the swap file path of the buffer {expr}.</pre>
<pre>		For the use of {expr}, see |bufname()| above.</pre>
<pre>		If buffer {expr} is the current buffer, the result is equal to</pre>
<pre>		|:swapname| (unless no swap file).</pre>
<pre>		If buffer {expr} has no swap file, returns an empty string.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetBufname()->swapname()<p></pre>

synID({lnum}, {col}, {trans})				*synID()*
<pre>		The result is a Number, which is the syntax ID at the position</pre>
<pre>		{lnum} and {col} in the current window.</pre>
<pre>		The syntax ID can be used with |synIDattr()| and</pre>
<pre>		|synIDtrans()| to obtain syntax information about text.<p></pre>

<pre>		{col} is 1 for the leftmost column, {lnum} is 1 for the first</pre>
<pre>		line.  'synmaxcol' applies, in a longer line zero is returned.</pre>
<pre>		Note that when the position is after the last character,</pre>
<pre>		that's where the cursor can be in Insert mode, synID() returns</pre>
<pre>		zero.<p></pre>

<pre>		When {trans} is |TRUE|, transparent items are reduced to the</pre>
<pre>		item that they reveal.  This is useful when wanting to know</pre>
<pre>		the effective color.  When {trans} is |FALSE|, the transparent</pre>
<pre>		item is returned.  This is useful when wanting to know which</pre>
<pre>		syntax item is effective (e.g. inside parens).</pre>
<pre>		Warning: This function can be very slow.  Best speed is</pre>
<pre>		obtained by going through the file in forward direction.<p></pre>

<pre>		Example (echoes the name of the syntax item under the cursor): ></pre>
<pre>			:echo synIDattr(synID(line("."), col("."), 1), "name")</pre>
<<p>

synIDattr({synID}, {what} [, {mode}])			*synIDattr()*
<pre>		The result is a String, which is the {what} attribute of</pre>
<pre>		syntax ID {synID}.  This can be used to obtain information</pre>
<pre>		about a syntax item.</pre>
<pre>		{mode} can be "gui", "cterm" or "term", to get the attributes</pre>
<pre>		for that mode.  When {mode} is omitted, or an invalid value is</pre>
<pre>		used, the attributes for the currently active highlighting are</pre>
<pre>		used (GUI, cterm or term).</pre>
<pre>		Use synIDtrans() to follow linked highlight groups.</pre>
<pre>		{what}		result</pre>
<pre>		"name"		the name of the syntax item</pre>
<pre>		"fg"		foreground color (GUI: color name used to set</pre>
<pre>				the color, cterm: color number as a string,</pre>
<pre>				term: empty string)</pre>
<pre>		"bg"		background color (as with "fg")</pre>
<pre>		"font"		font name (only available in the GUI)</pre>
<pre>				|highlight-font|</pre>
<pre>		"sp"		special color (as with "fg") |highlight-guisp|</pre>
<pre>		"fg#"		like "fg", but for the GUI and the GUI is</pre>
<pre>				running the name in "#RRGGBB" form</pre>
<pre>		"bg#"		like "fg#" for "bg"</pre>
<pre>		"sp#"		like "fg#" for "sp"</pre>
<pre>		"bold"		"1" if bold</pre>
<pre>		"italic"	"1" if italic</pre>
<pre>		"reverse"	"1" if reverse</pre>
<pre>		"inverse"	"1" if inverse (= reverse)</pre>
<pre>		"standout"	"1" if standout</pre>
<pre>		"underline"	"1" if underlined</pre>
<pre>		"undercurl"	"1" if undercurled</pre>
<pre>		"strike"	"1" if strikethrough<p></pre>

<pre>		Example (echoes the color of the syntax item under the</pre>
<pre>		cursor): ></pre>
<pre>	:echo synIDattr(synIDtrans(synID(line("."), col("."), 1)), "fg")</pre>
<
<pre>		Can also be used as a |method|: ></pre>
<pre>	:echo synID(line("."), col("."), 1)->synIDtrans()->synIDattr("fg")<p></pre>


synIDtrans({synID})					*synIDtrans()*
<pre>		The result is a Number, which is the translated syntax ID of</pre>
<pre>		{synID}.  This is the syntax group ID of what is being used to</pre>
<pre>		highlight the character.  Highlight links given with</pre>
<pre>		":highlight link" are followed.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>	:echo synID(line("."), col("."), 1)->synIDtrans()->synIDattr("fg")<p></pre>

synconcealed({lnum}, {col})				*synconcealed()*
<pre>		The result is a List with currently three items:</pre>
<pre>		1. The first item in the list is 0 if the character at the</pre>
<pre>		   position {lnum} and {col} is not part of a concealable</pre>
<pre>		   region, 1 if it is.</pre>
<pre>		2. The second item in the list is a string. If the first item</pre>
<pre>		   is 1, the second item contains the text which will be</pre>
<pre>		   displayed in place of the concealed text, depending on the</pre>
<pre>		   current setting of 'conceallevel' and 'listchars'.</pre>
<pre>		3. The third and final item in the list is a number</pre>
<pre>		   representing the specific syntax region matched in the</pre>
<pre>		   line. When the character is not concealed the value is</pre>
<pre>		   zero. This allows detection of the beginning of a new</pre>
<pre>		   concealable region if there are two consecutive regions</pre>
<pre>		   with the same replacement character.  For an example, if</pre>
<pre>		   the text is "123456" and both "23" and "45" are concealed</pre>
<pre>		   and replaced by the character "X", then:</pre>
<pre>			call			returns ~</pre>
<pre>			synconcealed(lnum, 1)   [0, '', 0]</pre>
<pre>			synconcealed(lnum, 2)   [1, 'X', 1]</pre>
<pre>			synconcealed(lnum, 3)   [1, 'X', 1]</pre>
<pre>			synconcealed(lnum, 4)   [1, 'X', 2]</pre>
<pre>			synconcealed(lnum, 5)   [1, 'X', 2]</pre>
<pre>			synconcealed(lnum, 6)   [0, '', 0]<p></pre>


synstack({lnum}, {col})					*synstack()*
<pre>		Return a |List|, which is the stack of syntax items at the</pre>
<pre>		position {lnum} and {col} in the current window.  Each item in</pre>
<pre>		the List is an ID like what |synID()| returns.</pre>
<pre>		The first item in the List is the outer region, following are</pre>
<pre>		items contained in that one.  The last one is what |synID()|</pre>
<pre>		returns, unless not the whole item is highlighted or it is a</pre>
<pre>		transparent item.</pre>
<pre>		This function is useful for debugging a syntax file.</pre>
<pre>		Example that shows the syntax stack under the cursor: ></pre>
<pre>			for id in synstack(line("."), col("."))</pre>
<pre>			   echo synIDattr(id, "name")</pre>
<pre>			endfor</pre>
<		When the position specified with {lnum} and {col} is invalid
<pre>		nothing is returned.  The position just after the last</pre>
<pre>		character in a line and the first column in an empty line are</pre>
<pre>		valid positions.<p></pre>

system({expr} [, {input}])				*system()* *E677*
<pre>		Get the output of the shell command {expr} as a string.  See</pre>
<pre>		|systemlist()| to get the output as a List.<p></pre>

<pre>		When {input} is given and is a string this string is written</pre>
<pre>		to a file and passed as stdin to the command.  The string is</pre>
<pre>		written as-is, you need to take care of using the correct line</pre>
<pre>		separators yourself.</pre>
<pre>		If {input} is given and is a |List| it is written to the file</pre>
<pre>		in a way |writefile()| does with {binary} set to "b" (i.e.</pre>
<pre>		with a newline between each list item with newlines inside</pre>
<pre>		list items converted to NULs).</pre>
<pre>		When {input} is given and is a number that is a valid id for</pre>
<pre>		an existing buffer then the content of the buffer is written</pre>
<pre>		to the file line by line, each line terminated by a NL and</pre>
<pre>		NULs characters where the text has a NL.<p></pre>

<pre>		Pipes are not used, the 'shelltemp' option is not used.<p></pre>

<pre>		When prepended by |:silent| the terminal will not be set to</pre>
<pre>		cooked mode.  This is meant to be used for commands that do</pre>
<pre>		not need the user to type.  It avoids stray characters showing</pre>
<pre>		up on the screen which require |CTRL-L| to remove. ></pre>
<pre>			:silent let f = system('ls *.vim')</pre>
<
<pre>		Note: Use |shellescape()| or |::S| with |expand()| or</pre>
<pre>		|fnamemodify()| to escape special characters in a command</pre>
<pre>		argument.  Newlines in {expr} may cause the command to fail.</pre>
<pre>		The characters in 'shellquote' and 'shellxquote' may also</pre>
<pre>		cause trouble.</pre>
<pre>		This is not to be used for interactive commands.<p></pre>

<pre>		The result is a String.  Example: ></pre>
<pre>		    :let files = system("ls " .  shellescape(expand('%:h')))</pre>
<pre>		    :let files = system('ls ' . expand('%:h:S'))<p></pre>

<		To make the result more system-independent, the shell output
<pre>		is filtered to replace <CR> with <NL> for Macintosh, and</pre>
<pre>		<CR><NL> with <NL> for DOS-like systems.</pre>
<pre>		To avoid the string being truncated at a NUL, all NUL</pre>
<pre>		characters are replaced with SOH (0x01).<p></pre>

<pre>		The command executed is constructed using several options:</pre>
<pre>	'shell' 'shellcmdflag' 'shellxquote' {expr} 'shellredir' {tmp} 'shellxquote'</pre>
<pre>		({tmp} is an automatically generated file name).</pre>
<pre>		For Unix and OS/2 braces are put around {expr} to allow for</pre>
<pre>		concatenated commands.<p></pre>

<pre>		The command will be executed in "cooked" mode, so that a</pre>
<pre>		CTRL-C will interrupt the command (on Unix at least).<p></pre>

<pre>		The resulting error code can be found in |v:shell_error|.</pre>
<pre>		This function will fail in |restricted-mode|.<p></pre>

<pre>		Note that any wrong value in the options mentioned above may</pre>
<pre>		make the function fail.  It has also been reported to fail</pre>
<pre>		when using a security agent application.</pre>
<pre>		Unlike ":!cmd" there is no automatic check for changed files.</pre>
<pre>		Use |:checktime| to force a check.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			:echo GetCmd()->system()<p></pre>


systemlist({expr} [, {input}])				*systemlist()*
<pre>		Same as |system()|, but returns a |List| with lines (parts of</pre>
<pre>		output separated by NL) with NULs transformed into NLs. Output</pre>
<pre>		is the same as |readfile()| will output with {binary} argument</pre>
<pre>		set to "b", except that there is no extra empty item when the</pre>
<pre>		result ends in a NL.</pre>
<pre>		Note that on MS-Windows you may get trailing CR characters.<p></pre>

<pre>		To see the difference between "echo hello" and "echo -n hello"</pre>
<pre>		use |system()| and |split()|: ></pre>
<pre>			echo system('echo hello')->split('\n', 1)</pre>
<
<pre>		Returns an empty string on error.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			:echo GetCmd()->systemlist()<p></pre>


tabpagebuflist([{arg}])					*tabpagebuflist()*
<pre>		The result is a |List|, where each item is the number of the</pre>
<pre>		buffer associated with each window in the current tab page.</pre>
<pre>		{arg} specifies the number of the tab page to be used. When</pre>
<pre>		omitted the current tab page is used.</pre>
<pre>		When {arg} is invalid the number zero is returned.</pre>
<pre>		To get a list of all buffers in all tabs use this: ></pre>
<pre>			let buflist = []</pre>
<pre>			for i in range(tabpagenr('$'))</pre>
<pre>			   call extend(buflist, tabpagebuflist(i + 1))</pre>
<pre>			endfor</pre>
<		Note that a buffer may appear in more than one window.<p>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetTabpage()->tabpagebuflist()<p></pre>

tabpagenr([{arg}])					*tabpagenr()*
<pre>		The result is a Number, which is the number of the current</pre>
<pre>		tab page.  The first tab page has number 1.</pre>
<pre>		When the optional argument is "$", the number of the last tab</pre>
<pre>		page is returned (the tab page count).</pre>
<pre>		The number can be used with the |:tab| command.<p></pre>


tabpagewinnr({tabarg} [, {arg}])			*tabpagewinnr()*
<pre>		Like |winnr()| but for tab page {tabarg}.</pre>
<pre>		{tabarg} specifies the number of tab page to be used.</pre>
<pre>		{arg} is used like with |winnr()|:</pre>
<pre>		- When omitted the current window number is returned.  This is</pre>
<pre>		  the window which will be used when going to this tab page.</pre>
<pre>		- When "$" the number of windows is returned.</pre>
<pre>		- When "#" the previous window nr is returned.</pre>
<pre>		Useful examples: ></pre>
<pre>		    tabpagewinnr(1)	    " current window of tab page 1</pre>
<pre>		    tabpagewinnr(4, '$')    " number of windows in tab page 4</pre>
<		When {tabarg} is invalid zero is returned.<p>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetTabpage()->tabpagewinnr()</pre>
<
<pre>							*tagfiles()*</pre>
tagfiles()	Returns a |List| with the file names used to search for tags
<pre>		for the current buffer.  This is the 'tags' option expanded.<p></pre>


taglist({expr} [, {filename}])				*taglist()*
<pre>		Returns a list of tags matching the regular expression {expr}.<p></pre>

<pre>		If {filename} is passed it is used to prioritize the results</pre>
<pre>		in the same way that |:tselect| does. See |tag-priority|.</pre>
<pre>		{filename} should be the full path of the file.<p></pre>

<pre>		Each list item is a dictionary with at least the following</pre>
<pre>		entries:</pre>
<pre>			name		Name of the tag.</pre>
<pre>			filename	Name of the file where the tag is</pre>
<pre>					defined.  It is either relative to the</pre>
<pre>					current directory or a full path.</pre>
<pre>			cmd		Ex command used to locate the tag in</pre>
<pre>					the file.</pre>
<pre>			kind		Type of the tag.  The value for this</pre>
<pre>					entry depends on the language specific</pre>
<pre>					kind values.  Only available when</pre>
<pre>					using a tags file generated by</pre>
<pre>					Exuberant ctags or hdrtag.</pre>
<pre>			static		A file specific tag.  Refer to</pre>
<pre>					|static-tag| for more information.</pre>
<pre>		More entries may be present, depending on the content of the</pre>
<pre>		tags file: access, implementation, inherits and signature.</pre>
<pre>		Refer to the ctags documentation for information about these</pre>
<pre>		fields.  For C code the fields "struct", "class" and "enum"</pre>
<pre>		may appear, they give the name of the entity the tag is</pre>
<pre>		contained in.<p></pre>

<pre>		The ex-command "cmd" can be either an ex search pattern, a</pre>
<pre>		line number or a line number followed by a byte number.<p></pre>

<pre>		If there are no matching tags, then an empty list is returned.<p></pre>

<pre>		To get an exact tag match, the anchors '^' and '$' should be</pre>
<pre>		used in {expr}.  This also make the function work faster.</pre>
<pre>		Refer to |tag-regexp| for more information about the tag</pre>
<pre>		search regular expression pattern.<p></pre>

<pre>		Refer to |'tags'| for information about how the tags file is</pre>
<pre>		located by Vim. Refer to |tags-file-format| for the format of</pre>
<pre>		the tags file generated by the different ctags tools.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetTagpattern()->taglist()<p></pre>

tan({expr})						*tan()*
<pre>		Return the tangent of {expr}, measured in radians, as a |Float|</pre>
<pre>		in the range [-inf, inf].</pre>
<pre>		{expr} must evaluate to a |Float| or a |Number|.</pre>
<pre>		Examples: ></pre>
<pre>			:echo tan(10)</pre>
<			0.648361 >
<pre>			:echo tan(-4.01)</pre>
<			-1.181502<p>

<pre>		Can also be used as a |method|: ></pre>
<pre>			Compute()->tan()</pre>
<
<pre>		{only available when compiled with the |+float| feature}<p></pre>


tanh({expr})						*tanh()*
<pre>		Return the hyperbolic tangent of {expr} as a |Float| in the</pre>
<pre>		range [-1, 1].</pre>
<pre>		{expr} must evaluate to a |Float| or a |Number|.</pre>
<pre>		Examples: ></pre>
<pre>			:echo tanh(0.5)</pre>
<			0.462117 >
<pre>			:echo tanh(-1)</pre>
<			-0.761594<p>

<pre>		Can also be used as a |method|: ></pre>
<pre>			Compute()->tanh()</pre>
<
<pre>		{only available when compiled with the |+float| feature}<p></pre>


tempname()					*tempname()* *temp-file-name*
<pre>		The result is a String, which is the name of a file that</pre>
<pre>		doesn't exist.  It can be used for a temporary file.  The name</pre>
<pre>		is different for at least 26 consecutive calls.  Example: ></pre>
<pre>			:let tmpfile = tempname()</pre>
<pre>			:exe "redir > " . tmpfile</pre>
<		For Unix, the file will be in a private directory |tempfile|.
<pre>		For MS-Windows forward slashes are used when the 'shellslash'</pre>
<pre>		option is set or when 'shellcmdflag' starts with '-'.<p></pre>


term_ functions are documented here: |terminal-function-details|<p>

test_ functions are documented here: |test-functions-details|<p>


<pre>							*timer_info()*</pre>
timer_info([{id}])
<pre>		Return a list with information about timers.</pre>
<pre>		When {id} is given only information about this timer is</pre>
<pre>		returned.  When timer {id} does not exist an empty list is</pre>
<pre>		returned.</pre>
<pre>		When {id} is omitted information about all timers is returned.<p></pre>

<pre>		For each timer the information is stored in a Dictionary with</pre>
<pre>		these items:</pre>
<pre>		    "id"	    the timer ID</pre>
<pre>		    "time"	    time the timer was started with</pre>
<pre>		    "remaining"	    time until the timer fires</pre>
<pre>		    "repeat"	    number of times the timer will still fire;</pre>
<pre>				    -1 means forever</pre>
<pre>		    "callback"	    the callback</pre>
<pre>		    "paused"	    1 if the timer is paused, 0 otherwise<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetTimer()->timer_info()<p></pre>

<		{only available when compiled with the |+timers| feature}<p>

timer_pause({timer}, {paused})				*timer_pause()*
<pre>		Pause or unpause a timer.  A paused timer does not invoke its</pre>
<pre>		callback when its time expires.  Unpausing a timer may cause</pre>
<pre>		the callback to be invoked almost immediately if enough time</pre>
<pre>		has passed.<p></pre>

<pre>		Pausing a timer is useful to avoid the callback to be called</pre>
<pre>		for a short time.<p></pre>

<pre>		If {paused} evaluates to a non-zero Number or a non-empty</pre>
<pre>		String, then the timer is paused, otherwise it is unpaused.</pre>
<pre>		See |non-zero-arg|.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetTimer()->timer_pause(1)<p></pre>

<		{only available when compiled with the |+timers| feature}<p>

<pre>						*timer_start()* *timer* *timers*</pre>
timer_start({time}, {callback} [, {options}])
<pre>		Create a timer and return the timer ID.<p></pre>

<pre>		{time} is the waiting time in milliseconds. This is the</pre>
<pre>		minimum time before invoking the callback.  When the system is</pre>
<pre>		busy or Vim is not waiting for input the time will be longer.<p></pre>

<pre>		{callback} is the function to call.  It can be the name of a</pre>
<pre>		function or a |Funcref|.  It is called with one argument, which</pre>
<pre>		is the timer ID.  The callback is only invoked when Vim is</pre>
<pre>		waiting for input.<p></pre>

<pre>		{options} is a dictionary.  Supported entries:</pre>
<pre>		   "repeat"	Number of times to repeat calling the</pre>
<pre>				callback.  -1 means forever.  When not present</pre>
<pre>				the callback will be called once.</pre>
<pre>				If the timer causes an error three times in a</pre>
<pre>				row the repeat is cancelled.  This avoids that</pre>
<pre>				Vim becomes unusable because of all the error</pre>
<pre>				messages.<p></pre>

<pre>		Example: ></pre>
<pre>			func MyHandler(timer)</pre>
<pre>			  echo 'Handler called'</pre>
<pre>			endfunc</pre>
<pre>			let timer = timer_start(500, 'MyHandler',</pre>
<pre>				\ {'repeat': 3})</pre>
<		This will invoke MyHandler() three times at 500 msec
<pre>		intervals.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetMsec()->timer_start(callback)<p></pre>

<		Not available in the |sandbox|.
<pre>		{only available when compiled with the |+timers| feature}<p></pre>

timer_stop({timer})					*timer_stop()*
<pre>		Stop a timer.  The timer callback will no longer be invoked.</pre>
<pre>		{timer} is an ID returned by timer_start(), thus it must be a</pre>
<pre>		Number.  If {timer} does not exist there is no error.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetTimer()->timer_stop()<p></pre>

<		{only available when compiled with the |+timers| feature}<p>

timer_stopall()						*timer_stopall()*
<pre>		Stop all timers.  The timer callbacks will no longer be</pre>
<pre>		invoked.  Useful if a timer is misbehaving.  If there are no</pre>
<pre>		timers there is no error.<p></pre>

<pre>		{only available when compiled with the |+timers| feature}<p></pre>

tolower({expr})						*tolower()*
<pre>		The result is a copy of the String given, with all uppercase</pre>
<pre>		characters turned into lowercase (just like applying |gu| to</pre>
<pre>		the string).<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetText()->tolower()<p></pre>

toupper({expr})						*toupper()*
<pre>		The result is a copy of the String given, with all lowercase</pre>
<pre>		characters turned into uppercase (just like applying |gU| to</pre>
<pre>		the string).<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetText()->toupper()<p></pre>

tr({src}, {fromstr}, {tostr})				*tr()*
<pre>		The result is a copy of the {src} string with all characters</pre>
<pre>		which appear in {fromstr} replaced by the character in that</pre>
<pre>		position in the {tostr} string.  Thus the first character in</pre>
<pre>		{fromstr} is translated into the first character in {tostr}</pre>
<pre>		and so on.  Exactly like the unix "tr" command.</pre>
<pre>		This code also deals with multibyte characters properly.<p></pre>

<pre>		Examples: ></pre>
<pre>			echo tr("hello there", "ht", "HT")</pre>
<		returns "Hello THere" >
<pre>			echo tr("<blob>", "<>", "{}")</pre>
<		returns "{blob}"<p>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetText()->tr(from, to)<p></pre>

trim({text} [, {mask}])						*trim()*
<pre>		Return {text} as a String where any character in {mask} is</pre>
<pre>		removed from the beginning and  end of {text}.</pre>
<pre>		If {mask} is not given, {mask} is all characters up to 0x20,</pre>
<pre>		which includes Tab, space, NL and CR, plus the non-breaking</pre>
<pre>		space character 0xa0.</pre>
<pre>		This code deals with multibyte characters properly.<p></pre>

<pre>		Examples: ></pre>
<pre>			echo trim("   some text ")</pre>
<		returns "some text" >
<pre>			echo trim("  \r\t\t\r RESERVE \t\n\x0B\xA0") . "_TAIL"</pre>
<		returns "RESERVE_TAIL" >
<pre>			echo trim("rm<Xrm<>X>rrm", "rm<>")</pre>
<		returns "Xrm<>X" (characters in the middle are not removed)<p>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetText()->trim()<p></pre>

trunc({expr})							*trunc()*
<pre>		Return the largest integral value with magnitude less than or</pre>
<pre>		equal to {expr} as a |Float| (truncate towards zero).</pre>
<pre>		{expr} must evaluate to a |Float| or a |Number|.</pre>
<pre>		Examples: ></pre>
<pre>			echo trunc(1.456)</pre>
<			1.0  >
<pre>			echo trunc(-5.456)</pre>
<			-5.0  >
<pre>			echo trunc(4.0)</pre>
<			4.0<p>

<pre>		Can also be used as a |method|: ></pre>
<pre>			Compute()->trunc()</pre>
<
<pre>		{only available when compiled with the |+float| feature}<p></pre>

<pre>							*type()*</pre>
type({expr})	The result is a Number representing the type of {expr}.
<pre>		Instead of using the number directly, it is better to use the</pre>
<pre>		v:t_ variable that has the value:</pre>
<pre>			Number:	    0  |v:t_number|</pre>
<pre>			String:	    1  |v:t_string|</pre>
<pre>			Funcref:    2  |v:t_func|</pre>
<pre>			List:	    3  |v:t_list|</pre>
<pre>			Dictionary: 4  |v:t_dict|</pre>
<pre>			Float:	    5  |v:t_float|</pre>
<pre>			Boolean:    6  |v:t_bool| (v:false and v:true)</pre>
<pre>			None:	    7  |v:t_none| (v:null and v:none)</pre>
<pre>			Job:	    8  |v:t_job|</pre>
<pre>			Channel:    9  |v:t_channel|</pre>
<pre>			Blob:	   10  |v:t_blob|</pre>
<pre>		For backward compatibility, this method can be used: ></pre>
<pre>			:if type(myvar) == type(0)</pre>
<pre>			:if type(myvar) == type("")</pre>
<pre>			:if type(myvar) == type(function("tr"))</pre>
<pre>			:if type(myvar) == type([])</pre>
<pre>			:if type(myvar) == type({})</pre>
<pre>			:if type(myvar) == type(0.0)</pre>
<pre>			:if type(myvar) == type(v:false)</pre>
<pre>			:if type(myvar) == type(v:none)</pre>
<		To check if the v:t_ variables exist use this: >
<pre>			:if exists('v:t_number')<p></pre>

<		Can also be used as a |method|: >
<pre>			mylist->type()<p></pre>

undofile({name})					*undofile()*
<pre>		Return the name of the undo file that would be used for a file</pre>
<pre>		with name {name} when writing.  This uses the 'undodir'</pre>
<pre>		option, finding directories that exist.  It does not check if</pre>
<pre>		the undo file exists.</pre>
<pre>		{name} is always expanded to the full path, since that is what</pre>
<pre>		is used internally.</pre>
<pre>		If {name} is empty undofile() returns an empty string, since a</pre>
<pre>		buffer without a file name will not write an undo file.</pre>
<pre>		Useful in combination with |:wundo| and |:rundo|.</pre>
<pre>		When compiled without the |+persistent_undo| option this always</pre>
<pre>		returns an empty string.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetFilename()->undofile()<p></pre>

undotree()						*undotree()*
<pre>		Return the current state of the undo tree in a dictionary with</pre>
<pre>		the following items:</pre>
<pre>		  "seq_last"	The highest undo sequence number used.</pre>
<pre>		  "seq_cur"	The sequence number of the current position in</pre>
<pre>				the undo tree.  This differs from "seq_last"</pre>
<pre>				when some changes were undone.</pre>
<pre>		  "time_cur"	Time last used for |:earlier| and related</pre>
<pre>				commands.  Use |strftime()| to convert to</pre>
<pre>				something readable.</pre>
<pre>		  "save_last"	Number of the last file write.  Zero when no</pre>
<pre>				write yet.</pre>
<pre>		  "save_cur"	Number of the current position in the undo</pre>
<pre>				tree.</pre>
<pre>		  "synced"	Non-zero when the last undo block was synced.</pre>
<pre>				This happens when waiting from input from the</pre>
<pre>				user.  See |undo-blocks|.</pre>
<pre>		  "entries"	A list of dictionaries with information about</pre>
<pre>				undo blocks.<p></pre>

<pre>		The first item in the "entries" list is the oldest undo item.</pre>
<pre>		Each List item is a Dictionary with these items:</pre>
<pre>		  "seq"		Undo sequence number.  Same as what appears in</pre>
<pre>				|:undolist|.</pre>
<pre>		  "time"	Timestamp when the change happened.  Use</pre>
<pre>				|strftime()| to convert to something readable.</pre>
<pre>		  "newhead"	Only appears in the item that is the last one</pre>
<pre>				that was added.  This marks the last change</pre>
<pre>				and where further changes will be added.</pre>
<pre>		  "curhead"	Only appears in the item that is the last one</pre>
<pre>				that was undone.  This marks the current</pre>
<pre>				position in the undo tree, the block that will</pre>
<pre>				be used by a redo command.  When nothing was</pre>
<pre>				undone after the last change this item will</pre>
<pre>				not appear anywhere.</pre>
<pre>		  "save"	Only appears on the last block before a file</pre>
<pre>				write.  The number is the write count.  The</pre>
<pre>				first write has number 1, the last one the</pre>
<pre>				"save_last" mentioned above.</pre>
<pre>		  "alt"		Alternate entry.  This is again a List of undo</pre>
<pre>				blocks.  Each item may again have an "alt"</pre>
<pre>				item.<p></pre>

uniq({list} [, {func} [, {dict}]])			*uniq()* *E882*
<pre>		Remove second and succeeding copies of repeated adjacent</pre>
<pre>		{list} items in-place.  Returns {list}.  If you want a list</pre>
<pre>		to remain unmodified make a copy first: ></pre>
<pre>			:let newlist = uniq(copy(mylist))</pre>
<		The default compare function uses the string representation of
<pre>		each item.  For the use of {func} and {dict} see |sort()|.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			mylist->uniq()<p></pre>

values({dict})						*values()*
<pre>		Return a |List| with all the values of {dict}.  The |List| is</pre>
<pre>		in arbitrary order.  Also see |items()| and |keys()|.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			mydict->values()<p></pre>

virtcol({expr})						*virtcol()*
<pre>		The result is a Number, which is the screen column of the file</pre>
<pre>		position given with {expr}.  That is, the last screen position</pre>
<pre>		occupied by the character at that position, when the screen</pre>
<pre>		would be of unlimited width.  When there is a <Tab> at the</pre>
<pre>		position, the returned Number will be the column at the end of</pre>
<pre>		the <Tab>.  For example, for a <Tab> in column 1, with 'ts'</pre>
<pre>		set to 8, it returns 8. |conceal| is ignored.</pre>
<pre>		For the byte position use |col()|.</pre>
<pre>		For the use of {expr} see |col()|.</pre>
<pre>		When 'virtualedit' is used {expr} can be [lnum, col, off], where</pre>
<pre>		"off" is the offset in screen columns from the start of the</pre>
<pre>		character.  E.g., a position within a <Tab> or after the last</pre>
<pre>		character.  When "off" is omitted zero is used.</pre>
<pre>		When Virtual editing is active in the current mode, a position</pre>
<pre>		beyond the end of the line can be returned. |'virtualedit'|</pre>
<pre>		The accepted positions are:</pre>
<pre>		    .	    the cursor position</pre>
<pre>		    $	    the end of the cursor line (the result is the</pre>
<pre>			    number of displayed characters in the cursor line</pre>
<pre>			    plus one)</pre>
<pre>		    'x	    position of mark x (if the mark is not set, 0 is</pre>
<pre>			    returned)</pre>
<pre>		    v       In Visual mode: the start of the Visual area (the</pre>
<pre>			    cursor is the end).  When not in Visual mode</pre>
<pre>			    returns the cursor position.  Differs from |'<| in</pre>
<pre>			    that it's updated right away.</pre>
<pre>		Note that only marks in the current file can be used.</pre>
<pre>		Examples: ></pre>
<pre>  virtcol(".")	   with text "foo^Lbar", with cursor on the "^L", returns 5</pre>
<pre>  virtcol("$")	   with text "foo^Lbar", returns 9</pre>
<pre>  virtcol("'t")    with text "	  there", with 't at 'h', returns 6</pre>
<		The first column is 1.  0 is returned for an error.
<pre>		A more advanced example that echoes the maximum length of</pre>
<pre>		all lines: ></pre>
<pre>		    echo max(map(range(1, line('$')), "virtcol([v:val, '$'])"))<p></pre>

<		Can also be used as a |method|: >
<pre>			GetPos()->virtcol()<p></pre>


visualmode([{expr}])						*visualmode()*
<pre>		The result is a String, which describes the last Visual mode</pre>
<pre>		used in the current buffer.  Initially it returns an empty</pre>
<pre>		string, but once Visual mode has been used, it returns "v",</pre>
<pre>		"V", or "<CTRL-V>" (a single CTRL-V character) for</pre>
<pre>		character-wise, line-wise, or block-wise Visual mode</pre>
<pre>		respectively.</pre>
<pre>		Example: ></pre>
<pre>			:exe "normal " . visualmode()</pre>
<		This enters the same Visual mode as before.  It is also useful
<pre>		in scripts if you wish to act differently depending on the</pre>
<pre>		Visual mode that was used.</pre>
<pre>		If Visual mode is active, use |mode()| to get the Visual mode</pre>
<pre>		(e.g., in a |:vmap|).</pre>
<pre>		If {expr} is supplied and it evaluates to a non-zero Number or</pre>
<pre>		a non-empty String, then the Visual mode will be cleared and</pre>
<pre>		the old value is returned.  See |non-zero-arg|.<p></pre>

wildmenumode()					*wildmenumode()*
<pre>		Returns |TRUE| when the wildmenu is active and |FALSE|</pre>
<pre>		otherwise.  See 'wildmenu' and 'wildmode'.</pre>
<pre>		This can be used in mappings to handle the 'wildcharm' option</pre>
<pre>		gracefully. (Makes only sense with |mapmode-c| mappings).<p></pre>

<pre>		For example to make <c-j> work like <down> in wildmode, use: ></pre>
<pre>    :cnoremap <expr> <C-j> wildmenumode() ? "\<Down>\<Tab>" : "\<c-j>"</pre>
<
<pre>		(Note, this needs the 'wildcharm' option set appropriately).<p></pre>

win_execute({id}, {command} [, {silent}])		*win_execute()*
<pre>		Like `execute()` but in the context of window {id}.</pre>
<pre>		The window will temporarily be made the current window,</pre>
<pre>		without triggering autocommands.  When executing {command}</pre>
<pre>		autocommands will be triggered, this may have unexpected side</pre>
<pre>		effects.  Use |:noautocmd| if needed.</pre>
<pre>		Example: ></pre>
<pre>			call win_execute(winid, 'set syntax=python')</pre>
<		Doing the same with `setwinvar()` would not trigger
<pre>		autocommands and not actually show syntax highlighting.</pre>
<pre>							*E994*</pre>
<pre>		Not all commands are allowed in popup windows.</pre>
<pre>		When window {id} does not exist then no error is given.<p></pre>

<pre>		Can also be used as a |method|, the base is passed as the</pre>
<pre>		second argument: ></pre>
<pre>			GetCommand()->win_execute(winid)<p></pre>

win_findbuf({bufnr})					*win_findbuf()*
<pre>		Returns a list with |window-ID|s for windows that contain</pre>
<pre>		buffer {bufnr}.  When there is none the list is empty.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetBufnr()->win_findbuf()<p></pre>

win_getid([{win} [, {tab}]])				*win_getid()*
<pre>		Get the |window-ID| for the specified window.</pre>
<pre>		When {win} is missing use the current window.</pre>
<pre>		With {win} this is the window number.  The top window has</pre>
<pre>		number 1.</pre>
<pre>		Without {tab} use the current tab, otherwise the tab with</pre>
<pre>		number {tab}.  The first tab has number one.</pre>
<pre>		Return zero if the window cannot be found.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetWinnr()->win_getid()<p></pre>

win_gotoid({expr})					*win_gotoid()*
<pre>		Go to window with ID {expr}.  This may also change the current</pre>
<pre>		tabpage.</pre>
<pre>		Return 1 if successful, 0 if the window cannot be found.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetWinid()->win_gotoid()<p></pre>

win_id2tabwin({expr})					*win_id2tabwin()*
<pre>		Return a list with the tab number and window number of window</pre>
<pre>		with ID {expr}: [tabnr, winnr].</pre>
<pre>		Return [0, 0] if the window cannot be found.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetWinid()->win_id2tabwin()<p></pre>

win_id2win({expr})					*win_id2win()*
<pre>		Return the window number of window with ID {expr}.</pre>
<pre>		Return 0 if the window cannot be found in the current tabpage.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetWinid()->win_id2win()<p></pre>

win_screenpos({nr})					*win_screenpos()*
<pre>		Return the screen position of window {nr} as a list with two</pre>
<pre>		numbers: [row, col].  The first window always has position</pre>
<pre>		[1, 1], unless there is a tabline, then it is [2, 1].</pre>
<pre>		{nr} can be the window number or the |window-ID|.</pre>
<pre>		Return [0, 0] if the window cannot be found in the current</pre>
<pre>		tabpage.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetWinid()->win_screenpos()</pre>
<
win_splitmove({nr}, {target} [, {options}])		*win_splitmove()*
<pre>	        Move the window {nr} to a new split of the window {target}.</pre>
<pre>		This is similar to moving to {target}, creating a new window</pre>
<pre>		using |:split| but having the same contents as window {nr}, and</pre>
<pre>		then closing {nr}.<p></pre>

<pre>		Both {nr} and {target} can be window numbers or |window-ID|s.<p></pre>

<pre>		Returns zero for success, non-zero for failure.<p></pre>

<pre>		{options} is a Dictionary with the following optional entries:</pre>
<pre>		  "vertical"	When TRUE, the split is created vertically,</pre>
<pre>				like with |:vsplit|.</pre>
<pre>		  "rightbelow"	When TRUE, the split is made below or to the</pre>
<pre>				right (if vertical).  When FALSE, it is done</pre>
<pre>				above or to the left (if vertical).  When not</pre>
<pre>				present, the values of 'splitbelow' and</pre>
<pre>				'splitright' are used.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetWinid()->win_splitmove(target)</pre>
<
<pre>							*winbufnr()*</pre>
winbufnr({nr})	The result is a Number, which is the number of the buffer
<pre>		associated with window {nr}.  {nr} can be the window number or</pre>
<pre>		the |window-ID|.</pre>
<pre>		When {nr} is zero, the number of the buffer in the current</pre>
<pre>		window is returned.</pre>
<pre>		When window {nr} doesn't exist, -1 is returned.</pre>
<pre>		Example: ></pre>
<pre>  :echo "The file in the current window is " . bufname(winbufnr(0))</pre>
<
<pre>		Can also be used as a |method|: ></pre>
<pre>			FindWindow()->winbufnr()->bufname()</pre>
<
<pre>							*wincol()*</pre>
wincol()	The result is a Number, which is the virtual column of the
<pre>		cursor in the window.  This is counting screen cells from the</pre>
<pre>		left side of the window.  The leftmost column is one.<p></pre>

winheight({nr})						*winheight()*
<pre>		The result is a Number, which is the height of window {nr}.</pre>
<pre>		{nr} can be the window number or the |window-ID|.</pre>
<pre>		When {nr} is zero, the height of the current window is</pre>
<pre>		returned.  When window {nr} doesn't exist, -1 is returned.</pre>
<pre>		An existing window always has a height of zero or more.</pre>
<pre>		This excludes any window toolbar line.</pre>
<pre>		Examples: ></pre>
<pre>  :echo "The current window has " . winheight(0) . " lines."<p></pre>

<		Can also be used as a |method|: >
<pre>			GetWinid()->winheight()</pre>
<
winlayout([{tabnr}])					*winlayout()*
<pre>		The result is a nested List containing the layout of windows</pre>
<pre>		in a tabpage.<p></pre>

<pre>		Without {tabnr} use the current tabpage, otherwise the tabpage</pre>
<pre>		with number {tabnr}. If the tabpage {tabnr} is not found,</pre>
<pre>		returns an empty list.<p></pre>

<pre>		For a leaf window, it returns:</pre>
<pre>			['leaf', {winid}]</pre>
<pre>		For horizontally split windows, which form a column, it</pre>
<pre>		returns:</pre>
<pre>			['col', [{nested list of windows}]]</pre>
<pre>		For vertically split windows, which form a row, it returns:</pre>
<pre>			['row', [{nested list of windows}]]<p></pre>

<pre>		Example: ></pre>
<pre>			" Only one window in the tab page</pre>
<pre>			:echo winlayout()</pre>
<pre>			['leaf', 1000]</pre>
<pre>			" Two horizontally split windows</pre>
<pre>			:echo winlayout()</pre>
<pre>			['col', [['leaf', 1000], ['leaf', 1001]]]</pre>
<pre>			" Three horizontally split windows, with two</pre>
<pre>			" vertically split windows in the middle window</pre>
<pre>			:echo winlayout(2)</pre>
<pre>			['col', [['leaf', 1002], ['row', ['leaf', 1003],</pre>
<pre>					     ['leaf', 1001]]], ['leaf', 1000]]</pre>
<
<pre>		Can also be used as a |method|: ></pre>
<pre>			GetTabnr()->winlayout()</pre>
<
<pre>							*winline()*</pre>
winline()	The result is a Number, which is the screen line of the cursor
<pre>		in the window.  This is counting screen lines from the top of</pre>
<pre>		the window.  The first line is one.</pre>
<pre>		If the cursor was moved the view on the file will be updated</pre>
<pre>		first, this may cause a scroll.<p></pre>

<pre>							*winnr()*</pre>
winnr([{arg}])	The result is a Number, which is the number of the current
<pre>		window.  The top window has number 1.<p></pre>

<pre>		The optional argument {arg} supports the following values:</pre>
<pre>			$	the number of the last window (the window</pre>
<pre>				count).</pre>
<pre>			#	the number of the last accessed window (where</pre>
<pre>				|CTRL-W_p| goes to).  If there is no previous</pre>
<pre>				window or it is in another tab page 0 is</pre>
<pre>				returned.</pre>
<pre>			{N}j	the number of the Nth window below the</pre>
<pre>				current window (where |CTRL-W_j| goes to).</pre>
<pre>			{N}k	the number of the Nth window above the current</pre>
<pre>				window (where |CTRL-W_k| goes to).</pre>
<pre>			{N}h	the number of the Nth window left of the</pre>
<pre>				current window (where |CTRL-W_h| goes to).</pre>
<pre>			{N}l	the number of the Nth window right of the</pre>
<pre>				current window (where |CTRL-W_l| goes to).</pre>
<pre>		The number can be used with |CTRL-W_w| and ":wincmd w"</pre>
<pre>		|:wincmd|.</pre>
<pre>		Also see |tabpagewinnr()| and |win_getid()|.</pre>
<pre>		Examples: ></pre>
<pre>			let window_count = winnr('$')</pre>
<pre>			let prev_window = winnr('#')</pre>
<pre>			let wnum = winnr('3k')<p></pre>

<		Can also be used as a |method|: >
<pre>			GetWinval()->winnr()</pre>
<
<pre>							*winrestcmd()*</pre>
winrestcmd()	Returns a sequence of |:resize| commands that should restore
<pre>		the current window sizes.  Only works properly when no windows</pre>
<pre>		are opened or closed and the current window and tab page is</pre>
<pre>		unchanged.</pre>
<pre>		Example: ></pre>
<pre>			:let cmd = winrestcmd()</pre>
<pre>			:call MessWithWindowSizes()</pre>
<pre>			:exe cmd</pre>
<
<pre>							*winrestview()*</pre>
winrestview({dict})
<pre>		Uses the |Dictionary| returned by |winsaveview()| to restore</pre>
<pre>		the view of the current window.</pre>
<pre>		Note: The {dict} does not have to contain all values, that are</pre>
<pre>		returned by |winsaveview()|. If values are missing, those</pre>
<pre>		settings won't be restored. So you can use: ></pre>
<pre>		    :call winrestview({'curswant': 4})</pre>
<
<pre>		This will only set the curswant value (the column the cursor</pre>
<pre>		wants to move on vertical movements) of the cursor to column 5</pre>
<pre>		(yes, that is 5), while all other settings will remain the</pre>
<pre>		same. This is useful, if you set the cursor position manually.<p></pre>

<pre>		If you have changed the values the result is unpredictable.</pre>
<pre>		If the window size changed the result won't be the same.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetView()->winrestview()</pre>
<
<pre>							*winsaveview()*</pre>
winsaveview()	Returns a |Dictionary| that contains information to restore
<pre>		the view of the current window.  Use |winrestview()| to</pre>
<pre>		restore the view.</pre>
<pre>		This is useful if you have a mapping that jumps around in the</pre>
<pre>		buffer and you want to go back to the original view.</pre>
<pre>		This does not save fold information.  Use the 'foldenable'</pre>
<pre>		option to temporarily switch off folding, so that folds are</pre>
<pre>		not opened when moving around. This may have side effects.</pre>
<pre>		The return value includes:</pre>
<pre>			lnum		cursor line number</pre>
<pre>			col		cursor column (Note: the first column</pre>
<pre>					zero, as opposed to what getpos()</pre>
<pre>					returns)</pre>
<pre>			coladd		cursor column offset for 'virtualedit'</pre>
<pre>			curswant	column for vertical movement</pre>
<pre>			topline		first line in the window</pre>
<pre>			topfill		filler lines, only in diff mode</pre>
<pre>			leftcol		first column displayed</pre>
<pre>			skipcol		columns skipped</pre>
<pre>		Note that no option values are saved.<p></pre>


winwidth({nr})						*winwidth()*
<pre>		The result is a Number, which is the width of window {nr}.</pre>
<pre>		{nr} can be the window number or the |window-ID|.</pre>
<pre>		When {nr} is zero, the width of the current window is</pre>
<pre>		returned.  When window {nr} doesn't exist, -1 is returned.</pre>
<pre>		An existing window always has a width of zero or more.</pre>
<pre>		Examples: ></pre>
<pre>  :echo "The current window has " . winwidth(0) . " columns."</pre>
<pre>  :if winwidth(0) <= 50</pre>
<pre>  :  50 wincmd |</pre>
<pre>  :endif</pre>
<		For getting the terminal or screen size, see the 'columns'
<pre>		option.<p></pre>

<pre>		Can also be used as a |method|: ></pre>
<pre>			GetWinid()->winwidth()<p></pre>


wordcount()						*wordcount()*
<pre>		The result is a dictionary of byte/chars/word statistics for</pre>
<pre>		the current buffer.  This is the same info as provided by</pre>
<pre>		|g_CTRL-G|</pre>
<pre>		The return value includes:</pre>
<pre>			bytes		Number of bytes in the buffer</pre>
<pre>			chars		Number of chars in the buffer</pre>
<pre>			words		Number of words in the buffer</pre>
<pre>			cursor_bytes    Number of bytes before cursor position</pre>
<pre>					(not in Visual mode)</pre>
<pre>			cursor_chars    Number of chars before cursor position</pre>
<pre>					(not in Visual mode)</pre>
<pre>			cursor_words    Number of words before cursor position</pre>
<pre>					(not in Visual mode)</pre>
<pre>			visual_bytes    Number of bytes visually selected</pre>
<pre>					(only in Visual mode)</pre>
<pre>			visual_chars    Number of chars visually selected</pre>
<pre>					(only in Visual mode)</pre>
<pre>			visual_words    Number of words visually selected</pre>
<pre>					(only in Visual mode)<p></pre>


<pre>							*writefile()*</pre>
writefile({object}, {fname} [, {flags}])
<pre>		When {object} is a |List| write it to file {fname}.  Each list</pre>
<pre>		item is separated with a NL.  Each list item must be a String</pre>
<pre>		or Number.</pre>
<pre>		When {flags} contains "b" then binary mode is used: There will</pre>
<pre>		not be a NL after the last list item.  An empty item at the</pre>
<pre>		end does cause the last line in the file to end in a NL.<p></pre>

<pre>		When {object} is a |Blob| write the bytes to file {fname}</pre>
<pre>		unmodified.<p></pre>

<pre>		When {flags} contains "a" then append mode is used, lines are</pre>
<pre>		appended to the file: ></pre>
<pre>			:call writefile(["foo"], "event.log", "a")</pre>
<pre>			:call writefile(["bar"], "event.log", "a")</pre>
<
<pre>		When {flags} contains "s" then fsync() is called after writing</pre>
<pre>		the file.  This flushes the file to disk, if possible.  This</pre>
<pre>		takes more time but avoids losing the file if the system</pre>
<pre>		crashes.</pre>
<pre>		When {flags} does not contain "S" or "s" then fsync() is</pre>
<pre>		called if the 'fsync' option is set.</pre>
<pre>		When {flags} contains "S" then fsync() is not called, even</pre>
<pre>		when 'fsync' is set.<p></pre>

<pre>		All NL characters are replaced with a NUL character.</pre>
<pre>		Inserting CR characters needs to be done before passing {list}</pre>
<pre>		to writefile().</pre>
<pre>		An existing file is overwritten, if possible.</pre>
<pre>		When the write fails -1 is returned, otherwise 0.  There is an</pre>
<pre>		error message if the file can't be created or when writing</pre>
<pre>		fails.</pre>
<pre>		Also see |readfile()|.</pre>
<pre>		To copy a file byte for byte: ></pre>
<pre>			:let fl = readfile("foo", "b")</pre>
<pre>			:call writefile(fl, "foocopy", "b")<p></pre>

<		Can also be used as a |method|: >
<pre>			GetText()->writefile("thefile")<p></pre>


xor({expr}, {expr})					*xor()*
<pre>		Bitwise XOR on the two arguments.  The arguments are converted</pre>
<pre>		to a number.  A List, Dict or Float argument causes an error.</pre>
<pre>		Example: ></pre>
<pre>			:let bits = xor(bits, 0x80)</pre>
<
<pre>		Can also be used as a |method|: ></pre>
<pre>			:let bits = bits->xor(0x80)</pre>
<<p>

<pre>							*feature-list*</pre>
There are four types of features:
<pre>1.  Features that are only supported when they have been enabled when Vim</pre>
<pre>    was compiled |+feature-list|.  Example: ></pre>
<pre>	:if has("cindent")</pre>
<pre>2.  Features that are only supported when certain conditions have been met.</pre>
<pre>    Example: ></pre>
<pre>	:if has("gui_running")</pre>
<							*has-patch*
<pre>3.  Beyond a certain version or at a certain version and including a specific</pre>
<pre>    patch.  The "patch-7.4.248" feature means that the Vim version is 7.5 or</pre>
<pre>    later, or it is version 7.4 and patch 248 was included.  Example: ></pre>
<pre>	:if has("patch-7.4.248")</pre>
<    Note that it's possible for patch 248 to be omitted even though 249 is
<pre>    included.  Only happens when cherry-picking patches.</pre>
<pre>    Note that this form only works for patch 7.4.237 and later, before that</pre>
<pre>    you need to check for the patch and the  v:version.  Example (checking</pre>
<pre>    version 6.2.148 or later): ></pre>
<pre>	:if v:version > 602 || (v:version == 602 && has("patch148"))<p></pre>

Hint: To find out if Vim supports backslashes in a file name (MS-Windows),
use: `if exists('+shellslash')`<p>


acl			Compiled with |ACL| support.
all_builtin_terms	Compiled with all builtin terminals enabled.
amiga			Amiga version of Vim.
arabic			Compiled with Arabic support |Arabic|.
arp			Compiled with ARP support (Amiga).
autocmd			Compiled with autocommand support. (always true)
autochdir		Compiled with support for 'autochdir'
autoservername		Automatically enable |clientserver|
balloon_eval		Compiled with |balloon-eval| support.
balloon_multiline	GUI supports multiline balloons.
beos			BeOS version of Vim.
browse			Compiled with |:browse| support, and browse() will
<pre>			work.</pre>
browsefilter		Compiled with support for |browsefilter|.
bsd			Compiled on an OS in the BSD family (excluding macOS).
builtin_terms		Compiled with some builtin terminals.
byte_offset		Compiled with support for 'o' in 'statusline'
cindent			Compiled with 'cindent' support.
clientserver		Compiled with remote invocation support |clientserver|.
clipboard		Compiled with 'clipboard' support.
clipboard_working	Compiled with 'clipboard' support and it can be used.
cmdline_compl		Compiled with |cmdline-completion| support.
cmdline_hist		Compiled with |cmdline-history| support.
cmdline_info		Compiled with 'showcmd' and 'ruler' support.
comments		Compiled with |'comments'| support.
compatible		Compiled to be very Vi compatible.
conpty			Platform where |ConPTY| can be used.
cryptv			Compiled with encryption support |encryption|.
cscope			Compiled with |cscope| support.
cursorbind		Compiled with |'cursorbind'| (always true)
debug			Compiled with "DEBUG" defined.
dialog_con		Compiled with console dialog support.
dialog_gui		Compiled with GUI dialog support.
diff			Compiled with |vimdiff| and 'diff' support.
digraphs		Compiled with support for digraphs.
directx			Compiled with support for DirectX and 'renderoptions'.
dnd			Compiled with support for the "~ register |quote_~|.
ebcdic			Compiled on a machine with ebcdic character set.
emacs_tags		Compiled with support for Emacs tags.
eval			Compiled with expression evaluation support.  Always
<pre>			true, of course!</pre>
ex_extra		|+ex_extra| (always true)
extra_search		Compiled with support for |'incsearch'| and
<pre>			|'hlsearch'|</pre>
farsi			Compiled with Farsi support |farsi|.
file_in_path		Compiled with support for |gf| and |<cfile>|
filterpipe		When 'shelltemp' is off pipes are used for shell
<pre>			read/write/filter commands</pre>
find_in_path		Compiled with support for include file searches
<pre>			|+find_in_path|.</pre>
float			Compiled with support for |Float|.
fname_case		Case in file names matters (for Amiga, MS-DOS, and
<pre>			Windows this is not present).</pre>
folding			Compiled with |folding| support.
footer			Compiled with GUI footer support. |gui-footer|
fork			Compiled to use fork()/exec() instead of system().
gettext			Compiled with message translation |multi-lang|
gui			Compiled with GUI enabled.
gui_athena		Compiled with Athena GUI.
gui_gnome		Compiled with Gnome support (gui_gtk is also defined).
gui_gtk			Compiled with GTK+ GUI (any version).
gui_gtk2		Compiled with GTK+ 2 GUI (gui_gtk is also defined).
gui_gtk3		Compiled with GTK+ 3 GUI (gui_gtk is also defined).
gui_mac			Compiled with Macintosh GUI.
gui_motif		Compiled with Motif GUI.
gui_photon		Compiled with Photon GUI.
gui_running		Vim is running in the GUI, or it will start soon.
gui_win32		Compiled with MS Windows Win32 GUI.
gui_win32s		idem, and Win32s system being used (Windows 3.1)
hangul_input		Compiled with Hangul input support. |hangul|
hpux			HP-UX version of Vim.
iconv			Can use iconv() for conversion.
insert_expand		Compiled with support for CTRL-X expansion commands in
<pre>			Insert mode. (always true)</pre>
jumplist		Compiled with |jumplist| support.
keymap			Compiled with 'keymap' support.
lambda			Compiled with |lambda| support.
langmap			Compiled with 'langmap' support.
libcall			Compiled with |libcall()| support.
linebreak		Compiled with 'linebreak', 'breakat', 'showbreak' and
<pre>			'breakindent' support.</pre>
linux			Linux version of Vim.
lispindent		Compiled with support for lisp indenting.
listcmds		Compiled with commands for the buffer list |:files|
<pre>			and the argument list |arglist|.</pre>
localmap		Compiled with local mappings and abbr. |:map-local|
lua			Compiled with Lua interface |Lua|.
mac			Any Macintosh version of Vim  cf. osx
macunix			Synonym for osxdarwin
menu			Compiled with support for |:menu|.
mksession		Compiled with support for |:mksession|.
modify_fname		Compiled with file name modifiers. |filename-modifiers|
<pre>			(always true)</pre>
mouse			Compiled with support mouse.
mouse_dec		Compiled with support for Dec terminal mouse.
mouse_gpm		Compiled with support for gpm (Linux console mouse)
mouse_gpm_enabled	GPM mouse is working
mouse_netterm		Compiled with support for netterm mouse.
mouse_pterm		Compiled with support for qnx pterm mouse.
mouse_sysmouse		Compiled with support for sysmouse (*BSD console mouse)
mouse_sgr		Compiled with support for sgr mouse.
mouse_urxvt		Compiled with support for urxvt mouse.
mouse_xterm		Compiled with support for xterm mouse.
mouseshape		Compiled with support for 'mouseshape'.
multi_byte		Compiled with support for 'encoding' (always true)
multi_byte_encoding	'encoding' is set to a multi-byte encoding.
multi_byte_ime		Compiled with support for IME input method.
multi_lang		Compiled with support for multiple languages.
mzscheme		Compiled with MzScheme interface |mzscheme|.
netbeans_enabled	Compiled with support for |netbeans| and connected.
netbeans_intg		Compiled with support for |netbeans|.
num64			Compiled with 64-bit |Number| support.
ole			Compiled with OLE automation support for Win32.
osx			Compiled for macOS  cf. mac
osxdarwin		Compiled for macOS, with |mac-darwin-feature|
packages		Compiled with |packages| support.
path_extra		Compiled with up/downwards search in 'path' and 'tags'
perl			Compiled with Perl interface.
persistent_undo		Compiled with support for persistent undo history.
postscript		Compiled with PostScript file printing.
printer			Compiled with |:hardcopy| support.
profile			Compiled with |:profile| support.
python			Python 2.x interface available. |has-python|
python_compiled		Compiled with Python 2.x interface. |has-python|
python_dynamic		Python 2.x interface is dynamically loaded. |has-python|
python3			Python 3.x interface available. |has-python|
python3_compiled	Compiled with Python 3.x interface. |has-python|
python3_dynamic		Python 3.x interface is dynamically loaded. |has-python|
pythonx			Compiled with |python_x| interface. |has-pythonx|
qnx			QNX version of Vim.
quickfix		Compiled with |quickfix| support.
reltime			Compiled with |reltime()| support.
rightleft		Compiled with 'rightleft' support.
ruby			Compiled with Ruby interface |ruby|.
scrollbind		Compiled with 'scrollbind' support. (always true)
showcmd			Compiled with 'showcmd' support.
signs			Compiled with |:sign| support.
smartindent		Compiled with 'smartindent' support.
sound			Compiled with sound support, e.g. `sound_playevent()`
spell			Compiled with spell checking support |spell|.
startuptime		Compiled with |--startuptime| support.
statusline		Compiled with support for 'statusline', 'rulerformat'
<pre>			and special formats of 'titlestring' and 'iconstring'.</pre>
sun			SunOS version of Vim.
sun_workshop		Support for Sun |workshop| has been removed.
syntax			Compiled with syntax highlighting support |syntax|.
syntax_items		There are active syntax highlighting items for the
<pre>			current buffer.</pre>
system			Compiled to use system() instead of fork()/exec().
tag_binary		Compiled with binary searching in tags files
<pre>			|tag-binary-search|.</pre>
tag_old_static		Support for old static tags was removed, see
<pre>			|tag-old-static|.</pre>
tcl			Compiled with Tcl interface.
termguicolors		Compiled with true color in terminal support.
terminal		Compiled with |terminal| support.
terminfo		Compiled with terminfo instead of termcap.
termresponse		Compiled with support for |t_RV| and |v:termresponse|.
textobjects		Compiled with support for |text-objects|.
textprop		Compiled with support for |text-properties|.
tgetent			Compiled with tgetent support, able to use a termcap
<pre>			or terminfo file.</pre>
timers			Compiled with |timer_start()| support.
title			Compiled with window title support |'title'|.
toolbar			Compiled with support for |gui-toolbar|.
ttyin			input is a terminal (tty)
ttyout			output is a terminal (tty)
unix			Unix version of Vim. *+unix*
unnamedplus		Compiled with support for "unnamedplus" in 'clipboard'
user_commands		User-defined commands. (always true)
vcon			Win32: Virtual console support is working, can use
<pre>			'termguicolors'. Also see |+vtp|.</pre>
vertsplit		Compiled with vertically split windows |:vsplit|.
<pre>			(always true)</pre>
vim_starting		True while initial source'ing takes place. |startup|
<pre>			*vim_starting*</pre>
viminfo			Compiled with viminfo support.
vimscript-1		Compiled Vim script version 1 support
vimscript-2		Compiled Vim script version 2 support
vimscript-3		Compiled Vim script version 3 support
virtualedit		Compiled with 'virtualedit' option. (always true)
visual			Compiled with Visual mode. (always true)
visualextra		Compiled with extra Visual mode commands. (always
<pre>			true) |blockwise-operators|.</pre>
vms			VMS version of Vim.
vreplace		Compiled with |gR| and |gr| commands. (always true)
vtp			Compiled for vcon support |+vtp| (check vcon to find
<pre>			out if it works in the current console).</pre>
wildignore		Compiled with 'wildignore' option.
wildmenu		Compiled with 'wildmenu' option.
win16			old version for MS-Windows 3.1 (always false)
win32			Win32 version of Vim (MS-Windows 95 and later, 32 or
<pre>			64 bits)</pre>
win32unix		Win32 version of Vim, using Unix files (Cygwin)
win64			Win64 version of Vim (MS-Windows 64 bit).
win95			Win32 version for MS-Windows 95/98/ME (always false)
winaltkeys		Compiled with 'winaltkeys' option.
windows			Compiled with support for more than one window.
<pre>			(always true)</pre>
writebackup		Compiled with 'writebackup' default on.
xfontset		Compiled with X fontset support |xfontset|.
xim			Compiled with X input method support |xim|.
xpm			Compiled with pixmap support.
xpm_w32			Compiled with pixmap support for Win32. (Only for
<pre>			backward compatibility. Use "xpm" instead.)</pre>
xsmp			Compiled with X session management support.
xsmp_interact		Compiled with interactive X session management support.
xterm_clipboard		Compiled with support for xterm clipboard.
xterm_save		Compiled with support for saving and restoring the
<pre>			xterm screen.</pre>
x11			Compiled with X11 support.<p>

<pre>							*string-match*</pre>
Matching a pattern in a String<p>

A regexp pattern as explained at |pattern| is normally used to find a match in
the buffer lines.  When a pattern is used to find a match in a String, almost
everything works in the same way.  The difference is that a String is handled
like it is one line.  When it contains a "\n" character, this is not seen as a
line break for the pattern.  It can be matched with a "\n" in the pattern, or
with ".".  Example: >
<pre>	:let a = "aaaa\nxxxx"</pre>
<pre>	:echo matchstr(a, "..\n..")</pre>
<pre>	aa</pre>
<pre>	xx</pre>
<pre>	:echo matchstr(a, "a.x")</pre>
<pre>	a</pre>
<pre>	x<p></pre>

Don't forget that "^" will only match at the first character of the String and
"$" at the last character of the string.  They don't match after or before a
"\n".<p>

* Defining functions					*user-functions*<p>

New functions can be defined.  These can be called just like builtin
functions.  The function executes a sequence of Ex commands.  Normal mode
commands can be executed with the |:normal| command.<p>

The function name must start with an uppercase letter, to avoid confusion with
builtin functions.  To prevent from using the same name in different scripts
avoid obvious, short names.  A good habit is to start the function name with
the name of the script, e.g., "HTMLcolor()".<p>

It's also possible to use curly braces, see |curly-braces-names|.  And the
|autoload| facility is useful to define a function only when it's called.<p>

<pre>							*local-function*</pre>
A function local to a script must start with "s:".  A local script function
can only be called from within the script and from functions, user commands
and autocommands defined in the script.  It is also possible to call the
function from a mapping defined in the script, but then |<SID>| must be used
instead of "s:" when the mapping is expanded outside of the script.
There are only script-local functions, no buffer-local or window-local
functions.<p>

<pre>					*:fu* *:function* *E128* *E129* *E123*</pre>
:fu[nction]		List all functions and their arguments.<p>

:fu[nction] {name}	List function {name}.
<pre>			{name} can also be a |Dictionary| entry that is a</pre>
<pre>			|Funcref|: ></pre>
<pre>				:function dict.init<p></pre>

:fu[nction] /{pattern}	List functions with a name matching {pattern}.
<pre>			Example that lists all functions ending with "File": ></pre>
<pre>				:function /File$</pre>
<
<pre>							*:function-verbose*</pre>
When 'verbose' is non-zero, listing a function will also display where it was
last defined. Example: ><p>

<pre>    :verbose function SetFileTypeSH</pre>
<pre>	function SetFileTypeSH(name)</pre>
<pre>	    Last set from /usr/share/vim/vim-7.0/filetype.vim</pre>
<
See |:verbose-cmd| for more information.<p>

<pre>						*E124* *E125* *E853* *E884*</pre>
:fu[nction][!] {name}([arguments]) [range] [abort] [dict] [closure]
<pre>			Define a new function by the name {name}.  The body of</pre>
<pre>			the function follows in the next lines, until the</pre>
<pre>			matching |:endfunction|.<p></pre>

<pre>			The name must be made of alphanumeric characters and</pre>
<pre>			'_', and must start with a capital or "s:" (see</pre>
<pre>			above).  Note that using "b:" or "g:" is not allowed.</pre>
<pre>			(since patch 7.4.260 E884 is given if the function</pre>
<pre>			name has a colon in the name, e.g. for "foo:bar()".</pre>
<pre>			Before that patch no error was given).<p></pre>

<pre>			{name} can also be a |Dictionary| entry that is a</pre>
<pre>			|Funcref|: ></pre>
<pre>				:function dict.init(arg)</pre>
<			"dict" must be an existing dictionary.  The entry
<pre>			"init" is added if it didn't exist yet.  Otherwise [!]</pre>
<pre>			is required to overwrite an existing function.  The</pre>
<pre>			result is a |Funcref| to a numbered function.  The</pre>
<pre>			function can only be used with a |Funcref| and will be</pre>
<pre>			deleted if there are no more references to it.</pre>
<pre>								*E127* *E122*</pre>
<pre>			When a function by this name already exists and [!] is</pre>
<pre>			not used an error message is given.  There is one</pre>
<pre>			exception: When sourcing a script again, a function</pre>
<pre>			that was previously defined in that script will be</pre>
<pre>			silently replaced.</pre>
<pre>			When [!] is used, an existing function is silently</pre>
<pre>			replaced.  Unless it is currently being executed, that</pre>
<pre>			is an error.</pre>
<pre>			NOTE: Use ! wisely.  If used without care it can cause</pre>
<pre>			an existing function to be replaced unexpectedly,</pre>
<pre>			which is hard to debug.<p></pre>

<pre>			For the {arguments} see |function-argument|.<p></pre>

<pre>					*:func-range* *a:firstline* *a:lastline*</pre>
<pre>			When the [range] argument is added, the function is</pre>
<pre>			expected to take care of a range itself.  The range is</pre>
<pre>			passed as "a:firstline" and "a:lastline".  If [range]</pre>
<pre>			is excluded, ":{range}call" will call the function for</pre>
<pre>			each line in the range, with the cursor on the start</pre>
<pre>			of each line.  See |function-range-example|.</pre>
<pre>			The cursor is still moved to the first line of the</pre>
<pre>			range, as is the case with all Ex commands.</pre>
<pre>								*:func-abort*</pre>
<pre>			When the [abort] argument is added, the function will</pre>
<pre>			abort as soon as an error is detected.</pre>
<pre>								*:func-dict*</pre>
<pre>			When the [dict] argument is added, the function must</pre>
<pre>			be invoked through an entry in a |Dictionary|.  The</pre>
<pre>			local variable "self" will then be set to the</pre>
<pre>			dictionary.  See |Dictionary-function|.</pre>
<pre>						*:func-closure* *E932*</pre>
<pre>			When the [closure] argument is added, the function</pre>
<pre>			can access variables and arguments from the outer</pre>
<pre>			scope.  This is usually called a closure.  In this</pre>
<pre>			example Bar() uses "x" from the scope of Foo().  It</pre>
<pre>			remains referenced even after Foo() returns: ></pre>
<pre>				:function! Foo()</pre>
<pre>				:  let x = 0</pre>
<pre>				:  function! Bar() closure</pre>
<pre>				:    let x += 1</pre>
<pre>				:    return x</pre>
<pre>				:  endfunction</pre>
<pre>				:  return funcref('Bar')</pre>
<pre>				:endfunction<p></pre>

<pre>				:let F = Foo()</pre>
<pre>				:echo F()</pre>
<				1 >
<pre>				:echo F()</pre>
<				2 >
<pre>				:echo F()</pre>
<				3<p>

<pre>						*function-search-undo*</pre>
<pre>			The last used search pattern and the redo command "."</pre>
<pre>			will not be changed by the function.  This also</pre>
<pre>			implies that the effect of |:nohlsearch| is undone</pre>
<pre>			when the function returns.<p></pre>

<pre>				*:endf* *:endfunction* *E126* *E193* *W22*</pre>
:endf[unction] [argument]
<pre>			The end of a function definition.  Best is to put it</pre>
<pre>			on a line by its own, without [argument].<p></pre>

<pre>			[argument] can be:</pre>
<pre>				| command	command to execute next</pre>
<pre>				\n command	command to execute next</pre>
<pre>				" comment	always ignored</pre>
<pre>				anything else	ignored, warning given when</pre>
<pre>						'verbose' is non-zero</pre>
<pre>			The support for a following command was added in Vim</pre>
<pre>			8.0.0654, before that any argument was silently</pre>
<pre>			ignored.<p></pre>

<pre>			To be able to define a function inside an `:execute`</pre>
<pre>			command, use line breaks instead of |:bar|: ></pre>
<pre>				:exe "func Foo()\necho 'foo'\nendfunc"</pre>
<
<pre>				*:delf* *:delfunction* *E130* *E131* *E933*</pre>
:delf[unction][!] {name}
<pre>			Delete function {name}.</pre>
<pre>			{name} can also be a |Dictionary| entry that is a</pre>
<pre>			|Funcref|: ></pre>
<pre>				:delfunc dict.init</pre>
<			This will remove the "init" entry from "dict".  The
<pre>			function is deleted if there are no more references to</pre>
<pre>			it.</pre>
<pre>			With the ! there is no error if the function does not</pre>
<pre>			exist.</pre>
<pre>							*:retu* *:return* *E133*</pre>
:retu[rn] [expr]	Return from a function.  When "[expr]" is given, it is
<pre>			evaluated and returned as the result of the function.</pre>
<pre>			If "[expr]" is not given, the number 0 is returned.</pre>
<pre>			When a function ends without an explicit ":return",</pre>
<pre>			the number 0 is returned.</pre>
<pre>			Note that there is no check for unreachable lines,</pre>
<pre>			thus there is no warning if commands follow ":return".<p></pre>

<pre>			If the ":return" is used after a |:try| but before the</pre>
<pre>			matching |:finally| (if present), the commands</pre>
<pre>			following the ":finally" up to the matching |:endtry|</pre>
<pre>			are executed first.  This process applies to all</pre>
<pre>			nested ":try"s inside the function.  The function</pre>
<pre>			returns at the outermost ":endtry".<p></pre>

<pre>						*function-argument* *a:var*</pre>
An argument can be defined by giving its name.  In the function this can then
be used as "a:name" ("a:" for argument).
<pre>					*a:0* *a:1* *a:000* *E740* *...*</pre>
Up to 20 arguments can be given, separated by commas.  After the named
arguments an argument "..." can be specified, which means that more arguments
may optionally be following.  In the function the extra arguments can be used
as "a:1", "a:2", etc.  "a:0" is set to the number of extra arguments (which
can be 0).  "a:000" is set to a |List| that contains these arguments.  Note
that "a:1" is the same as "a:000[0]".
<pre>								*E742*</pre>
The a: scope and the variables in it cannot be changed, they are fixed.
However, if a composite type is used, such as |List| or |Dictionary| , you can
change their contents.  Thus you can pass a |List| to a function and have the
function add an item to it.  If you want to make sure the function cannot
change a |List| or |Dictionary| use |:lockvar|.<p>

It is also possible to define a function without any arguments.  You must
still supply the () then.<p>

It is allowed to define another function inside a function body.<p>

<pre>						*optional-function-argument*</pre>
You can provide default values for positional named arguments.  This makes
them optional for function calls.  When a positional argument is not
specified at a call, the default expression is used to initialize it.
This only works for functions declared with `:function`, not for lambda
expressions |expr-lambda|.<p>

Example: >
<pre>  function Something(key, value = 10)</pre>
<pre>     echo a:key .. ": " .. a:value</pre>
<pre>  endfunction</pre>
<pre>  call Something('empty')	"empty: 10"</pre>
<pre>  call Something('key', 20)	"key: 20"<p></pre>

The argument default expressions are evaluated at the time of the function
call, not definition.  Thus it is possible to use an expression which is
invalid the moment the function is defined.  The expressions are also only
evaluated when arguments are not specified during a call.<p>

You can pass |v:none| to use the default expression.  Note that this means you
cannot pass v:none as an ordinary value when an argument has a default
expression.<p>

Example: >
<pre>  function Something(a = 10, b = 20, c = 30)</pre>
<pre>  endfunction</pre>
<pre>  call Something(1, v:none, 3)	    " b = 20</pre>
<
<pre>								*E989*</pre>
Optional arguments with default expressions must occur after any mandatory
arguments.  You can use "..." after all optional named arguments.<p>

It is possible for later argument defaults to refer to prior arguments,
but not the other way around.  They must be prefixed with "a:", as with all
arguments.<p>

Example that works: >
<pre>  :function Okay(mandatory, optional = a:mandatory)</pre>
<pre>  :endfunction</pre>
Example that does NOT work: >
<pre>  :function NoGood(first = a:second, second = 10)</pre>
<pre>  :endfunction</pre>
<
When not using "...", the number of arguments in a function call must be equal
to the number of mandatory named arguments.  When using "...", the number of
arguments may be larger.<p>

<pre>							*local-variables*</pre>
Inside a function local variables can be used.  These will disappear when the
function returns.  Global variables need to be accessed with "g:".<p>

Example: >
<pre>  :function Table(title, ...)</pre>
<pre>  :  echohl Title</pre>
<pre>  :  echo a:title</pre>
<pre>  :  echohl None</pre>
<pre>  :  echo a:0 . " items:"</pre>
<pre>  :  for s in a:000</pre>
<pre>  :    echon ' ' . s</pre>
<pre>  :  endfor</pre>
<pre>  :endfunction<p></pre>

This function can then be called with: >
<pre>  call Table("Table", "line1", "line2")</pre>
<pre>  call Table("Empty Table")<p></pre>

To return more than one value, return a |List|: >
<pre>  :function Compute(n1, n2)</pre>
<pre>  :  if a:n2 == 0</pre>
<pre>  :    return ["fail", 0]</pre>
<pre>  :  endif</pre>
<pre>  :  return ["ok", a:n1 / a:n2]</pre>
<pre>  :endfunction<p></pre>

This function can then be called with: >
<pre>  :let [success, div] = Compute(102, 6)</pre>
<pre>  :if success == "ok"</pre>
<pre>  :  echo div</pre>
<pre>  :endif</pre>
<
<pre>						*:cal* *:call* *E107* *E117*</pre>
:[range]cal[l] {name}([arguments])
<pre>		Call a function.  The name of the function and its arguments</pre>
<pre>		are as specified with `:function`.  Up to 20 arguments can be</pre>
<pre>		used.  The returned value is discarded.</pre>
<pre>		Without a range and for functions that accept a range, the</pre>
<pre>		function is called once.  When a range is given the cursor is</pre>
<pre>		positioned at the start of the first line before executing the</pre>
<pre>		function.</pre>
<pre>		When a range is given and the function doesn't handle it</pre>
<pre>		itself, the function is executed for each line in the range,</pre>
<pre>		with the cursor in the first column of that line.  The cursor</pre>
<pre>		is left at the last line (possibly moved by the last function</pre>
<pre>		call).  The arguments are re-evaluated for each line.  Thus</pre>
<pre>		this works:</pre>
<pre>						*function-range-example*  ></pre>
<pre>	:function Mynumber(arg)</pre>
<pre>	:  echo line(".") . " " . a:arg</pre>
<pre>	:endfunction</pre>
<pre>	:1,5call Mynumber(getline("."))</pre>
<
<pre>		The "a:firstline" and "a:lastline" are defined anyway, they</pre>
<pre>		can be used to do something different at the start or end of</pre>
<pre>		the range.<p></pre>

<pre>		Example of a function that handles the range itself: ><p></pre>

<pre>	:function Cont() range</pre>
<pre>	:  execute (a:firstline + 1) . "," . a:lastline . 's/^/\t\\ '</pre>
<pre>	:endfunction</pre>
<pre>	:4,8call Cont()</pre>
<
<pre>		This function inserts the continuation character "\" in front</pre>
<pre>		of all the lines in the range, except the first one.<p></pre>

<pre>		When the function returns a composite value it can be further</pre>
<pre>		dereferenced, but the range will not be used then.  Example: ></pre>
<pre>	:4,8call GetDict().method()</pre>
<		Here GetDict() gets the range but method() does not.<p>

<pre>								*E132*</pre>
The recursiveness of user functions is restricted with the |'maxfuncdepth'|
option.<p>

It is also possible to use `:eval`.  It does not support a range, but does
allow for method chaining, e.g.: >
<pre>	eval GetList()->Filter()->append('$')<p></pre>

A function can also be called as part of evaluating an expression or when it
is used as a method: >
<pre>	let x = GetList()</pre>
<pre>	let y = GetList()->Filter()<p></pre>


AUTOMATICALLY LOADING FUNCTIONS ~
<pre>							*autoload-functions*</pre>
When using many or large functions, it's possible to automatically define them
only when they are used.  There are two methods: with an autocommand and with
the "autoload" directory in 'runtimepath'.<p>


Using an autocommand ~<p>

This is introduced in the user manual, section |41.14|.<p>

The autocommand is useful if you have a plugin that is a long Vim script file.
You can define the autocommand and quickly quit the script with `:finish`.
That makes Vim startup faster.  The autocommand should then load the same file
again, setting a variable to skip the `:finish` command.<p>

Use the FuncUndefined autocommand event with a pattern that matches the
function(s) to be defined.  Example: ><p>

<pre>	:au FuncUndefined BufNet* source ~/vim/bufnetfuncs.vim<p></pre>

The file "~/vim/bufnetfuncs.vim" should then define functions that start with
"BufNet".  Also see |FuncUndefined|.<p>


Using an autoload script ~
<pre>							*autoload* *E746*</pre>
This is introduced in the user manual, section |41.15|.<p>

Using a script in the "autoload" directory is simpler, but requires using
exactly the right file name.  A function that can be autoloaded has a name
like this: ><p>

<pre>	:call filename#funcname()<p></pre>

When such a function is called, and it is not defined yet, Vim will search the
"autoload" directories in 'runtimepath' for a script file called
"filename.vim".  For example "~/.vim/autoload/filename.vim".  That file should
then define the function like this: ><p>

<pre>	function filename#funcname()</pre>
<pre>	   echo "Done!"</pre>
<pre>	endfunction<p></pre>

The file name and the name used before the # in the function must match
exactly, and the defined function must have the name exactly as it will be
called.<p>

It is possible to use subdirectories.  Every # in the function name works like
a path separator.  Thus when calling a function: ><p>

<pre>	:call foo#bar#func()<p></pre>

Vim will look for the file "autoload/foo/bar.vim" in 'runtimepath'.<p>

This also works when reading a variable that has not been set yet: ><p>

<pre>	:let l = foo#bar#lvar<p></pre>

However, when the autoload script was already loaded it won't be loaded again
for an unknown variable.<p>

When assigning a value to such a variable nothing special happens.  This can
be used to pass settings to the autoload script before it's loaded: ><p>

<pre>	:let foo#bar#toggle = 1</pre>
<pre>	:call foo#bar#func()<p></pre>

Note that when you make a mistake and call a function that is supposed to be
defined in an autoload script, but the script doesn't actually define the
function, the script will be sourced every time you try to call the function.
And you will get an error message every time.<p>

Also note that if you have two script files, and one calls a function in the
other and vice versa, before the used function is defined, it won't work.
Avoid using the autoload functionality at the toplevel.<p>

Hint: If you distribute a bunch of scripts you can pack them together with the
|vimball| utility.  Also read the user manual |distribute-script|.<p>

* Curly braces names					*curly-braces-names*<p>

In most places where you can use a variable, you can use a "curly braces name"
variable.  This is a regular variable name with one or more expressions
wrapped in braces {} like this: >
<pre>	my_{adjective}_variable<p></pre>

When Vim encounters this, it evaluates the expression inside the braces, puts
that in place of the expression, and re-interprets the whole as a variable
name.  So in the above example, if the variable "adjective" was set to
"noisy", then the reference would be to "my_noisy_variable", whereas if
"adjective" was set to "quiet", then it would be to "my_quiet_variable".<p>

One application for this is to create a set of variables governed by an option
value.  For example, the statement >
<pre>	echo my_{&background}_message<p></pre>

would output the contents of "my_dark_message" or "my_light_message" depending
on the current value of 'background'.<p>

You can use multiple brace pairs: >
<pre>	echo my_{adverb}_{adjective}_message</pre>
..or even nest them: >
<pre>	echo my_{ad{end_of_word}}_message</pre>
where "end_of_word" is either "verb" or "jective".<p>

However, the expression inside the braces must evaluate to a valid single
variable name, e.g. this is invalid: >
<pre>	:let foo='a + b'</pre>
<pre>	:echo c{foo}d</pre>
.. since the result of expansion is "ca + bd", which is not a variable name.<p>

<pre>						*curly-braces-function-names*</pre>
You can call and define functions by an evaluated name in a similar way.
Example: >
<pre>	:let func_end='whizz'</pre>
<pre>	:call my_func_{func_end}(parameter)<p></pre>

This would call the function "my_func_whizz(parameter)".<p>

This does NOT work: >
<pre>  :let i = 3</pre>
<pre>  :let @{i} = ''  " error</pre>
<pre>  :echo @{i}      " error<p></pre>

* Commands						*expression-commands*<p>

:let {var-name} = {expr1}				*:let* *E18*
<pre>			Set internal variable {var-name} to the result of the</pre>
<pre>			expression {expr1}.  The variable will get the type</pre>
<pre>			from the {expr}.  If {var-name} didn't exist yet, it</pre>
<pre>			is created.<p></pre>

:let {var-name}[{idx}] = {expr1}			*E689*
<pre>			Set a list item to the result of the expression</pre>
<pre>			{expr1}.  {var-name} must refer to a list and {idx}</pre>
<pre>			must be a valid index in that list.  For nested list</pre>
<pre>			the index can be repeated.</pre>
<pre>			This cannot be used to add an item to a |List|.</pre>
<pre>			This cannot be used to set a byte in a String.  You</pre>
<pre>			can do that like this: ></pre>
<pre>				:let var = var[0:2] . 'X' . var[4:]</pre>
<			When {var-name} is a |Blob| then {idx} can be the
<pre>			length of the blob, in which case one byte is</pre>
<pre>			appended.<p></pre>

<pre>							*E711* *E719*</pre>
:let {var-name}[{idx1}:{idx2}] = {expr1}		*E708* *E709* *E710*
<pre>			Set a sequence of items in a |List| to the result of</pre>
<pre>			the expression {expr1}, which must be a list with the</pre>
<pre>			correct number of items.</pre>
<pre>			{idx1} can be omitted, zero is used instead.</pre>
<pre>			{idx2} can be omitted, meaning the end of the list.</pre>
<pre>			When the selected range of items is partly past the</pre>
<pre>			end of the list, items will be added.<p></pre>

<pre>			*:let+=* *:let-=* *:letstar=*</pre>
<pre>			*:let/=* *:let%=* *:let.=* *:let..=* *E734* *E985*</pre>
:let {var} += {expr1}	Like ":let {var} = {var} + {expr1}".
:let {var} -= {expr1}	Like ":let {var} = {var} - {expr1}".
:let {var} *= {expr1}	Like ":let {var} = {var} * {expr1}".
:let {var} /= {expr1}	Like ":let {var} = {var} / {expr1}".
:let {var} %= {expr1}	Like ":let {var} = {var} % {expr1}".
:let {var} .= {expr1}	Like ":let {var} = {var} . {expr1}".
:let {var} ..= {expr1}	Like ":let {var} = {var} .. {expr1}".
<pre>			These fail if {var} was not set yet and when the type</pre>
<pre>			of {var} and {expr1} don't fit the operator.</pre>
<pre>			`.=` is not supported with Vim script version 2 and</pre>
<pre>			later, see |vimscript-version|.<p></pre>


:let ${env-name} = {expr1}			*:let-environment* *:let-$*
<pre>			Set environment variable {env-name} to the result of</pre>
<pre>			the expression {expr1}.  The type is always String.<p></pre>

<pre>			On some systems making an environment variable empty</pre>
<pre>			causes it to be deleted.  Many systems do not make a</pre>
<pre>			difference between an environment variable that is not</pre>
<pre>			set and an environment variable that is empty.<p></pre>

:let ${env-name} .= {expr1}
<pre>			Append {expr1} to the environment variable {env-name}.</pre>
<pre>			If the environment variable didn't exist yet this</pre>
<pre>			works like "=".<p></pre>

:let @{reg-name} = {expr1}			*:let-register* *:let-@*
<pre>			Write the result of the expression {expr1} in register</pre>
<pre>			{reg-name}.  {reg-name} must be a single letter, and</pre>
<pre>			must be the name of a writable register (see</pre>
<pre>			|registers|).  "@@" can be used for the unnamed</pre>
<pre>			register, "@/" for the search pattern.</pre>
<pre>			If the result of {expr1} ends in a <CR> or <NL>, the</pre>
<pre>			register will be linewise, otherwise it will be set to</pre>
<pre>			characterwise.</pre>
<pre>			This can be used to clear the last search pattern: ></pre>
<pre>				:let @/ = ""</pre>
<			This is different from searching for an empty string,
<pre>			that would match everywhere.<p></pre>

:let @{reg-name} .= {expr1}
<pre>			Append {expr1} to register {reg-name}.  If the</pre>
<pre>			register was empty it's like setting it to {expr1}.<p></pre>

:let &{option-name} = {expr1}			*:let-option* *:let-&*
<pre>			Set option {option-name} to the result of the</pre>
<pre>			expression {expr1}.  A String or Number value is</pre>
<pre>			always converted to the type of the option.</pre>
<pre>			For an option local to a window or buffer the effect</pre>
<pre>			is just like using the |:set| command: both the local</pre>
<pre>			value and the global value are changed.</pre>
<pre>			Example: ></pre>
<pre>				:let &path = &path . ',/usr/local/include'</pre>
<			This also works for terminal codes in the form t_xx.
<pre>			But only for alphanumerical names.  Example: ></pre>
<pre>				:let &t_k1 = "\<Esc>[234;"</pre>
<			When the code does not exist yet it will be created as
<pre>			a terminal key code, there is no error.<p></pre>

:let &{option-name} .= {expr1}
<pre>			For a string option: Append {expr1} to the value.</pre>
<pre>			Does not insert a comma like |:set+=|.<p></pre>

:let &{option-name} += {expr1}
:let &{option-name} -= {expr1}
<pre>			For a number or boolean option: Add or subtract</pre>
<pre>			{expr1}.<p></pre>

:let &l:{option-name} = {expr1}
:let &l:{option-name} .= {expr1}
:let &l:{option-name} += {expr1}
:let &l:{option-name} -= {expr1}
<pre>			Like above, but only set the local value of an option</pre>
<pre>			(if there is one).  Works like |:setlocal|.<p></pre>

:let &g:{option-name} = {expr1}
:let &g:{option-name} .= {expr1}
:let &g:{option-name} += {expr1}
:let &g:{option-name} -= {expr1}
<pre>			Like above, but only set the global value of an option</pre>
<pre>			(if there is one).  Works like |:setglobal|.<p></pre>

:let [{name1}, {name2}, ...] = {expr1}		*:let-unpack* *E687* *E688*
<pre>			{expr1} must evaluate to a |List|.  The first item in</pre>
<pre>			the list is assigned to {name1}, the second item to</pre>
<pre>			{name2}, etc.</pre>
<pre>			The number of names must match the number of items in</pre>
<pre>			the |List|.</pre>
<pre>			Each name can be one of the items of the ":let"</pre>
<pre>			command as mentioned above.</pre>
<pre>			Example: ></pre>
<pre>				:let [s, item] = GetItem(s)</pre>
<			Detail: {expr1} is evaluated first, then the
<pre>			assignments are done in sequence.  This matters if</pre>
<pre>			{name2} depends on {name1}.  Example: ></pre>
<pre>				:let x = [0, 1]</pre>
<pre>				:let i = 0</pre>
<pre>				:let [i, x[i]] = [1, 2]</pre>
<pre>				:echo x</pre>
<			The result is [0, 2].<p>

:let [{name1}, {name2}, ...] .= {expr1}
:let [{name1}, {name2}, ...] += {expr1}
:let [{name1}, {name2}, ...] -= {expr1}
<pre>			Like above, but append/add/subtract the value for each</pre>
<pre>			|List| item.<p></pre>

:let [{name}, ..., ; {lastname}] = {expr1}
<pre>			Like |:let-unpack| above, but the |List| may have more</pre>
<pre>			items than there are names.  A list of the remaining</pre>
<pre>			items is assigned to {lastname}.  If there are no</pre>
<pre>			remaining items {lastname} is set to an empty list.</pre>
<pre>			Example: ></pre>
<pre>				:let [a, b; rest] = ["aval", "bval", 3, 4]</pre>
<
:let [{name}, ..., ; {lastname}] .= {expr1}
:let [{name}, ..., ; {lastname}] += {expr1}
:let [{name}, ..., ; {lastname}] -= {expr1}
<pre>			Like above, but append/add/subtract the value for each</pre>
<pre>			|List| item.<p></pre>

<pre>						*:let=<<* *:let-heredoc*</pre>
<pre>						*E990* *E991* *E172* *E221*</pre>
:let {var-name} =<< [trim] {endmarker}
text...
text...
{endmarker}
<pre>			Set internal variable {var-name} to a List containing</pre>
<pre>			the lines of text bounded by the string {endmarker}.</pre>
<pre>			{endmarker} must not contain white space.</pre>
<pre>			{endmarker} cannot start with a lower case character.</pre>
<pre>			The last line should end only with the {endmarker}</pre>
<pre>			string without any other character.  Watch out for</pre>
<pre>			white space after {endmarker}!<p></pre>

<pre>			Without "trim" any white space characters in the lines</pre>
<pre>			of text are preserved.  If "trim" is specified before</pre>
<pre>			{endmarker}, then indentation is stripped so you can</pre>
<pre>			do: ></pre>
<pre>				let text =<< trim END</pre>
<pre>				   if ok</pre>
<pre>				     echo 'done'</pre>
<pre>				   endif</pre>
<pre>				END</pre>
<			Results in: ["if ok", "  echo 'done'", "endif"]
<pre>			The marker must line up with "let" and the indentation</pre>
<pre>			of the first line is removed from all the text lines.</pre>
<pre>			Specifically: all the leading indentation exactly</pre>
<pre>			matching the leading indentation of the first</pre>
<pre>			non-empty text line is stripped from the input lines.</pre>
<pre>			All leading indentation exactly matching the leading</pre>
<pre>			indentation before `let` is stripped from the line</pre>
<pre>			containing {endmarker}.  Note that the difference</pre>
<pre>			between space and tab matters here.<p></pre>

<pre>			If {var-name} didn't exist yet, it is created.</pre>
<pre>			Cannot be followed by another command, but can be</pre>
<pre>			followed by a comment.<p></pre>

<pre>			To avoid line continuation to be applied, consider</pre>
<pre>			adding 'C' to 'cpoptions': ></pre>
<pre>				set cpo+=C</pre>
<pre>				let var =<< END</pre>
<pre>				   \ leading backslash</pre>
<pre>				END</pre>
<pre>				set cpo-=C</pre>
<
<pre>			Examples: ></pre>
<pre>				let var1 =<< END</pre>
<pre>				Sample text 1</pre>
<pre>				    Sample text 2</pre>
<pre>				Sample text 3</pre>
<pre>				END<p></pre>

<pre>				let data =<< trim DATA</pre>
<pre>					1 2 3 4</pre>
<pre>					5 6 7 8</pre>
<pre>				DATA</pre>
<
<pre>								*E121*</pre>
:let {var-name}	..	List the value of variable {var-name}.  Multiple
<pre>			variable names may be given.  Special names recognized</pre>
<pre>			here:				*E738*</pre>
<pre>			  g:	global variables</pre>
<pre>			  b:	local buffer variables</pre>
<pre>			  w:	local window variables</pre>
<pre>			  t:	local tab page variables</pre>
<pre>			  s:	script-local variables</pre>
<pre>			  l:	local function variables</pre>
<pre>			  v:	Vim variables.<p></pre>

:let			List the values of all variables.  The type of the
<pre>			variable is indicated before the value:</pre>
<pre>			    <nothing>	String</pre>
<pre>				#	Number</pre>
<pre>				*	Funcref<p></pre>

:unl[et][!] {name} ...				*:unlet* *:unl* *E108* *E795*
<pre>			Remove the internal variable {name}.  Several variable</pre>
<pre>			names can be given, they are all removed.  The name</pre>
<pre>			may also be a |List| or |Dictionary| item.</pre>
<pre>			With [!] no error message is given for non-existing</pre>
<pre>			variables.</pre>
<pre>			One or more items from a |List| can be removed: ></pre>
<pre>				:unlet list[3]	  " remove fourth item</pre>
<pre>				:unlet list[3:]   " remove fourth item to last</pre>
<			One item from a |Dictionary| can be removed at a time: >
<pre>				:unlet dict['two']</pre>
<pre>				:unlet dict.two</pre>
<			This is especially useful to clean up used global
<pre>			variables and script-local variables (these are not</pre>
<pre>			deleted when the script ends).  Function-local</pre>
<pre>			variables are automatically deleted when the function</pre>
<pre>			ends.<p></pre>

:unl[et] ${env-name} ...			*:unlet-environment* *:unlet-$*
<pre>			Remove environment variable {env-name}.</pre>
<pre>			Can mix {name} and ${env-name} in one :unlet command.</pre>
<pre>			No error message is given for a non-existing</pre>
<pre>			variable, also without !.</pre>
<pre>			If the system does not support deleting an environment</pre>
<pre>			variable, it is made empty.<p></pre>

<pre>						*:cons* *:const*</pre>
:cons[t] {var-name} = {expr1}
:cons[t] [{name1}, {name2}, ...] = {expr1}
:cons[t] [{name}, ..., ; {lastname}] = {expr1}
:cons[t] {var-name} =<< [trim] {marker}
text...
text...
{marker}
<pre>			Similar to |:let|, but additionally lock the variable</pre>
<pre>			after setting the value.  This is the same as locking</pre>
<pre>			the variable with |:lockvar| just after |:let|, thus: ></pre>
<pre>				:const x = 1</pre>
<			is equivalent to: >
<pre>				:let x = 1</pre>
<pre>				:lockvar 1 x</pre>
<			This is useful if you want to make sure the variable
<pre>			is not modified.</pre>
<pre>							*E995*</pre>
<pre>			|:const| does not allow to for changing a variable: ></pre>
<pre>				:let x = 1</pre>
<pre>				:const x = 2  " Error!</pre>
<							*E996*
<pre>			Note that environment variables, option values and</pre>
<pre>			register values cannot be used here, since they cannot</pre>
<pre>			be locked.<p></pre>

:cons[t]
:cons[t] {var-name}
<pre>			If no argument is given or only {var-name} is given,</pre>
<pre>			the behavior is the same as |:let|.<p></pre>

:lockv[ar][!] [depth] {name} ...			*:lockvar* *:lockv*
<pre>			Lock the internal variable {name}.  Locking means that</pre>
<pre>			it can no longer be changed (until it is unlocked).</pre>
<pre>			A locked variable can be deleted: ></pre>
<pre>				:lockvar v</pre>
<pre>				:let v = 'asdf'		" fails!</pre>
<pre>				:unlet v</pre>
<							*E741* *E940*
<pre>			If you try to change a locked variable you get an</pre>
<pre>			error message: "E741: Value is locked: {name}".</pre>
<pre>			If you try to lock or unlock a built-in variable you</pre>
<pre>			get an error message: "E940: Cannot lock or unlock</pre>
<pre>			variable {name}".<p></pre>

<pre>			[depth] is relevant when locking a |List| or</pre>
<pre>			|Dictionary|.  It specifies how deep the locking goes:</pre>
<pre>				1	Lock the |List| or |Dictionary| itself,</pre>
<pre>					cannot add or remove items, but can</pre>
<pre>					still change their values.</pre>
<pre>				2	Also lock the values, cannot change</pre>
<pre>					the items.  If an item is a |List| or</pre>
<pre>					|Dictionary|, cannot add or remove</pre>
<pre>					items, but can still change the</pre>
<pre>					values.</pre>
<pre>				3	Like 2 but for the |List| /</pre>
<pre>					|Dictionary| in the |List| /</pre>
<pre>					|Dictionary|, one level deeper.</pre>
<pre>			The default [depth] is 2, thus when {name} is a |List|</pre>
<pre>			or |Dictionary| the values cannot be changed.</pre>
<pre>								*E743*</pre>
<pre>			For unlimited depth use [!] and omit [depth].</pre>
<pre>			However, there is a maximum depth of 100 to catch</pre>
<pre>			loops.<p></pre>

<pre>			Note that when two variables refer to the same |List|</pre>
<pre>			and you lock one of them, the |List| will also be</pre>
<pre>			locked when used through the other variable.</pre>
<pre>			Example: ></pre>
<pre>				:let l = [0, 1, 2, 3]</pre>
<pre>				:let cl = l</pre>
<pre>				:lockvar l</pre>
<pre>				:let cl[1] = 99		" won't work!</pre>
<			You may want to make a copy of a list to avoid this.
<pre>			See |deepcopy()|.<p></pre>


:unlo[ckvar][!] [depth] {name} ...			*:unlockvar* *:unlo*
<pre>			Unlock the internal variable {name}.  Does the</pre>
<pre>			opposite of |:lockvar|.<p></pre>

:if {expr1}			*:if* *:end* *:endif* *:en* *E171* *E579* *E580*
:en[dif]		Execute the commands until the next matching ":else"
<pre>			or ":endif" if {expr1} evaluates to non-zero.<p></pre>

<pre>			From Vim version 4.5 until 5.0, every Ex command in</pre>
<pre>			between the ":if" and ":endif" is ignored.  These two</pre>
<pre>			commands were just to allow for future expansions in a</pre>
<pre>			backward compatible way.  Nesting was allowed.  Note</pre>
<pre>			that any ":else" or ":elseif" was ignored, the "else"</pre>
<pre>			part was not executed either.<p></pre>

<pre>			You can use this to remain compatible with older</pre>
<pre>			versions: ></pre>
<pre>				:if version >= 500</pre>
<pre>				:  version-5-specific-commands</pre>
<pre>				:endif</pre>
<			The commands still need to be parsed to find the
<pre>			"endif".  Sometimes an older Vim has a problem with a</pre>
<pre>			new command.  For example, ":silent" is recognized as</pre>
<pre>			a ":substitute" command.  In that case ":execute" can</pre>
<pre>			avoid problems: ></pre>
<pre>				:if version >= 600</pre>
<pre>				:  execute "silent 1,$delete"</pre>
<pre>				:endif</pre>
<
<pre>			NOTE: The ":append" and ":insert" commands don't work</pre>
<pre>			properly in between ":if" and ":endif".<p></pre>

<pre>						*:else* *:el* *E581* *E583*</pre>
:el[se]			Execute the commands until the next matching ":else"
<pre>			or ":endif" if they previously were not being</pre>
<pre>			executed.<p></pre>

<pre>					*:elseif* *:elsei* *E582* *E584*</pre>
:elsei[f] {expr1}	Short for ":else" ":if", with the addition that there
<pre>			is no extra ":endif".<p></pre>

:wh[ile] {expr1}			*:while* *:endwhile* *:wh* *:endw*
<pre>						*E170* *E585* *E588* *E733*</pre>
:endw[hile]		Repeat the commands between ":while" and ":endwhile",
<pre>			as long as {expr1} evaluates to non-zero.</pre>
<pre>			When an error is detected from a command inside the</pre>
<pre>			loop, execution continues after the "endwhile".</pre>
<pre>			Example: ></pre>
<pre>				:let lnum = 1</pre>
<pre>				:while lnum <= line("$")</pre>
<pre>				   :call FixLine(lnum)</pre>
<pre>				   :let lnum = lnum + 1</pre>
<pre>				:endwhile</pre>
<
<pre>			NOTE: The ":append" and ":insert" commands don't work</pre>
<pre>			properly inside a ":while" and ":for" loop.<p></pre>

:for {var} in {object}					*:for* *E690* *E732*
:endfo[r]						*:endfo* *:endfor*
<pre>			Repeat the commands between ":for" and ":endfor" for</pre>
<pre>			each item in {object}.  {object} can be a |List| or</pre>
<pre>			a |Blob|.  Variable {var} is set to the value of each</pre>
<pre>			item.  When an error is detected for a command inside</pre>
<pre>			the loop, execution continues after the "endfor".</pre>
<pre>			Changing {object} inside the loop affects what items</pre>
<pre>			are used.  Make a copy if this is unwanted: ></pre>
<pre>				:for item in copy(mylist)</pre>
<
<pre>			When {object} is a |List| and not making a copy, Vim</pre>
<pre>			stores a reference to the next item in the |List|</pre>
<pre>			before executing the commands with the current item.</pre>
<pre>			Thus the current item can be removed without effect.</pre>
<pre>			Removing any later item means it will not be found.</pre>
<pre>			Thus the following example works (an inefficient way</pre>
<pre>			to make a |List| empty): ></pre>
<pre>				for item in mylist</pre>
<pre>				   call remove(mylist, 0)</pre>
<pre>				endfor</pre>
<			Note that reordering the |List| (e.g., with sort() or
<pre>			reverse()) may have unexpected effects.<p></pre>

<pre>			When {object} is a |Blob|, Vim always makes a copy to</pre>
<pre>			iterate over.  Unlike with |List|, modifying the</pre>
<pre>			|Blob| does not affect the iteration.<p></pre>

:for [{var1}, {var2}, ...] in {listlist}
:endfo[r]
<pre>			Like ":for" above, but each item in {listlist} must be</pre>
<pre>			a list, of which each item is assigned to {var1},</pre>
<pre>			{var2}, etc.  Example: ></pre>
<pre>				:for [lnum, col] in [[1, 3], [2, 5], [3, 8]]</pre>
<pre>				   :echo getline(lnum)[col]</pre>
<pre>				:endfor</pre>
<
<pre>						*:continue* *:con* *E586*</pre>
:con[tinue]		When used inside a ":while" or ":for" loop, jumps back
<pre>			to the start of the loop.</pre>
<pre>			If it is used after a |:try| inside the loop but</pre>
<pre>			before the matching |:finally| (if present), the</pre>
<pre>			commands following the ":finally" up to the matching</pre>
<pre>			|:endtry| are executed first.  This process applies to</pre>
<pre>			all nested ":try"s inside the loop.  The outermost</pre>
<pre>			":endtry" then jumps back to the start of the loop.<p></pre>

<pre>						*:break* *:brea* *E587*</pre>
:brea[k]		When used inside a ":while" or ":for" loop, skips to
<pre>			the command after the matching ":endwhile" or</pre>
<pre>			":endfor".</pre>
<pre>			If it is used after a |:try| inside the loop but</pre>
<pre>			before the matching |:finally| (if present), the</pre>
<pre>			commands following the ":finally" up to the matching</pre>
<pre>			|:endtry| are executed first.  This process applies to</pre>
<pre>			all nested ":try"s inside the loop.  The outermost</pre>
<pre>			":endtry" then jumps to the command after the loop.<p></pre>

:try				*:try* *:endt* *:endtry* *E600* *E601* *E602*
:endt[ry]		Change the error handling for the commands between
<pre>			":try" and ":endtry" including everything being</pre>
<pre>			executed across ":source" commands, function calls,</pre>
<pre>			or autocommand invocations.<p></pre>

<pre>			When an error or interrupt is detected and there is</pre>
<pre>			a |:finally| command following, execution continues</pre>
<pre>			after the ":finally".  Otherwise, or when the</pre>
<pre>			":endtry" is reached thereafter, the next</pre>
<pre>			(dynamically) surrounding ":try" is checked for</pre>
<pre>			a corresponding ":finally" etc.  Then the script</pre>
<pre>			processing is terminated.  (Whether a function</pre>
<pre>			definition has an "abort" argument does not matter.)</pre>
<pre>			Example: ></pre>
<pre>		:try | edit too much | finally | echo "cleanup" | endtry</pre>
<pre>		:echo "impossible"	" not reached, script terminated above</pre>
<
<pre>			Moreover, an error or interrupt (dynamically) inside</pre>
<pre>			":try" and ":endtry" is converted to an exception.  It</pre>
<pre>			can be caught as if it were thrown by a |:throw|</pre>
<pre>			command (see |:catch|).  In this case, the script</pre>
<pre>			processing is not terminated.<p></pre>

<pre>			The value "Vim:Interrupt" is used for an interrupt</pre>
<pre>			exception.  An error in a Vim command is converted</pre>
<pre>			to a value of the form "Vim({command}):{errmsg}",</pre>
<pre>			other errors are converted to a value of the form</pre>
<pre>			"Vim:{errmsg}".  {command} is the full command name,</pre>
<pre>			and {errmsg} is the message that is displayed if the</pre>
<pre>			error exception is not caught, always beginning with</pre>
<pre>			the error number.</pre>
<pre>			Examples: ></pre>
<pre>		:try | sleep 100 | catch /^Vim:Interrupt$/ | endtry</pre>
<pre>		:try | edit | catch /^Vim(edit):E\d\+/ | echo "error" | endtry</pre>
<
<pre>					*:cat* *:catch* *E603* *E604* *E605*</pre>
:cat[ch] /{pattern}/	The following commands until the next |:catch|,
<pre>			|:finally|, or |:endtry| that belongs to the same</pre>
<pre>			|:try| as the ":catch" are executed when an exception</pre>
<pre>			matching {pattern} is being thrown and has not yet</pre>
<pre>			been caught by a previous ":catch".  Otherwise, these</pre>
<pre>			commands are skipped.</pre>
<pre>			When {pattern} is omitted all errors are caught.</pre>
<pre>			Examples: ></pre>
<pre>		:catch /^Vim:Interrupt$/	 " catch interrupts (CTRL-C)</pre>
<pre>		:catch /^Vim\%((\a\+)\)\=:E/	 " catch all Vim errors</pre>
<pre>		:catch /^Vim\%((\a\+)\)\=:/	 " catch errors and interrupts</pre>
<pre>		:catch /^Vim(write):/		 " catch all errors in :write</pre>
<pre>		:catch /^Vim\%((\a\+)\)\=:E123:/ " catch error E123</pre>
<pre>		:catch /my-exception/		 " catch user exception</pre>
<pre>		:catch /.*/			 " catch everything</pre>
<pre>		:catch				 " same as /.*/</pre>
<
<pre>			Another character can be used instead of / around the</pre>
<pre>			{pattern}, so long as it does not have a special</pre>
<pre>			meaning (e.g., '|' or '"') and doesn't occur inside</pre>
<pre>			{pattern}.</pre>
<pre>			Information about the exception is available in</pre>
<pre>			|v:exception|.  Also see |throw-variables|.</pre>
<pre>			NOTE: It is not reliable to ":catch" the TEXT of</pre>
<pre>			an error message because it may vary in different</pre>
<pre>			locales.<p></pre>

<pre>					*:fina* *:finally* *E606* *E607*</pre>
:fina[lly]		The following commands until the matching |:endtry|
<pre>			are executed whenever the part between the matching</pre>
<pre>			|:try| and the ":finally" is left:  either by falling</pre>
<pre>			through to the ":finally" or by a |:continue|,</pre>
<pre>			|:break|, |:finish|, or |:return|, or by an error or</pre>
<pre>			interrupt or exception (see |:throw|).<p></pre>

<pre>							*:th* *:throw* *E608*</pre>
:th[row] {expr1}	The {expr1} is evaluated and thrown as an exception.
<pre>			If the ":throw" is used after a |:try| but before the</pre>
<pre>			first corresponding |:catch|, commands are skipped</pre>
<pre>			until the first ":catch" matching {expr1} is reached.</pre>
<pre>			If there is no such ":catch" or if the ":throw" is</pre>
<pre>			used after a ":catch" but before the |:finally|, the</pre>
<pre>			commands following the ":finally" (if present) up to</pre>
<pre>			the matching |:endtry| are executed.  If the ":throw"</pre>
<pre>			is after the ":finally", commands up to the ":endtry"</pre>
<pre>			are skipped.  At the ":endtry", this process applies</pre>
<pre>			again for the next dynamically surrounding ":try"</pre>
<pre>			(which may be found in a calling function or sourcing</pre>
<pre>			script), until a matching ":catch" has been found.</pre>
<pre>			If the exception is not caught, the command processing</pre>
<pre>			is terminated.</pre>
<pre>			Example: ></pre>
<pre>		:try | throw "oops" | catch /^oo/ | echo "caught" | endtry</pre>
<			Note that "catch" may need to be on a separate line
<pre>			for when an error causes the parsing to skip the whole</pre>
<pre>			line and not see the "|" that separates the commands.<p></pre>

<pre>							*:ec* *:echo*</pre>
:ec[ho] {expr1} ..	Echoes each {expr1}, with a space in between.  The
<pre>			first {expr1} starts on a new line.</pre>
<pre>			Also see |:comment|.</pre>
<pre>			Use "\n" to start a new line.  Use "\r" to move the</pre>
<pre>			cursor to the first column.</pre>
<pre>			Uses the highlighting set by the |:echohl| command.</pre>
<pre>			Cannot be followed by a comment.</pre>
<pre>			Example: ></pre>
<pre>		:echo "the value of 'shell' is" &shell</pre>
<							*:echo-redraw*
<pre>			A later redraw may make the message disappear again.</pre>
<pre>			And since Vim mostly postpones redrawing until it's</pre>
<pre>			finished with a sequence of commands this happens</pre>
<pre>			quite often.  To avoid that a command from before the</pre>
<pre>			":echo" causes a redraw afterwards (redraws are often</pre>
<pre>			postponed until you type something), force a redraw</pre>
<pre>			with the |:redraw| command.  Example: ></pre>
<pre>		:new | redraw | echo "there is a new window"</pre>
<
<pre>							*:echon*</pre>
:echon {expr1} ..	Echoes each {expr1}, without anything added.  Also see
<pre>			|:comment|.</pre>
<pre>			Uses the highlighting set by the |:echohl| command.</pre>
<pre>			Cannot be followed by a comment.</pre>
<pre>			Example: ></pre>
<pre>				:echon "the value of 'shell' is " &shell</pre>
<
<pre>			Note the difference between using ":echo", which is a</pre>
<pre>			Vim command, and ":!echo", which is an external shell</pre>
<pre>			command: ></pre>
<pre>		:!echo %		--> filename</pre>
<			The arguments of ":!" are expanded, see |:_%|. >
<pre>		:!echo "%"		--> filename or "filename"</pre>
<			Like the previous example.  Whether you see the double
<pre>			quotes or not depends on your 'shell'. ></pre>
<pre>		:echo %			--> nothing</pre>
<			The '%' is an illegal character in an expression. >
<pre>		:echo "%"		--> %</pre>
<			This just echoes the '%' character. >
<pre>		:echo expand("%")	--> filename</pre>
<			This calls the expand() function to expand the '%'.<p>

<pre>							*:echoh* *:echohl*</pre>
:echoh[l] {name}	Use the highlight group {name} for the following
<pre>			|:echo|, |:echon| and |:echomsg| commands.  Also used</pre>
<pre>			for the |input()| prompt.  Example: ></pre>
<pre>		:echohl WarningMsg | echo "Don't panic!" | echohl None</pre>
<			Don't forget to set the group back to "None",
<pre>			otherwise all following echo's will be highlighted.<p></pre>

<pre>							*:echom* *:echomsg*</pre>
:echom[sg] {expr1} ..	Echo the expression(s) as a true message, saving the
<pre>			message in the |message-history|.</pre>
<pre>			Spaces are placed between the arguments as with the</pre>
<pre>			|:echo| command.  But unprintable characters are</pre>
<pre>			displayed, not interpreted.</pre>
<pre>			The parsing works slightly different from |:echo|,</pre>
<pre>			more like |:execute|.  All the expressions are first</pre>
<pre>			evaluated and concatenated before echoing anything.</pre>
<pre>			If expressions does not evaluate to a Number or</pre>
<pre>			String, string() is used to turn it into a string.</pre>
<pre>			Uses the highlighting set by the |:echohl| command.</pre>
<pre>			Example: ></pre>
<pre>		:echomsg "It's a Zizzer Zazzer Zuzz, as you can plainly see."</pre>
<			See |:echo-redraw| to avoid the message disappearing
<pre>			when the screen is redrawn.</pre>
<pre>							*:echoe* *:echoerr*</pre>
:echoe[rr] {expr1} ..	Echo the expression(s) as an error message, saving the
<pre>			message in the |message-history|.  When used in a</pre>
<pre>			script or function the line number will be added.</pre>
<pre>			Spaces are placed between the arguments as with the</pre>
<pre>			|:echomsg| command.  When used inside a try conditional,</pre>
<pre>			the message is raised as an error exception instead</pre>
<pre>			(see |try-echoerr|).</pre>
<pre>			Example: ></pre>
<pre>		:echoerr "This script just failed!"</pre>
<			If you just want a highlighted message use |:echohl|.
<pre>			And to get a beep: ></pre>
<pre>		:exe "normal \<Esc>"</pre>
<
<pre>							*:eval*</pre>
:eval {expr}		Evaluate {expr} and discard the result.  Example: >
<pre>				:eval Getlist()->Filter()->append('$')<p></pre>

<			The expression is supposed to have a side effect,
<pre>			since the resulting value is not used.  In the example</pre>
<pre>			the `append()` call appends the List with text to the</pre>
<pre>			buffer.  This is similar to `:call` but works with any</pre>
<pre>			expression.<p></pre>

<pre>			The command can be shortened to `:ev` or `:eva`, but</pre>
<pre>			these are hard to recognize and therefore not to be</pre>
<pre>			used.<p></pre>


<pre>							*:exe* *:execute*</pre>
:exe[cute] {expr1} ..	Executes the string that results from the evaluation
<pre>			of {expr1} as an Ex command.</pre>
<pre>			Multiple arguments are concatenated, with a space in</pre>
<pre>			between.  To avoid the extra space use the "."</pre>
<pre>			operator to concatenate strings into one argument.</pre>
<pre>			{expr1} is used as the processed command, command line</pre>
<pre>			editing keys are not recognized.</pre>
<pre>			Cannot be followed by a comment.</pre>
<pre>			Examples: ></pre>
<pre>		:execute "buffer" nextbuf</pre>
<pre>		:execute "normal" count . "w"</pre>
<
<pre>			":execute" can be used to append a command to commands</pre>
<pre>			that don't accept a '|'.  Example: ></pre>
<pre>		:execute '!ls' | echo "theend"<p></pre>

<			":execute" is also a nice way to avoid having to type
<pre>			control characters in a Vim script for a ":normal"</pre>
<pre>			command: ></pre>
<pre>		:execute "normal ixxx\<Esc>"</pre>
<			This has an <Esc> character, see |expr-string|.<p>

<pre>			Be careful to correctly escape special characters in</pre>
<pre>			file names.  The |fnameescape()| function can be used</pre>
<pre>			for Vim commands, |shellescape()| for |:!| commands.</pre>
<pre>			Examples: ></pre>
<pre>		:execute "e " . fnameescape(filename)</pre>
<pre>		:execute "!ls " . shellescape(filename, 1)</pre>
<
<pre>			Note: The executed string may be any command-line, but</pre>
<pre>			starting or ending "if", "while" and "for" does not</pre>
<pre>			always work, because when commands are skipped the</pre>
<pre>			":execute" is not evaluated and Vim loses track of</pre>
<pre>			where blocks start and end.  Also "break" and</pre>
<pre>			"continue" should not be inside ":execute".</pre>
<pre>			This example does not work, because the ":execute" is</pre>
<pre>			not evaluated and Vim does not see the "while", and</pre>
<pre>			gives an error for finding an ":endwhile": ></pre>
<pre>		:if 0</pre>
<pre>		: execute 'while i > 5'</pre>
<pre>		:  echo "test"</pre>
<pre>		: endwhile</pre>
<pre>		:endif</pre>
<
<pre>			It is allowed to have a "while" or "if" command</pre>
<pre>			completely in the executed string: ></pre>
<pre>		:execute 'while i < 5 | echo i | let i = i + 1 | endwhile'</pre>
<<p>

<pre>							*:exe-comment*</pre>
<pre>			":execute", ":echo" and ":echon" cannot be followed by</pre>
<pre>			a comment directly, because they see the '"' as the</pre>
<pre>			start of a string.  But, you can use '|' followed by a</pre>
<pre>			comment.  Example: ></pre>
<pre>		:echo "foo" | "this is a comment<p></pre>

* Exception handling					*exception-handling*<p>

The Vim script language comprises an exception handling feature.  This section
explains how it can be used in a Vim script.<p>

Exceptions may be raised by Vim on an error or on interrupt, see
|catch-errors| and |catch-interrupt|.  You can also explicitly throw an
exception by using the ":throw" command, see |throw-catch|.<p>


TRY CONDITIONALS					*try-conditionals*<p>

Exceptions can be caught or can cause cleanup code to be executed.  You can
use a try conditional to specify catch clauses (that catch exceptions) and/or
a finally clause (to be executed for cleanup).
<pre>   A try conditional begins with a |:try| command and ends at the matching</pre>
|:endtry| command.  In between, you can use a |:catch| command to start
a catch clause, or a |:finally| command to start a finally clause.  There may
be none or multiple catch clauses, but there is at most one finally clause,
which must not be followed by any catch clauses.  The lines before the catch
clauses and the finally clause is called a try block. ><p>

<pre>     :try</pre>
<pre>     :	...</pre>
<pre>     :	...				TRY BLOCK</pre>
<pre>     :	...</pre>
<pre>     :catch /{pattern}/</pre>
<pre>     :	...</pre>
<pre>     :	...				CATCH CLAUSE</pre>
<pre>     :	...</pre>
<pre>     :catch /{pattern}/</pre>
<pre>     :	...</pre>
<pre>     :	...				CATCH CLAUSE</pre>
<pre>     :	...</pre>
<pre>     :finally</pre>
<pre>     :	...</pre>
<pre>     :	...				FINALLY CLAUSE</pre>
<pre>     :	...</pre>
<pre>     :endtry<p></pre>

The try conditional allows to watch code for exceptions and to take the
appropriate actions.  Exceptions from the try block may be caught.  Exceptions
from the try block and also the catch clauses may cause cleanup actions.
<pre>   When no exception is thrown during execution of the try block, the control</pre>
is transferred to the finally clause, if present.  After its execution, the
script continues with the line following the ":endtry".
<pre>   When an exception occurs during execution of the try block, the remaining</pre>
lines in the try block are skipped.  The exception is matched against the
patterns specified as arguments to the ":catch" commands.  The catch clause
after the first matching ":catch" is taken, other catch clauses are not
executed.  The catch clause ends when the next ":catch", ":finally", or
":endtry" command is reached - whatever is first.  Then, the finally clause
(if present) is executed.  When the ":endtry" is reached, the script execution
continues in the following line as usual.
<pre>   When an exception that does not match any of the patterns specified by the</pre>
":catch" commands is thrown in the try block, the exception is not caught by
that try conditional and none of the catch clauses is executed.  Only the
finally clause, if present, is taken.  The exception pends during execution of
the finally clause.  It is resumed at the ":endtry", so that commands after
the ":endtry" are not executed and the exception might be caught elsewhere,
see |try-nesting|.
<pre>   When during execution of a catch clause another exception is thrown, the</pre>
remaining lines in that catch clause are not executed.  The new exception is
not matched against the patterns in any of the ":catch" commands of the same
try conditional and none of its catch clauses is taken.  If there is, however,
a finally clause, it is executed, and the exception pends during its
execution.  The commands following the ":endtry" are not executed.  The new
exception might, however, be caught elsewhere, see |try-nesting|.
<pre>   When during execution of the finally clause (if present) an exception is</pre>
thrown, the remaining lines in the finally clause are skipped.  If the finally
clause has been taken because of an exception from the try block or one of the
catch clauses, the original (pending) exception is discarded.  The commands
following the ":endtry" are not executed, and the exception from the finally
clause is propagated and can be caught elsewhere, see |try-nesting|.<p>

The finally clause is also executed, when a ":break" or ":continue" for
a ":while" loop enclosing the complete try conditional is executed from the
try block or a catch clause.  Or when a ":return" or ":finish" is executed
from the try block or a catch clause of a try conditional in a function or
sourced script, respectively.  The ":break", ":continue", ":return", or
":finish" pends during execution of the finally clause and is resumed when the
":endtry" is reached.  It is, however, discarded when an exception is thrown
from the finally clause.
<pre>   When a ":break" or ":continue" for a ":while" loop enclosing the complete</pre>
try conditional or when a ":return" or ":finish" is encountered in the finally
clause, the rest of the finally clause is skipped, and the ":break",
":continue", ":return" or ":finish" is executed as usual.  If the finally
clause has been taken because of an exception or an earlier ":break",
":continue", ":return", or ":finish" from the try block or a catch clause,
this pending exception or command is discarded.<p>

For examples see |throw-catch| and |try-finally|.<p>


NESTING	OF TRY CONDITIONALS				*try-nesting*<p>

Try conditionals can be nested arbitrarily.  That is, a complete try
conditional can be put into the try block, a catch clause, or the finally
clause of another try conditional.  If the inner try conditional does not
catch an exception thrown in its try block or throws a new exception from one
of its catch clauses or its finally clause, the outer try conditional is
checked according to the rules above.  If the inner try conditional is in the
try block of the outer try conditional, its catch clauses are checked, but
otherwise only the finally clause is executed.  It does not matter for
nesting, whether the inner try conditional is directly contained in the outer
one, or whether the outer one sources a script or calls a function containing
the inner try conditional.<p>

When none of the active try conditionals catches an exception, just their
finally clauses are executed.  Thereafter, the script processing terminates.
An error message is displayed in case of an uncaught exception explicitly
thrown by a ":throw" command.  For uncaught error and interrupt exceptions
implicitly raised by Vim, the error message(s) or interrupt message are shown
as usual.<p>

For examples see |throw-catch|.<p>


EXAMINING EXCEPTION HANDLING CODE			*except-examine*<p>

Exception handling code can get tricky.  If you are in doubt what happens, set
'verbose' to 13 or use the ":13verbose" command modifier when sourcing your
script file.  Then you see when an exception is thrown, discarded, caught, or
finished.  When using a verbosity level of at least 14, things pending in
a finally clause are also shown.  This information is also given in debug mode
(see |debug-scripts|).<p>


THROWING AND CATCHING EXCEPTIONS			*throw-catch*<p>

You can throw any number or string as an exception.  Use the |:throw| command
and pass the value to be thrown as argument: >
<pre>	:throw 4711</pre>
<pre>	:throw "string"</pre>
<							*throw-expression*
You can also specify an expression argument.  The expression is then evaluated
first, and the result is thrown: >
<pre>	:throw 4705 + strlen("string")</pre>
<pre>	:throw strpart("strings", 0, 6)<p></pre>

An exception might be thrown during evaluation of the argument of the ":throw"
command.  Unless it is caught there, the expression evaluation is abandoned.
The ":throw" command then does not throw a new exception.
<pre>   Example: ><p></pre>

<pre>	:function! Foo(arg)</pre>
<pre>	:  try</pre>
<pre>	:    throw a:arg</pre>
<pre>	:  catch /foo/</pre>
<pre>	:  endtry</pre>
<pre>	:  return 1</pre>
<pre>	:endfunction</pre>
<pre>	:</pre>
<pre>	:function! Bar()</pre>
<pre>	:  echo "in Bar"</pre>
<pre>	:  return 4710</pre>
<pre>	:endfunction</pre>
<pre>	:</pre>
<pre>	:throw Foo("arrgh") + Bar()<p></pre>

This throws "arrgh", and "in Bar" is not displayed since Bar() is not
executed. >
<pre>	:throw Foo("foo") + Bar()</pre>
however displays "in Bar" and throws 4711.<p>

Any other command that takes an expression as argument might also be
abandoned by an (uncaught) exception during the expression evaluation.  The
exception is then propagated to the caller of the command.
<pre>   Example: ><p></pre>

<pre>	:if Foo("arrgh")</pre>
<pre>	:  echo "then"</pre>
<pre>	:else</pre>
<pre>	:  echo "else"</pre>
<pre>	:endif<p></pre>

Here neither of "then" or "else" is displayed.<p>

<pre>							*catch-order*</pre>
Exceptions can be caught by a try conditional with one or more |:catch|
commands, see |try-conditionals|.   The values to be caught by each ":catch"
command can be specified as a pattern argument.  The subsequent catch clause
gets executed when a matching exception is caught.
<pre>   Example: ><p></pre>

<pre>	:function! Foo(value)</pre>
<pre>	:  try</pre>
<pre>	:    throw a:value</pre>
<pre>	:  catch /^\d\+$/</pre>
<pre>	:    echo "Number thrown"</pre>
<pre>	:  catch /.*/</pre>
<pre>	:    echo "String thrown"</pre>
<pre>	:  endtry</pre>
<pre>	:endfunction</pre>
<pre>	:</pre>
<pre>	:call Foo(0x1267)</pre>
<pre>	:call Foo('string')<p></pre>

The first call to Foo() displays "Number thrown", the second "String thrown".
An exception is matched against the ":catch" commands in the order they are
specified.  Only the first match counts.  So you should place the more
specific ":catch" first.  The following order does not make sense: ><p>

<pre>	:  catch /.*/</pre>
<pre>	:    echo "String thrown"</pre>
<pre>	:  catch /^\d\+$/</pre>
<pre>	:    echo "Number thrown"<p></pre>

The first ":catch" here matches always, so that the second catch clause is
never taken.<p>

<pre>							*throw-variables*</pre>
If you catch an exception by a general pattern, you may access the exact value
in the variable |v:exception|: ><p>

<pre>	:  catch /^\d\+$/</pre>
<pre>	:    echo "Number thrown.  Value is" v:exception<p></pre>

You may also be interested where an exception was thrown.  This is stored in
|v:throwpoint|.  Note that "v:exception" and "v:throwpoint" are valid for the
exception most recently caught as long it is not finished.
<pre>   Example: ><p></pre>

<pre>	:function! Caught()</pre>
<pre>	:  if v:exception != ""</pre>
<pre>	:    echo 'Caught "' . v:exception . '" in ' . v:throwpoint</pre>
<pre>	:  else</pre>
<pre>	:    echo 'Nothing caught'</pre>
<pre>	:  endif</pre>
<pre>	:endfunction</pre>
<pre>	:</pre>
<pre>	:function! Foo()</pre>
<pre>	:  try</pre>
<pre>	:    try</pre>
<pre>	:      try</pre>
<pre>	:	 throw 4711</pre>
<pre>	:      finally</pre>
<pre>	:	 call Caught()</pre>
<pre>	:      endtry</pre>
<pre>	:    catch /.*/</pre>
<pre>	:      call Caught()</pre>
<pre>	:      throw "oops"</pre>
<pre>	:    endtry</pre>
<pre>	:  catch /.*/</pre>
<pre>	:    call Caught()</pre>
<pre>	:  finally</pre>
<pre>	:    call Caught()</pre>
<pre>	:  endtry</pre>
<pre>	:endfunction</pre>
<pre>	:</pre>
<pre>	:call Foo()<p></pre>

This displays ><p>

<pre>	Nothing caught</pre>
<pre>	Caught "4711" in function Foo, line 4</pre>
<pre>	Caught "oops" in function Foo, line 10</pre>
<pre>	Nothing caught<p></pre>

A practical example:  The following command ":LineNumber" displays the line
number in the script or function where it has been used: ><p>

<pre>	:function! LineNumber()</pre>
<pre>	:    return substitute(v:throwpoint, '.*\D\(\d\+\).*', '\1', "")</pre>
<pre>	:endfunction</pre>
<pre>	:command! LineNumber try | throw "" | catch | echo LineNumber() | endtry</pre>
<
<pre>							*try-nested*</pre>
An exception that is not caught by a try conditional can be caught by
a surrounding try conditional: ><p>

<pre>	:try</pre>
<pre>	:  try</pre>
<pre>	:    throw "foo"</pre>
<pre>	:  catch /foobar/</pre>
<pre>	:    echo "foobar"</pre>
<pre>	:  finally</pre>
<pre>	:    echo "inner finally"</pre>
<pre>	:  endtry</pre>
<pre>	:catch /foo/</pre>
<pre>	:  echo "foo"</pre>
<pre>	:endtry<p></pre>

The inner try conditional does not catch the exception, just its finally
clause is executed.  The exception is then caught by the outer try
conditional.  The example displays "inner finally" and then "foo".<p>

<pre>							*throw-from-catch*</pre>
You can catch an exception and throw a new one to be caught elsewhere from the
catch clause: ><p>

<pre>	:function! Foo()</pre>
<pre>	:  throw "foo"</pre>
<pre>	:endfunction</pre>
<pre>	:</pre>
<pre>	:function! Bar()</pre>
<pre>	:  try</pre>
<pre>	:    call Foo()</pre>
<pre>	:  catch /foo/</pre>
<pre>	:    echo "Caught foo, throw bar"</pre>
<pre>	:    throw "bar"</pre>
<pre>	:  endtry</pre>
<pre>	:endfunction</pre>
<pre>	:</pre>
<pre>	:try</pre>
<pre>	:  call Bar()</pre>
<pre>	:catch /.*/</pre>
<pre>	:  echo "Caught" v:exception</pre>
<pre>	:endtry<p></pre>

This displays "Caught foo, throw bar" and then "Caught bar".<p>

<pre>							*rethrow*</pre>
There is no real rethrow in the Vim script language, but you may throw
"v:exception" instead: ><p>

<pre>	:function! Bar()</pre>
<pre>	:  try</pre>
<pre>	:    call Foo()</pre>
<pre>	:  catch /.*/</pre>
<pre>	:    echo "Rethrow" v:exception</pre>
<pre>	:    throw v:exception</pre>
<pre>	:  endtry</pre>
<pre>	:endfunction</pre>
<							*try-echoerr*
Note that this method cannot be used to "rethrow" Vim error or interrupt
exceptions, because it is not possible to fake Vim internal exceptions.
Trying so causes an error exception.  You should throw your own exception
denoting the situation.  If you want to cause a Vim error exception containing
the original error exception value, you can use the |:echoerr| command: ><p>

<pre>	:try</pre>
<pre>	:  try</pre>
<pre>	:    asdf</pre>
<pre>	:  catch /.*/</pre>
<pre>	:    echoerr v:exception</pre>
<pre>	:  endtry</pre>
<pre>	:catch /.*/</pre>
<pre>	:  echo v:exception</pre>
<pre>	:endtry<p></pre>

This code displays<p>

<pre>	Vim(echoerr):Vim:E492: Not an editor command:	asdf ~<p></pre>


CLEANUP CODE						*try-finally*<p>

Scripts often change global settings and restore them at their end.  If the
user however interrupts the script by pressing CTRL-C, the settings remain in
an inconsistent state.  The same may happen to you in the development phase of
a script when an error occurs or you explicitly throw an exception without
catching it.  You can solve these problems by using a try conditional with
a finally clause for restoring the settings.  Its execution is guaranteed on
normal control flow, on error, on an explicit ":throw", and on interrupt.
(Note that errors and interrupts from inside the try conditional are converted
to exceptions.  When not caught, they terminate the script after the finally
clause has been executed.)
Example: ><p>

<pre>	:try</pre>
<pre>	:  let s:saved_ts = &ts</pre>
<pre>	:  set ts=17</pre>
<pre>	:</pre>
<pre>	:  " Do the hard work here.</pre>
<pre>	:</pre>
<pre>	:finally</pre>
<pre>	:  let &ts = s:saved_ts</pre>
<pre>	:  unlet s:saved_ts</pre>
<pre>	:endtry<p></pre>

This method should be used locally whenever a function or part of a script
changes global settings which need to be restored on failure or normal exit of
that function or script part.<p>

<pre>							*break-finally*</pre>
Cleanup code works also when the try block or a catch clause is left by
a ":continue", ":break", ":return", or ":finish".
<pre>   Example: ><p></pre>

<pre>	:let first = 1</pre>
<pre>	:while 1</pre>
<pre>	:  try</pre>
<pre>	:    if first</pre>
<pre>	:      echo "first"</pre>
<pre>	:      let first = 0</pre>
<pre>	:      continue</pre>
<pre>	:    else</pre>
<pre>	:      throw "second"</pre>
<pre>	:    endif</pre>
<pre>	:  catch /.*/</pre>
<pre>	:    echo v:exception</pre>
<pre>	:    break</pre>
<pre>	:  finally</pre>
<pre>	:    echo "cleanup"</pre>
<pre>	:  endtry</pre>
<pre>	:  echo "still in while"</pre>
<pre>	:endwhile</pre>
<pre>	:echo "end"<p></pre>

This displays "first", "cleanup", "second", "cleanup", and "end". ><p>

<pre>	:function! Foo()</pre>
<pre>	:  try</pre>
<pre>	:    return 4711</pre>
<pre>	:  finally</pre>
<pre>	:    echo "cleanup\n"</pre>
<pre>	:  endtry</pre>
<pre>	:  echo "Foo still active"</pre>
<pre>	:endfunction</pre>
<pre>	:</pre>
<pre>	:echo Foo() "returned by Foo"<p></pre>

This displays "cleanup" and "4711 returned by Foo".  You don't need to add an
extra ":return" in the finally clause.  (Above all, this would override the
return value.)<p>

<pre>							*except-from-finally*</pre>
Using either of ":continue", ":break", ":return", ":finish", or ":throw" in
a finally clause is possible, but not recommended since it abandons the
cleanup actions for the try conditional.  But, of course, interrupt and error
exceptions might get raised from a finally clause.
<pre>   Example where an error in the finally clause stops an interrupt from</pre>
working correctly: ><p>

<pre>	:try</pre>
<pre>	:  try</pre>
<pre>	:    echo "Press CTRL-C for interrupt"</pre>
<pre>	:    while 1</pre>
<pre>	:    endwhile</pre>
<pre>	:  finally</pre>
<pre>	:    unlet novar</pre>
<pre>	:  endtry</pre>
<pre>	:catch /novar/</pre>
<pre>	:endtry</pre>
<pre>	:echo "Script still running"</pre>
<pre>	:sleep 1<p></pre>

If you need to put commands that could fail into a finally clause, you should
think about catching or ignoring the errors in these commands, see
|catch-errors| and |ignore-errors|.<p>


CATCHING ERRORS						*catch-errors*<p>

If you want to catch specific errors, you just have to put the code to be
watched in a try block and add a catch clause for the error message.  The
presence of the try conditional causes all errors to be converted to an
exception.  No message is displayed and |v:errmsg| is not set then.  To find
the right pattern for the ":catch" command, you have to know how the format of
the error exception is.
<pre>   Error exceptions have the following format: ><p></pre>

<pre>	Vim({cmdname}):{errmsg}</pre>
or >
<pre>	Vim:{errmsg}<p></pre>

{cmdname} is the name of the command that failed; the second form is used when
the command name is not known.  {errmsg} is the error message usually produced
when the error occurs outside try conditionals.  It always begins with
a capital "E", followed by a two or three-digit error number, a colon, and
a space.<p>

Examples:<p>

The command >
<pre>	:unlet novar</pre>
normally produces the error message >
<pre>	E108: No such variable: "novar"</pre>
which is converted inside try conditionals to an exception >
<pre>	Vim(unlet):E108: No such variable: "novar"<p></pre>

The command >
<pre>	:dwim</pre>
normally produces the error message >
<pre>	E492: Not an editor command: dwim</pre>
which is converted inside try conditionals to an exception >
<pre>	Vim:E492: Not an editor command: dwim<p></pre>

You can catch all ":unlet" errors by a >
<pre>	:catch /^Vim(unlet):/</pre>
or all errors for misspelled command names by a >
<pre>	:catch /^Vim:E492:/<p></pre>

Some error messages may be produced by different commands: >
<pre>	:function nofunc</pre>
and >
<pre>	:delfunction nofunc</pre>
both produce the error message >
<pre>	E128: Function name must start with a capital: nofunc</pre>
which is converted inside try conditionals to an exception >
<pre>	Vim(function):E128: Function name must start with a capital: nofunc</pre>
or >
<pre>	Vim(delfunction):E128: Function name must start with a capital: nofunc</pre>
respectively.  You can catch the error by its number independently on the
command that caused it if you use the following pattern: >
<pre>	:catch /^Vim(\a\+):E128:/<p></pre>

Some commands like >
<pre>	:let x = novar</pre>
produce multiple error messages, here: >
<pre>	E121: Undefined variable: novar</pre>
<pre>	E15: Invalid expression:  novar</pre>
Only the first is used for the exception value, since it is the most specific
one (see |except-several-errors|).  So you can catch it by >
<pre>	:catch /^Vim(\a\+):E121:/<p></pre>

You can catch all errors related to the name "nofunc" by >
<pre>	:catch /\<nofunc\>/<p></pre>

You can catch all Vim errors in the ":write" and ":read" commands by >
<pre>	:catch /^Vim(\(write\|read\)):E\d\+:/<p></pre>

You can catch all Vim errors by the pattern >
<pre>	:catch /^Vim\((\a\+)\)\=:E\d\+:/</pre>
<
<pre>							*catch-text*</pre>
NOTE: You should never catch the error message text itself: >
<pre>	:catch /No such variable/</pre>
only works in the English locale, but not when the user has selected
a different language by the |:language| command.  It is however helpful to
cite the message text in a comment: >
<pre>	:catch /^Vim(\a\+):E108:/   " No such variable<p></pre>


IGNORING ERRORS						*ignore-errors*<p>

You can ignore errors in a specific Vim command by catching them locally: ><p>

<pre>	:try</pre>
<pre>	:  write</pre>
<pre>	:catch</pre>
<pre>	:endtry<p></pre>

But you are strongly recommended NOT to use this simple form, since it could
catch more than you want.  With the ":write" command, some autocommands could
be executed and cause errors not related to writing, for instance: ><p>

<pre>	:au BufWritePre * unlet novar<p></pre>

There could even be such errors you are not responsible for as a script
writer: a user of your script might have defined such autocommands.  You would
then hide the error from the user.
<pre>   It is much better to use ><p></pre>

<pre>	:try</pre>
<pre>	:  write</pre>
<pre>	:catch /^Vim(write):/</pre>
<pre>	:endtry<p></pre>

which only catches real write errors.  So catch only what you'd like to ignore
intentionally.<p>

For a single command that does not cause execution of autocommands, you could
even suppress the conversion of errors to exceptions by the ":silent!"
command: >
<pre>	:silent! nunmap k</pre>
This works also when a try conditional is active.<p>


CATCHING INTERRUPTS					*catch-interrupt*<p>

When there are active try conditionals, an interrupt (CTRL-C) is converted to
the exception "Vim:Interrupt".  You can catch it like every exception.  The
script is not terminated, then.
<pre>   Example: ><p></pre>

<pre>	:function! TASK1()</pre>
<pre>	:  sleep 10</pre>
<pre>	:endfunction<p></pre>

<pre>	:function! TASK2()</pre>
<pre>	:  sleep 20</pre>
<pre>	:endfunction<p></pre>

<pre>	:while 1</pre>
<pre>	:  let command = input("Type a command: ")</pre>
<pre>	:  try</pre>
<pre>	:    if command == ""</pre>
<pre>	:      continue</pre>
<pre>	:    elseif command == "END"</pre>
<pre>	:      break</pre>
<pre>	:    elseif command == "TASK1"</pre>
<pre>	:      call TASK1()</pre>
<pre>	:    elseif command == "TASK2"</pre>
<pre>	:      call TASK2()</pre>
<pre>	:    else</pre>
<pre>	:      echo "\nIllegal command:" command</pre>
<pre>	:      continue</pre>
<pre>	:    endif</pre>
<pre>	:  catch /^Vim:Interrupt$/</pre>
<pre>	:    echo "\nCommand interrupted"</pre>
<pre>	:    " Caught the interrupt.  Continue with next prompt.</pre>
<pre>	:  endtry</pre>
<pre>	:endwhile<p></pre>

You can interrupt a task here by pressing CTRL-C; the script then asks for
a new command.  If you press CTRL-C at the prompt, the script is terminated.<p>

For testing what happens when CTRL-C would be pressed on a specific line in
your script, use the debug mode and execute the |>quit| or |>interrupt|
command on that line.  See |debug-scripts|.<p>


CATCHING ALL						*catch-all*<p>

The commands ><p>

<pre>	:catch /.*/</pre>
<pre>	:catch //</pre>
<pre>	:catch<p></pre>

catch everything, error exceptions, interrupt exceptions and exceptions
explicitly thrown by the |:throw| command.  This is useful at the top level of
a script in order to catch unexpected things.
<pre>   Example: ><p></pre>

<pre>	:try</pre>
<pre>	:</pre>
<pre>	:  " do the hard work here</pre>
<pre>	:</pre>
<pre>	:catch /MyException/</pre>
<pre>	:</pre>
<pre>	:  " handle known problem</pre>
<pre>	:</pre>
<pre>	:catch /^Vim:Interrupt$/</pre>
<pre>	:    echo "Script interrupted"</pre>
<pre>	:catch /.*/</pre>
<pre>	:  echo "Internal error (" . v:exception . ")"</pre>
<pre>	:  echo " - occurred at " . v:throwpoint</pre>
<pre>	:endtry</pre>
<pre>	:" end of script<p></pre>

Note: Catching all might catch more things than you want.  Thus, you are
strongly encouraged to catch only for problems that you can really handle by
specifying a pattern argument to the ":catch".
<pre>   Example: Catching all could make it nearly impossible to interrupt a script</pre>
by pressing CTRL-C: ><p>

<pre>	:while 1</pre>
<pre>	:  try</pre>
<pre>	:    sleep 1</pre>
<pre>	:  catch</pre>
<pre>	:  endtry</pre>
<pre>	:endwhile<p></pre>


EXCEPTIONS AND AUTOCOMMANDS				*except-autocmd*<p>

Exceptions may be used during execution of autocommands.  Example: ><p>

<pre>	:autocmd User x try</pre>
<pre>	:autocmd User x   throw "Oops!"</pre>
<pre>	:autocmd User x catch</pre>
<pre>	:autocmd User x   echo v:exception</pre>
<pre>	:autocmd User x endtry</pre>
<pre>	:autocmd User x throw "Arrgh!"</pre>
<pre>	:autocmd User x echo "Should not be displayed"</pre>
<pre>	:</pre>
<pre>	:try</pre>
<pre>	:  doautocmd User x</pre>
<pre>	:catch</pre>
<pre>	:  echo v:exception</pre>
<pre>	:endtry<p></pre>

This displays "Oops!" and "Arrgh!".<p>

<pre>							*except-autocmd-Pre*</pre>
For some commands, autocommands get executed before the main action of the
command takes place.  If an exception is thrown and not caught in the sequence
of autocommands, the sequence and the command that caused its execution are
abandoned and the exception is propagated to the caller of the command.
<pre>   Example: ><p></pre>

<pre>	:autocmd BufWritePre * throw "FAIL"</pre>
<pre>	:autocmd BufWritePre * echo "Should not be displayed"</pre>
<pre>	:</pre>
<pre>	:try</pre>
<pre>	:  write</pre>
<pre>	:catch</pre>
<pre>	:  echo "Caught:" v:exception "from" v:throwpoint</pre>
<pre>	:endtry<p></pre>

Here, the ":write" command does not write the file currently being edited (as
you can see by checking 'modified'), since the exception from the BufWritePre
autocommand abandons the ":write".  The exception is then caught and the
script displays: ><p>

<pre>	Caught: FAIL from BufWrite Auto commands for "*"</pre>
<
<pre>							*except-autocmd-Post*</pre>
For some commands, autocommands get executed after the main action of the
command has taken place.  If this main action fails and the command is inside
an active try conditional, the autocommands are skipped and an error exception
is thrown that can be caught by the caller of the command.
<pre>   Example: ><p></pre>

<pre>	:autocmd BufWritePost * echo "File successfully written!"</pre>
<pre>	:</pre>
<pre>	:try</pre>
<pre>	:  write /i/m/p/o/s/s/i/b/l/e</pre>
<pre>	:catch</pre>
<pre>	:  echo v:exception</pre>
<pre>	:endtry<p></pre>

This just displays: ><p>

<pre>	Vim(write):E212: Can't open file for writing (/i/m/p/o/s/s/i/b/l/e)<p></pre>

If you really need to execute the autocommands even when the main action
fails, trigger the event from the catch clause.
<pre>   Example: ><p></pre>

<pre>	:autocmd BufWritePre  * set noreadonly</pre>
<pre>	:autocmd BufWritePost * set readonly</pre>
<pre>	:</pre>
<pre>	:try</pre>
<pre>	:  write /i/m/p/o/s/s/i/b/l/e</pre>
<pre>	:catch</pre>
<pre>	:  doautocmd BufWritePost /i/m/p/o/s/s/i/b/l/e</pre>
<pre>	:endtry</pre>
<
You can also use ":silent!": ><p>

<pre>	:let x = "ok"</pre>
<pre>	:let v:errmsg = ""</pre>
<pre>	:autocmd BufWritePost * if v:errmsg != ""</pre>
<pre>	:autocmd BufWritePost *   let x = "after fail"</pre>
<pre>	:autocmd BufWritePost * endif</pre>
<pre>	:try</pre>
<pre>	:  silent! write /i/m/p/o/s/s/i/b/l/e</pre>
<pre>	:catch</pre>
<pre>	:endtry</pre>
<pre>	:echo x<p></pre>

This displays "after fail".<p>

If the main action of the command does not fail, exceptions from the
autocommands will be catchable by the caller of the command:  ><p>

<pre>	:autocmd BufWritePost * throw ":-("</pre>
<pre>	:autocmd BufWritePost * echo "Should not be displayed"</pre>
<pre>	:</pre>
<pre>	:try</pre>
<pre>	:  write</pre>
<pre>	:catch</pre>
<pre>	:  echo v:exception</pre>
<pre>	:endtry</pre>
<
<pre>							*except-autocmd-Cmd*</pre>
For some commands, the normal action can be replaced by a sequence of
autocommands.  Exceptions from that sequence will be catchable by the caller
of the command.
<pre>   Example:  For the ":write" command, the caller cannot know whether the file</pre>
had actually been written when the exception occurred.  You need to tell it in
some way. ><p>

<pre>	:if !exists("cnt")</pre>
<pre>	:  let cnt = 0</pre>
<pre>	:</pre>
<pre>	:  autocmd BufWriteCmd * if &modified</pre>
<pre>	:  autocmd BufWriteCmd *   let cnt = cnt + 1</pre>
<pre>	:  autocmd BufWriteCmd *   if cnt % 3 == 2</pre>
<pre>	:  autocmd BufWriteCmd *     throw "BufWriteCmdError"</pre>
<pre>	:  autocmd BufWriteCmd *   endif</pre>
<pre>	:  autocmd BufWriteCmd *   write | set nomodified</pre>
<pre>	:  autocmd BufWriteCmd *   if cnt % 3 == 0</pre>
<pre>	:  autocmd BufWriteCmd *     throw "BufWriteCmdError"</pre>
<pre>	:  autocmd BufWriteCmd *   endif</pre>
<pre>	:  autocmd BufWriteCmd *   echo "File successfully written!"</pre>
<pre>	:  autocmd BufWriteCmd * endif</pre>
<pre>	:endif</pre>
<pre>	:</pre>
<pre>	:try</pre>
<pre>	:	write</pre>
<pre>	:catch /^BufWriteCmdError$/</pre>
<pre>	:  if &modified</pre>
<pre>	:    echo "Error on writing (file contents not changed)"</pre>
<pre>	:  else</pre>
<pre>	:    echo "Error after writing"</pre>
<pre>	:  endif</pre>
<pre>	:catch /^Vim(write):/</pre>
<pre>	:    echo "Error on writing"</pre>
<pre>	:endtry<p></pre>

When this script is sourced several times after making changes, it displays
first >
<pre>	File successfully written!</pre>
then >
<pre>	Error on writing (file contents not changed)</pre>
then >
<pre>	Error after writing</pre>
etc.<p>

<pre>							*except-autocmd-ill*</pre>
You cannot spread a try conditional over autocommands for different events.
The following code is ill-formed: ><p>

<pre>	:autocmd BufWritePre  * try</pre>
<pre>	:</pre>
<pre>	:autocmd BufWritePost * catch</pre>
<pre>	:autocmd BufWritePost *   echo v:exception</pre>
<pre>	:autocmd BufWritePost * endtry</pre>
<pre>	:</pre>
<pre>	:write<p></pre>


EXCEPTION HIERARCHIES AND PARAMETERIZED EXCEPTIONS	*except-hier-param*<p>

Some programming languages allow to use hierarchies of exception classes or to
pass additional information with the object of an exception class.  You can do
similar things in Vim.
<pre>   In order to throw an exception from a hierarchy, just throw the complete</pre>
class name with the components separated by a colon, for instance throw the
string "EXCEPT:MATHERR:OVERFLOW" for an overflow in a mathematical library.
<pre>   When you want to pass additional information with your exception class, add</pre>
it in parentheses, for instance throw the string "EXCEPT:IO:WRITEERR(myfile)"
for an error when writing "myfile".
<pre>   With the appropriate patterns in the ":catch" command, you can catch for</pre>
base classes or derived classes of your hierarchy.  Additional information in
parentheses can be cut out from |v:exception| with the ":substitute" command.
<pre>   Example: ><p></pre>

<pre>	:function! CheckRange(a, func)</pre>
<pre>	:  if a:a < 0</pre>
<pre>	:    throw "EXCEPT:MATHERR:RANGE(" . a:func . ")"</pre>
<pre>	:  endif</pre>
<pre>	:endfunction</pre>
<pre>	:</pre>
<pre>	:function! Add(a, b)</pre>
<pre>	:  call CheckRange(a:a, "Add")</pre>
<pre>	:  call CheckRange(a:b, "Add")</pre>
<pre>	:  let c = a:a + a:b</pre>
<pre>	:  if c < 0</pre>
<pre>	:    throw "EXCEPT:MATHERR:OVERFLOW"</pre>
<pre>	:  endif</pre>
<pre>	:  return c</pre>
<pre>	:endfunction</pre>
<pre>	:</pre>
<pre>	:function! Div(a, b)</pre>
<pre>	:  call CheckRange(a:a, "Div")</pre>
<pre>	:  call CheckRange(a:b, "Div")</pre>
<pre>	:  if (a:b == 0)</pre>
<pre>	:    throw "EXCEPT:MATHERR:ZERODIV"</pre>
<pre>	:  endif</pre>
<pre>	:  return a:a / a:b</pre>
<pre>	:endfunction</pre>
<pre>	:</pre>
<pre>	:function! Write(file)</pre>
<pre>	:  try</pre>
<pre>	:    execute "write" fnameescape(a:file)</pre>
<pre>	:  catch /^Vim(write):/</pre>
<pre>	:    throw "EXCEPT:IO(" . getcwd() . ", " . a:file . "):WRITEERR"</pre>
<pre>	:  endtry</pre>
<pre>	:endfunction</pre>
<pre>	:</pre>
<pre>	:try</pre>
<pre>	:</pre>
<pre>	:  " something with arithmetics and I/O</pre>
<pre>	:</pre>
<pre>	:catch /^EXCEPT:MATHERR:RANGE/</pre>
<pre>	:  let function = substitute(v:exception, '.*(\(\a\+\)).*', '\1', "")</pre>
<pre>	:  echo "Range error in" function</pre>
<pre>	:</pre>
<pre>	:catch /^EXCEPT:MATHERR/	" catches OVERFLOW and ZERODIV</pre>
<pre>	:  echo "Math error"</pre>
<pre>	:</pre>
<pre>	:catch /^EXCEPT:IO/</pre>
<pre>	:  let dir = substitute(v:exception, '.*(\(.\+\),\s*.\+).*', '\1', "")</pre>
<pre>	:  let file = substitute(v:exception, '.*(.\+,\s*\(.\+\)).*', '\1', "")</pre>
<pre>	:  if file !~ '^/'</pre>
<pre>	:    let file = dir . "/" . file</pre>
<pre>	:  endif</pre>
<pre>	:  echo 'I/O error for "' . file . '"'</pre>
<pre>	:</pre>
<pre>	:catch /^EXCEPT/</pre>
<pre>	:  echo "Unspecified error"</pre>
<pre>	:</pre>
<pre>	:endtry<p></pre>

The exceptions raised by Vim itself (on error or when pressing CTRL-C) use
a flat hierarchy:  they are all in the "Vim" class.  You cannot throw yourself
exceptions with the "Vim" prefix; they are reserved for Vim.
<pre>   Vim error exceptions are parameterized with the name of the command that</pre>
failed, if known.  See |catch-errors|.<p>


PECULIARITIES
<pre>							*except-compat*</pre>
The exception handling concept requires that the command sequence causing the
exception is aborted immediately and control is transferred to finally clauses
and/or a catch clause.<p>

In the Vim script language there are cases where scripts and functions
continue after an error: in functions without the "abort" flag or in a command
after ":silent!", control flow goes to the following line, and outside
functions, control flow goes to the line following the outermost ":endwhile"
or ":endif".  On the other hand, errors should be catchable as exceptions
(thus, requiring the immediate abortion).<p>

This problem has been solved by converting errors to exceptions and using
immediate abortion (if not suppressed by ":silent!") only when a try
conditional is active.  This is no restriction since an (error) exception can
be caught only from an active try conditional.  If you want an immediate
termination without catching the error, just use a try conditional without
catch clause.  (You can cause cleanup code being executed before termination
by specifying a finally clause.)<p>

When no try conditional is active, the usual abortion and continuation
behavior is used instead of immediate abortion.  This ensures compatibility of
scripts written for Vim 6.1 and earlier.<p>

However, when sourcing an existing script that does not use exception handling
commands (or when calling one of its functions) from inside an active try
conditional of a new script, you might change the control flow of the existing
script on error.  You get the immediate abortion on error and can catch the
error in the new script.  If however the sourced script suppresses error
messages by using the ":silent!" command (checking for errors by testing
|v:errmsg| if appropriate), its execution path is not changed.  The error is
not converted to an exception.  (See |:silent|.)  So the only remaining cause
where this happens is for scripts that don't care about errors and produce
error messages.  You probably won't want to use such code from your new
scripts.<p>

<pre>							*except-syntax-err*</pre>
Syntax errors in the exception handling commands are never caught by any of
the ":catch" commands of the try conditional they belong to.  Its finally
clauses, however, is executed.
<pre>   Example: ><p></pre>

<pre>	:try</pre>
<pre>	:  try</pre>
<pre>	:    throw 4711</pre>
<pre>	:  catch /\(/</pre>
<pre>	:    echo "in catch with syntax error"</pre>
<pre>	:  catch</pre>
<pre>	:    echo "inner catch-all"</pre>
<pre>	:  finally</pre>
<pre>	:    echo "inner finally"</pre>
<pre>	:  endtry</pre>
<pre>	:catch</pre>
<pre>	:  echo 'outer catch-all caught "' . v:exception . '"'</pre>
<pre>	:  finally</pre>
<pre>	:    echo "outer finally"</pre>
<pre>	:endtry<p></pre>

This displays: >
<pre>    inner finally</pre>
<pre>    outer catch-all caught "Vim(catch):E54: Unmatched \("</pre>
<pre>    outer finally</pre>
The original exception is discarded and an error exception is raised, instead.<p>

<pre>							*except-single-line*</pre>
The ":try", ":catch", ":finally", and ":endtry" commands can be put on
a single line, but then syntax errors may make it difficult to recognize the
"catch" line, thus you better avoid this.
<pre>   Example: ></pre>
<pre>	:try | unlet! foo # | catch | endtry</pre>
raises an error exception for the trailing characters after the ":unlet!"
argument, but does not see the ":catch" and ":endtry" commands, so that the
error exception is discarded and the "E488: Trailing characters" message gets
displayed.<p>

<pre>							*except-several-errors*</pre>
When several errors appear in a single command, the first error message is
usually the most specific one and therefor converted to the error exception.
<pre>   Example: ></pre>
<pre>	echo novar</pre>
causes >
<pre>	E121: Undefined variable: novar</pre>
<pre>	E15: Invalid expression: novar</pre>
The value of the error exception inside try conditionals is: >
<pre>	Vim(echo):E121: Undefined variable: novar</pre>
<							*except-syntax-error*
But when a syntax error is detected after a normal error in the same command,
the syntax error is used for the exception being thrown.
<pre>   Example: ></pre>
<pre>	unlet novar #</pre>
causes >
<pre>	E108: No such variable: "novar"</pre>
<pre>	E488: Trailing characters</pre>
The value of the error exception inside try conditionals is: >
<pre>	Vim(unlet):E488: Trailing characters</pre>
This is done because the syntax error might change the execution path in a way
not intended by the user.  Example: >
<pre>	try</pre>
<pre>	    try | unlet novar # | catch | echo v:exception | endtry</pre>
<pre>	catch /.*/</pre>
<pre>	    echo "outer catch:" v:exception</pre>
<pre>	endtry</pre>
This displays "outer catch: Vim(unlet):E488: Trailing characters", and then
a "E600: Missing :endtry" error message is given, see |except-single-line|.<p>

* Examples						*eval-examples*<p>

Printing in Binary ~
>
<pre>  :" The function Nr2Bin() returns the binary string representation of a number.</pre>
<pre>  :func Nr2Bin(nr)</pre>
<pre>  :  let n = a:nr</pre>
<pre>  :  let r = ""</pre>
<pre>  :  while n</pre>
<pre>  :    let r = '01'[n % 2] . r</pre>
<pre>  :    let n = n / 2</pre>
<pre>  :  endwhile</pre>
<pre>  :  return r</pre>
<pre>  :endfunc<p></pre>

<pre>  :" The function String2Bin() converts each character in a string to a</pre>
<pre>  :" binary string, separated with dashes.</pre>
<pre>  :func String2Bin(str)</pre>
<pre>  :  let out = ''</pre>
<pre>  :  for ix in range(strlen(a:str))</pre>
<pre>  :    let out = out . '-' . Nr2Bin(char2nr(a:str[ix]))</pre>
<pre>  :  endfor</pre>
<pre>  :  return out[1:]</pre>
<pre>  :endfunc<p></pre>

Example of its use: >
<pre>  :echo Nr2Bin(32)</pre>
result: "100000" >
<pre>  :echo String2Bin("32")</pre>
result: "110011-110010"<p>


Sorting lines ~<p>

This example sorts lines with a specific compare function. ><p>

<pre>  :func SortBuffer()</pre>
<pre>  :  let lines = getline(1, '$')</pre>
<pre>  :  call sort(lines, function("Strcmp"))</pre>
<pre>  :  call setline(1, lines)</pre>
<pre>  :endfunction<p></pre>

As a one-liner: >
<pre>  :call setline(1, sort(getline(1, '$'), function("Strcmp")))<p></pre>


scanf() replacement ~
<pre>							*sscanf*</pre>
There is no sscanf() function in Vim.  If you need to extract parts from a
line, you can use matchstr() and substitute() to do it.  This example shows
how to get the file name, line number and column number out of a line like
"foobar.txt, 123, 45". >
<pre>   :" Set up the match bit</pre>
<pre>   :let mx='\(\f\+\),\s*\(\d\+\),\s*\(\d\+\)'</pre>
<pre>   :"get the part matching the whole expression</pre>
<pre>   :let l = matchstr(line, mx)</pre>
<pre>   :"get each item out of the match</pre>
<pre>   :let file = substitute(l, mx, '\1', '')</pre>
<pre>   :let lnum = substitute(l, mx, '\2', '')</pre>
<pre>   :let col = substitute(l, mx, '\3', '')<p></pre>

The input is in the variable "line", the results in the variables "file",
"lnum" and "col". (idea from Michael Geddes)<p>


getting the scriptnames in a Dictionary ~
<pre>						*scriptnames-dictionary*</pre>
The |:scriptnames| command can be used to get a list of all script files that
have been sourced.  There is no equivalent function or variable for this
(because it's rarely needed).  In case you need to manipulate the list this
code can be used: >
<pre>    " Get the output of ":scriptnames" in the scriptnames_output variable.</pre>
<pre>    let scriptnames_output = ''</pre>
<pre>    redir => scriptnames_output</pre>
<pre>    silent scriptnames</pre>
<pre>    redir END<p></pre>

<pre>    " Split the output into lines and parse each line.	Add an entry to the</pre>
<pre>    " "scripts" dictionary.</pre>
<pre>    let scripts = {}</pre>
<pre>    for line in split(scriptnames_output, "\n")</pre>
<pre>      " Only do non-blank lines.</pre>
<pre>      if line =~ '\S'</pre>
<pre>	" Get the first number in the line.</pre>
<pre>	let nr = matchstr(line, '\d\+')</pre>
<pre>	" Get the file name, remove the script number " 123: ".</pre>
<pre>	let name = substitute(line, '.\+:\s*', '', '')</pre>
<pre>	" Add an item to the Dictionary</pre>
<pre>	let scripts[nr] = name</pre>
<pre>      endif</pre>
<pre>    endfor</pre>
<pre>    unlet scriptnames_output<p></pre>

* Vim script versions		*vimscript-version* *vimscript-versions*
<pre>							*scriptversion*</pre>
Over time many features have been added to Vim script.  This includes Ex
commands, functions, variable types, etc.  Each individual feature can be
checked with the |has()| and |exists()| functions.<p>

Sometimes old syntax of functionality gets in the way of making Vim better.
When support is taken away this will break older Vim scripts.  To make this
explicit the |:scriptversion| command can be used.  When a Vim script is not
compatible with older versions of Vim this will give an explicit error,
instead of failing in mysterious ways.<p>

<pre>							*scriptversion-1*  ></pre>
<pre> :scriptversion 1</pre>
<	This is the original Vim script, same as not using a |:scriptversion|
<pre>	command.  Can be used to go back to old syntax for a range of lines.</pre>
<pre>	Test for support with: ></pre>
<pre>		has('vimscript-1')<p></pre>

<							*scriptversion-2*  >
<pre> :scriptversion 2</pre>
<	String concatenation with "." is not supported, use ".." instead.
<pre>	This avoids the ambiguity using "." for Dict member access and</pre>
<pre>	floating point numbers.  Now ".5" means the number 0.5.<p></pre>

<pre>							*scriptversion-3*  ></pre>
<pre> :scriptversion 3</pre>
<	All |vim-variable|s must be prefixed by "v:".  E.g. "version" doesn't
<pre>	work as |v:version| anymore, it can be used as a normal variable.</pre>
<pre>	Same for some obvious names as "count" and others.<p></pre>

<pre>	Test for support with: ></pre>
<pre>		has('vimscript-3')</pre>
<
<pre>							*scriptversion-4*  ></pre>
<pre> :scriptversion 4</pre>
<	Numbers with a leading zero are not recognized as octal.  With the
<pre>	previous version you get: ></pre>
<pre>		echo 017   " displays 15</pre>
<pre>		echo 018   " displays 18</pre>
<	with script version 4: >
<pre>		echo 017   " displays 17</pre>
<pre>		echo 018   " displays 18</pre>
<	Also, it is possible to use single quotes inside numbers to make them
<pre>	easier to read: ></pre>
<pre>		echo 1'000'000</pre>
<	The quotes must be surrounded by digits.<p>

<pre>	Test for support with: ></pre>
<pre>		has('vimscript-4')<p></pre>

* No +eval feature				*no-eval-feature*<p>

When the |+eval| feature was disabled at compile time, none of the expression
evaluation commands are available.  To prevent this from causing Vim scripts
to generate all kinds of errors, the ":if" and ":endif" commands are still
recognized, though the argument of the ":if" and everything between the ":if"
and the matching ":endif" is ignored.  Nesting of ":if" blocks is allowed, but
only if the commands are at the start of the line.  The ":else" command is not
recognized.<p>

Example of how to avoid executing commands when the |+eval| feature is
missing: ><p>

<pre>	:if 1</pre>
<pre>	:  echo "Expression evaluation is compiled in"</pre>
<pre>	:else</pre>
<pre>	:  echo "You will _never_ see this message"</pre>
<pre>	:endif<p></pre>

To execute a command only when the |+eval| feature is disabled can be done in
two ways.  The simplest is to exit the script (or Vim) prematurely: >
<pre>	if 1</pre>
<pre>	   echo "commands executed with +eval"</pre>
<pre>	   finish</pre>
<pre>	endif</pre>
<pre>	args  " command executed without +eval<p></pre>

If you do not want to abort loading the script you can use a trick, as this
example shows: ><p>

<pre>	silent! while 0</pre>
<pre>	  set history=111</pre>
<pre>	silent! endwhile<p></pre>

When the |+eval| feature is available the command is skipped because of the
"while 0".  Without the |+eval| feature the "while 0" is an error, which is
silently ignored, and the command is executed.<p>

* The sandbox					*eval-sandbox* *sandbox* *E48*<p>

The 'foldexpr', 'formatexpr', 'includeexpr', 'indentexpr', 'statusline' and
'foldtext' options may be evaluated in a sandbox.  This means that you are
protected from these expressions having nasty side effects.  This gives some
safety for when these options are set from a modeline.  It is also used when
the command from a tags file is executed and for CTRL-R = in the command line.
The sandbox is also used for the |:sandbox| command.<p>

These items are not allowed in the sandbox:
<pre>	- changing the buffer text</pre>
<pre>	- defining or changing mapping, autocommands, user commands</pre>
<pre>	- setting certain options (see |option-summary|)</pre>
<pre>	- setting certain v: variables (see |v:var|)  *E794*</pre>
<pre>	- executing a shell command</pre>
<pre>	- reading or writing a file</pre>
<pre>	- jumping to another buffer or editing a file</pre>
<pre>	- executing Python, Perl, etc. commands</pre>
This is not guaranteed 100% secure, but it should block most attacks.<p>

<pre>							*:san* *:sandbox*</pre>
:san[dbox] {cmd}	Execute {cmd} in the sandbox.  Useful to evaluate an
<pre>			option that may have been set from a modeline, e.g.</pre>
<pre>			'foldexpr'.<p></pre>

<pre>							*sandbox-option*</pre>
A few options contain an expression.  When this expression is evaluated it may
have to be done in the sandbox to avoid a security risk.  But the sandbox is
restrictive, thus this only happens when the option was set from an insecure
location.  Insecure in this context are:
<pre>- sourcing a .vimrc or .exrc in the current directory</pre>
<pre>- while executing in the sandbox</pre>
<pre>- value coming from a modeline</pre>
<pre>- executing a function that was defined in the sandbox<p></pre>

Note that when in the sandbox and saving an option value and restoring it, the
option will still be marked as it was set in the sandbox.<p>

* Textlock							*textlock*<p>

In a few situations it is not allowed to change the text in the buffer, jump
to another window and some other things that might confuse or break what Vim
is currently doing.  This mostly applies to things that happen when Vim is
actually doing something else.  For example, evaluating the 'balloonexpr' may
happen any moment the mouse cursor is resting at some position.<p>

This is not allowed when the textlock is active:
<pre>	- changing the buffer text</pre>
<pre>	- jumping to another buffer or window</pre>
<pre>	- editing another file</pre>
<pre>	- closing a window or quitting Vim</pre>
<pre>	- etc.<p></pre>


<pre> vim:tw=78:ts=8:noet:ft=help:norl:</pre>
